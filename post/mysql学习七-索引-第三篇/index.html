<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='前言 在现代互联网的数据库表中，邮箱应该是一个非常常见的字段，如何在这样一个字段上加索引，也是一个需要考量的问题。
背景 假设现在在维护一个支持邮箱登录的系统，用户表是这么定义的：
mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; 由于可以支持邮箱登录，因此在后端中大概率会出现如下的SQL语句：
mysql&amp;gt; select f1, f2 from SUser where email=&amp;#39;xxx&amp;#39;; 而如果email这个字段上没有设置索引，那么MySQL在执行时将会进行全表扫描，这显然在数据量庞大时是不可接受的。MySQL是支持前缀索引的，也就是说可以定义字符串的一部分作为索引。默认情况下，如果创建索引不指定前缀长度，那么索引就会包含整个字符串。
比如下面这两个语句就是在email字段上创建索引
mysql&amp;gt; alter table SUser add index index1(email); mysql&amp;gt; alter table SUser add index index2(email(6)); 第一个语句就是默认创建，使用整个字符串作为索引；第二个语句中，对于每个记录都是只取前6个字节。
两种索引结构在数据结构和存储上分别如下图所示：
email 索引结构 eamil(6) 索引结构 从图中可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。 但同时带来的损失是，可能会增加额外的记录扫描次数。在这两种索引的建立下，对于以下这个语句，索引定义的执行分别如下：
select id,name,email from SUser where email=&amp;#39;zhangssxyz@xxx.com&amp;#39;; 如果使用的是index1 （即email整个字符串的索引结构），执行顺序是这样的：
从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值； 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集； 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=&amp;lsquo;zhangssxyz@xxx.com’的条件了，循环结束。 这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。
如果使用的是index2 （即email(6)索引结构），执行顺序是这样的：
从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃； 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集； 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取4次数据，也就是扫描了4行。从中可以发现，使用前缀索引可能会导致查询语句读数据的次数变多。因此， 如果能够在使用前缀索引时，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。'><title>MySQL学习（七） 索引 第三篇</title>

<link rel='canonical' href='https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%83-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%B8%89%E7%AF%87/'>

<link rel="stylesheet" href="/scss/style.min.2d5c7b7fe00d3723b47df5ddeea35027ba1a58ec45a6d797c9c0e626dd65ac00.css"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script>
    
    $(window).scroll(function() {
    if ($(this).scrollTop()) {
        $('#go-top').fadeIn();
    } else {
        $('#go-top').fadeOut();
    }
    });

    
    $('#go-top').click(function() {
    $('html, body').animate({scrollTop: 0}, 1000);
    return false;
    });
</script>




<meta property='og:title' content='MySQL学习（七） 索引 第三篇'>
<meta property='og:description' content='前言 在现代互联网的数据库表中，邮箱应该是一个非常常见的字段，如何在这样一个字段上加索引，也是一个需要考量的问题。
背景 假设现在在维护一个支持邮箱登录的系统，用户表是这么定义的：
mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; 由于可以支持邮箱登录，因此在后端中大概率会出现如下的SQL语句：
mysql&amp;gt; select f1, f2 from SUser where email=&amp;#39;xxx&amp;#39;; 而如果email这个字段上没有设置索引，那么MySQL在执行时将会进行全表扫描，这显然在数据量庞大时是不可接受的。MySQL是支持前缀索引的，也就是说可以定义字符串的一部分作为索引。默认情况下，如果创建索引不指定前缀长度，那么索引就会包含整个字符串。
比如下面这两个语句就是在email字段上创建索引
mysql&amp;gt; alter table SUser add index index1(email); mysql&amp;gt; alter table SUser add index index2(email(6)); 第一个语句就是默认创建，使用整个字符串作为索引；第二个语句中，对于每个记录都是只取前6个字节。
两种索引结构在数据结构和存储上分别如下图所示：
email 索引结构 eamil(6) 索引结构 从图中可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。 但同时带来的损失是，可能会增加额外的记录扫描次数。在这两种索引的建立下，对于以下这个语句，索引定义的执行分别如下：
select id,name,email from SUser where email=&amp;#39;zhangssxyz@xxx.com&amp;#39;; 如果使用的是index1 （即email整个字符串的索引结构），执行顺序是这样的：
从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值； 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集； 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=&amp;lsquo;zhangssxyz@xxx.com’的条件了，循环结束。 这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。
如果使用的是index2 （即email(6)索引结构），执行顺序是这样的：
从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃； 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集； 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取4次数据，也就是扫描了4行。从中可以发现，使用前缀索引可能会导致查询语句读数据的次数变多。因此， 如果能够在使用前缀索引时，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。'>
<meta property='og:url' content='https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%83-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%B8%89%E7%AF%87/'>
<meta property='og:site_name' content='墨纹'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='MySQL' /><meta property='article:tag' content='技术' /><meta property='article:published_time' content='2026-02-08T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2026-02-08T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="MySQL学习（七） 索引 第三篇">
<meta name="twitter:description" content="前言 在现代互联网的数据库表中，邮箱应该是一个非常常见的字段，如何在这样一个字段上加索引，也是一个需要考量的问题。
背景 假设现在在维护一个支持邮箱登录的系统，用户表是这么定义的：
mysql&amp;gt; create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=innodb; 由于可以支持邮箱登录，因此在后端中大概率会出现如下的SQL语句：
mysql&amp;gt; select f1, f2 from SUser where email=&amp;#39;xxx&amp;#39;; 而如果email这个字段上没有设置索引，那么MySQL在执行时将会进行全表扫描，这显然在数据量庞大时是不可接受的。MySQL是支持前缀索引的，也就是说可以定义字符串的一部分作为索引。默认情况下，如果创建索引不指定前缀长度，那么索引就会包含整个字符串。
比如下面这两个语句就是在email字段上创建索引
mysql&amp;gt; alter table SUser add index index1(email); mysql&amp;gt; alter table SUser add index index2(email(6)); 第一个语句就是默认创建，使用整个字符串作为索引；第二个语句中，对于每个记录都是只取前6个字节。
两种索引结构在数据结构和存储上分别如下图所示：
email 索引结构 eamil(6) 索引结构 从图中可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。 但同时带来的损失是，可能会增加额外的记录扫描次数。在这两种索引的建立下，对于以下这个语句，索引定义的执行分别如下：
select id,name,email from SUser where email=&amp;#39;zhangssxyz@xxx.com&amp;#39;; 如果使用的是index1 （即email整个字符串的索引结构），执行顺序是这样的：
从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值； 到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集； 取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=&amp;lsquo;zhangssxyz@xxx.com’的条件了，循环结束。 这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。
如果使用的是index2 （即email(6)索引结构），执行顺序是这样的：
从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1； 到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃； 取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集； 重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 在这个过程中，要回主键索引取4次数据，也就是扫描了4行。从中可以发现，使用前缀索引可能会导致查询语句读数据的次数变多。因此， 如果能够在使用前缀索引时，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><style>
    :root {
        --article-font-family: "Noto Serif SC", var(--base-font-family);
    }
</style>

<script> 
		(function () {
		    const customFont = document.createElement('link');
		    customFont.href = "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap"; 
		    customFont.type = "text/css";
		    customFont.rel = "stylesheet";
		
		    document.head.appendChild(customFont);
		}());
</script>
<style>
	h1 {
		letter-spacing: 6px;
	}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%AD%A6%E4%B9%A0/" >
                学习
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%83-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%B8%89%E7%AF%87/">MySQL学习（七） 索引 第三篇</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 08, 2026</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="前言">前言</h2>
<p>在现代互联网的数据库表中，邮箱应该是一个非常常见的字段，如何在这样一个字段上加索引，也是一个需要考量的问题。</p>
<h2 id="背景">背景</h2>
<p>假设现在在维护一个支持邮箱登录的系统，用户表是这么定义的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> SUser(
</span></span><span style="display:flex;"><span>ID bigint unsigned <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
</span></span><span style="display:flex;"><span>email varchar(<span style="color:#ae81ff">64</span>),
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>)engine<span style="color:#f92672">=</span>innodb;
</span></span></code></pre></div><p>由于可以支持邮箱登录，因此在后端中大概率会出现如下的SQL语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> f1, f2 <span style="color:#66d9ef">from</span> SUser <span style="color:#66d9ef">where</span> email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;xxx&#39;</span>;
</span></span></code></pre></div><p>而如果email这个字段上没有设置索引，那么MySQL在执行时将会进行全表扫描，这显然在数据量庞大时是不可接受的。MySQL是支持前缀索引的，也就是说可以定义字符串的一部分作为索引。默认情况下，如果创建索引不指定前缀长度，那么索引就会包含整个字符串。</p>
<p>比如下面这两个语句就是在email字段上创建索引</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> SUser <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span> index1(email);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> SUser <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span> index2(email(<span style="color:#ae81ff">6</span>));
</span></span></code></pre></div><p>第一个语句就是默认创建，使用整个字符串作为索引；第二个语句中，对于每个记录都是只取前6个字节。</p>
<p>两种索引结构在数据结构和存储上分别如下图所示：</p>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/MUNLELEE/image-hosting/blog/20260208164205.png" >
		<img src="https://cdn.jsdelivr.net/gh/MUNLELEE/image-hosting/blog/20260208164205.png"
			
			
			
			loading="lazy"
			alt="email 索引结构">
	</a>
	
	<figcaption>email 索引结构</figcaption>
	
</figure></p>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/MUNLELEE/image-hosting/blog/20260208164232.png" >
		<img src="https://cdn.jsdelivr.net/gh/MUNLELEE/image-hosting/blog/20260208164232.png"
			
			
			
			loading="lazy"
			alt="eamil(6) 索引结构">
	</a>
	
	<figcaption>eamil(6) 索引结构</figcaption>
	
</figure></p>
<p><strong>从图中可以看到，由于email(6)这个索引结构中每个邮箱字段都只取前6个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</strong> 但同时带来的损失是，可能会增加额外的记录扫描次数。在这两种索引的建立下，对于以下这个语句，索引定义的执行分别如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> id,name,email <span style="color:#66d9ef">from</span> SUser <span style="color:#66d9ef">where</span> email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zhangssxyz@xxx.com&#39;</span>;
</span></span></code></pre></div><p><strong>如果使用的是index1</strong> （即email整个字符串的索引结构），执行顺序是这样的：</p>
<ol>
<li>从index1索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得ID2的值；</li>
<li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li>
<li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=&lsquo;<a class="link" href="mailto:zhangssxyz@xxx.com" >zhangssxyz@xxx.com</a>’的条件了，循环结束。</li>
</ol>
<p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p>
<p><strong>如果使用的是index2</strong> （即email(6)索引结构），执行顺序是这样的：</p>
<ol>
<li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li>
<li>到主键上查到主键值是ID1的行，判断出email的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</li>
<li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li>
<li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li>
</ol>
<p>在这个过程中，要回主键索引取4次数据，也就是扫描了4行。从中可以发现，使用前缀索引可能会导致查询语句读数据的次数变多。因此， <strong>如果能够在使用前缀索引时，定义好长度，就可以做到即节省空间，又不用额外增加太多的查询成本。</strong></p>
<h2 id="如何建立前缀索引">如何建立前缀索引</h2>
<p>到这里，应该会诞生一个问题，要怎么判断使用多长的前缀作为前缀索引才合适呢。</p>
<p>在之前的索引篇章中提到，索引的选择取决于扫描行数，而扫描行数取决于区分度。区分度越高，意味着重复的键值越少。所以，保证创建的前缀索引在全表数据行数中有满足一定的区分度就是目标。</p>
<p>首先，可以使用下面的SQL语句统计列上有多少不同的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> email) <span style="color:#66d9ef">as</span> L <span style="color:#66d9ef">from</span> SUser;
</span></span></code></pre></div><p>然后，依次选取不同的前缀长度来比较这个值，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(email,<span style="color:#ae81ff">4</span>)<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#66d9ef">as</span> L4,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(email,<span style="color:#ae81ff">5</span>)<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#66d9ef">as</span> L5,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(email,<span style="color:#ae81ff">6</span>)<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#66d9ef">as</span> L6,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">count</span>(<span style="color:#66d9ef">distinct</span> <span style="color:#66d9ef">left</span>(email,<span style="color:#ae81ff">7</span>)<span style="color:#960050;background-color:#1e0010">）</span><span style="color:#66d9ef">as</span> L7,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> SUser;
</span></span></code></pre></div><h2 id="前缀索引对覆盖索引的影响">前缀索引对覆盖索引的影响</h2>
<p>在前面说到前缀索引会增加扫描行数，从而影响性能。前缀索引对覆盖索引同样也具有一定影响。</p>
<p>假定有以下两个SQL语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> id,email <span style="color:#66d9ef">from</span> SUser <span style="color:#66d9ef">where</span> email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zhangssxyz@xxx.com&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">select</span> id,name,email <span style="color:#66d9ef">from</span> SUser <span style="color:#66d9ef">where</span> email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zhangssxyz@xxx.com&#39;</span>;
</span></span></code></pre></div><p>第一条SQL语句中，只需要返回id，email。所以，如果使用index1（即email整个字符串的索引结构）的话，可以利用覆盖索引，从index1查到结果后直接就返回了，不需要回到ID索引再去查一次。而如果使用index2（即email(6)索引结构）的话，就不得不回到ID索引再去判断email字段的值。即使将index2的定义修改为email(18)的前缀索引，这时候虽然index2已经包含了所有的信息，但InnoDB还是要回到id索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。</p>
<p><strong>也就是说，使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是在选择是否使用前缀索引时需要考虑的一个因素。</strong></p>
<h2 id="其他创建前缀索引的方式">其他创建前缀索引的方式</h2>
<p>对于类似于邮箱这样的字段来说，使用前缀索引的效果可能还不错。不过总是会有前缀区分度不够好的情况，就比如身份证号。一共18位，其中前6位是地址码，所以同一个县的人的身份证号前6位一般会是相同的。假设维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为6的前缀索引的话，这个索引的区分度就非常低了。按照我们前面说的方法，可能需要创建长度为12以上的前缀索引，才能够满足区分度要求。</p>
<p><strong>但是索引选取越长，占用的磁盘空间越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</strong> 自然这时候就会想有没有办法能够让索引占用空间较小，同时保证查询效率。</p>
<h3 id="方式">方式</h3>
<h4 id="倒序存储">倒序存储</h4>
<ol>
<li><strong>第一种方式是使用倒序存储。</strong> 如果存储身份证号的时候把它倒过来存，每次查询的时候，可以这么写：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> field_list <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">where</span> id_card <span style="color:#f92672">=</span> reverse(<span style="color:#e6db74">&#39;input_id_card_string&#39;</span>);
</span></span></code></pre></div><p>由于身份证号的最后6位没有地址码这样的重复逻辑，所以最后这6位很可能就提供了足够的区分度。</p>
<h4 id="使用hash字段">使用hash字段</h4>
<ol>
<li><strong>第二种方式是使用hash字段。</strong> 可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> t <span style="color:#66d9ef">add</span> id_card_crc int unsigned, <span style="color:#66d9ef">add</span> <span style="color:#66d9ef">index</span>(id_card_crc);
</span></span></code></pre></div><p>然后每次插入新记录的时候，都同时用crc32()这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过crc32()函数得到的结果可能是相同的，所以的查询语句where部分要判断id_card的值是否精确相同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> field_list <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">where</span> id_card_crc<span style="color:#f92672">=</span>crc32(<span style="color:#e6db74">&#39;input_id_card_string&#39;</span>) <span style="color:#66d9ef">and</span> id_card<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;input_id_card_string&#39;</span>
</span></span></code></pre></div><p>这两种方法的区别主要有以下几点</p>
<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而hash字段方法需要增加一个字段。当然，倒序存储方式使用4个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个hash字段也差不多抵消了。</li>
<li>在CPU消耗方面，倒序方式每次写和读的时候，都需要额外调用一次reverse函数，而hash字段的方式需要额外调用一次crc32()函数。如果只从这两个函数的计算复杂度来看的话，reverse函数额外消耗的CPU资源会更小些。</li>
<li>从查询效率上看，使用hash字段方式的查询性能相对更稳定一些。因为crc32算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
<h2 id="参考">参考</h2>
<ol>
<li>MySQL实战45讲——怎么给字符串加索引？</li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/mysql/">MySQL</a>
        
            <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
        
    </section>


    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/post/mysql%E5%AD%A6%E4%B9%A0%E5%85%AD-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%BA%8C%E7%AF%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">MySQL学习（六） 索引 第二篇</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%94-%E9%94%81/">
        
        

        <div class="article-details">
            <h2 class="article-title">MySQL学习（五）| 锁</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/mysql%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E7%B4%A2%E5%BC%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">MySQL学习（四）| 索引</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src='//unpkg.com/@waline/client@v2/dist/waline.js'></script>
<link href='//unpkg.com/@waline/client@v2/dist/waline.css' rel='stylesheet'/>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
        --waline-font-size: var(--article-font-size);
    }
    .waline-container .wl-count {
        color: var(--card-text-color-main);
    }
</style><script>
    
    Waline.init({"dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo",null],"lang":"zh-CN","placeholder":"写下你的评论吧~","requiredMeta":["name","email"],"serverURL":"https://waline-comment-k87yg2ovb-munlelees-projects.vercel.app","visitor":false});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2026 墨纹
    </section>
    
    <section class="powerby">
        
            你要相信流星划过会带给我们幸运，就像现实告诉你我要心存感激 <br/>
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#背景">背景</a></li>
    <li><a href="#如何建立前缀索引">如何建立前缀索引</a></li>
    <li><a href="#前缀索引对覆盖索引的影响">前缀索引对覆盖索引的影响</a></li>
    <li><a href="#其他创建前缀索引的方式">其他创建前缀索引的方式</a>
      <ul>
        <li><a href="#方式">方式</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
                </div>
                
                
                <a class="go-top" id="go-top" href="#top">
                    <img src="/img/top3_hu2d68ddee36f4745c9b8a323729022ab3_7941_35x0_resize_box_3.png" />
                </a>
                
            </section>
        </aside>
        
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<div class="btn-scroll-top">
    <i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>


    </body>
</html>
