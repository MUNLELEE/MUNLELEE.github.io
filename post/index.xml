<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 墨纹</title>
    <link>https://MUNLELEE.github.io/post/</link>
    <description>Recent content in Posts on 墨纹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 05 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://MUNLELEE.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>利用GitHub搭建一个简易图床</title>
      <link>https://MUNLELEE.github.io/post/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Fri, 05 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%9B%BE%E5%BA%8A/</guid>
      <description>虽然总是隔了很久才会更新一篇博客，但是一旦更新便会有图片到底放哪的烦恼，用过一段时间的在线图床，但终究不是个长久之计。也便有了这篇博文的诞生。
搭建过程 首先在GitHub上创建一个新的仓库，至于怎么创建这里就不赘述了。大家自行bing即可
仓库创建好之后就是我们之后上传图片的地方了，也就是图床。之后要考虑的是如何上传图片，这里用到了一个PicGo这个软件，可以通过这个篝火到达它的官网，之后根据需要下载相应的版本即可。之后按照以下步骤即可
从GitHub中创建一个token，打开路径为 setting-&amp;gt;Developer settings-&amp;gt;Personal access tokens，这里我们选用 Tokens(classic)就行。（其实是我不知道另外一个是干啥用的）。
在生成token界面中，Note用来表示你对这个token使用的描述。主要的还是红框部分，由于这个token会长期使用，而且是私有的这里设置为无限期也问题不大。然后再勾选repo，最后就可以点击generate了。 要注意的是token生成之后只会显示一次，因此要及时复制，否则你就只能再来一次了
生成token界面 配置PicGo，依次打开 图床设置 -&amp;gt; GitHub，如下图。
进行仓库相应配置。在图床配置名上写个名字，仓库名的设置为 GitHub用户名/作为图床的仓库名，分支名使用 main即可，token就是上文刚刚得到的那一串字符。剩下的就不是必选项了。
配置项 之后你只要在软件首页选择相应的图床就能够上传图片了。
参考 如何利用 Github 搭建自己的免费图床？ - 知乎 (zhihu.com)
折腾完这些之后发现，好像用git命令上传图片也不是不行。
算了，聊胜于无吧。</description>
    </item>
    
    <item>
      <title>社区发现 | CPM算法及其实现</title>
      <link>https://MUNLELEE.github.io/post/%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0-cpm%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E7%A4%BE%E5%8C%BA%E5%8F%91%E7%8E%B0-cpm%E7%AE%97%E6%B3%95/</guid>
      <description>前言 近日有了解社区发现相关内容以及实现这个比较古老的算法的需要，索性就了解一下社区发现，并尝试着复现这个算法。
社区发现概述 什么是社区 在现代人们的日常生活中，每个人都会进行社交，这在无形中就形成了一个社交网络。在这个网络中，每个人可以视为一个点，而用户之间的点赞、关注以及其他行为形成了边。在这样的一个网络中，有的用户之间联系较为紧密，有的用户之间联系较为稀疏。联系较为紧密的几个用户可以形成一个社区，在社区内，每个节点的链接都较为紧密，而两个社区之间的联系就较为稀疏。整体的结构可以被称为社团结构。如下图，圈起来的部分即为社区。
社团中的边结构其实是一种逻辑抽象，并不是一种空间位置上的关系，而是节点之间的共有关系，假如节点代表的是消费者，那么节点间的边则可能代表消费者购买了共同一类商品，边的权重则可以代表购买物品的数量。
社区发现的目的及简单思路 社区发现的目的就是为了在图中找到具有一定共同关系或者潜在特定关系的组织，也就是社区。社区发现也就是为了寻找图网络中联系较为紧密的社区也称为块（cluster）。基于这种想法，我们可以想到如果要进行社区发现那么就要寻找一个联系较为紧密的块，我们可以将其解释为具有较大的密度，之后便是考虑用什么方法去评估这种密度，类似于神经网络中的损失函数。
CPM算法 CPM（派系过滤算法）算法是最早的重叠社区发现算法，它的思想是基于团渗透的，这个算法认为社区是具有共享节点的全连通子集集合，并通过一种团过滤算法来识别网络中的社区结构。在这个算法中遵循以下两个概念
在图网络中视为团的部分是任意两个节点都存在一条边相连的，也就是完全子图 所有彼此连通的k-团（拥有k个节点）构成一个k-团社区，当两个k-团之间存在$k-1$个节点共享那么认为这两个k-团连通 算法步骤 算法首先需要找到网络中的所有团，并构建一个用来表示团团重叠情况的矩阵（matrix），在这个矩阵中matrix[i][j]表示网络中第i个团和第j个团之间的公共节点数。 根据给定的参数k，将矩阵（matrix）中对角线上小于$k$的元素和非对角线上的小于$k-1$的元素置零，其他元素置为一，这样所有对角线为1的即为k-团，而非对角线为1的即为两个相邻的k-团。 将相邻的k-团合并为一个较大的团社区，并可以使用模块度进行评价。 从上面可以得知算法中首先需要做到是得到k-团，因此为了提高效率，在这里需要使用Born_Kerbosch算法来寻找图中的团。在这里也简单介绍一下这个算法。
Born_Kerbosch算法 算法的初始化包括了以下三个集合
R集合：记录当前极大团中已经加入的点 P集合：记录可能可以继续加入极大团中的点（这些点应该与R集合中的所有点都相连） X集合：记录已经加入过极大团的点（用于判重，因为会从每个节点开始，枚举所有的团） 简单流程：
对于每一个在集合P中的点v，将v加入R集合中，之后更新P集合，确保集合中的节点与v相连。 进行回溯时，将v节点从P集合中取出，并加入X集合，表示包含v节点的极大团已经寻找完毕了 当R集合满足为极大团时，P集合和X集合必须为空。因为P集合中包含的点是可能加入R集合中的点，同样的X集合中的点也与R集合中的点都相邻，因此也属于可能称为R集合中极大团点的情况。 算法缺点 CPM算法较为简单，但存在不能为单节点分配社团以及比较使用于完全子图较多的网络中的问题，也即边密集网络中，在稀疏网络中算法的效率较低。
模块度 模块度是评估一个社区网络划分好坏度量方法，其含义为社区内节点的边数与随机情况下的边数之差。定义如下：
$$Q=\frac{1}{2m} \sum_{i, j}[A_{i j}-\frac{k_i k_j}{2m}]\delta(c_i, c_j) \qquad \delta(u, v)=\begin{cases}1,&amp;amp;u==v \newline 0, &amp;amp;else \end{cases}$$
其中$A_{i j}$是节点$i$和节点$j$之间边的权重，当图网络不带权时，可以将其视为1；$k_i=\sum_j{A_{ij}}$表示所有与节点$i$相连的边的权重之和；$c_i$表示节点$i$所属的社区；$m={1\over2}\sum_{ij}A_{ij}$表示所有边的权重之和。$\frac{k_i k_j}{2m}$表示随机情况下节点$i$与节点$j$之间产生的边。
对这个公式做进一步简化可以得到如下的公式：
$$Q=\frac{1}{2m}\sum_c{[\sum{in}-\frac{{(\sum{tot})}^2}{2m}]}$$
其中$\sum{in}$表示社区$c$内边的权重之和，$\sum{tot}$表示与社区$c$节点相连的边的权重之和。
可以这么简单的理解模块度，即社区内部边的权重和减去社区外部与社区内部相连的边的权重和。
算法实现 在这部分将讲述算法实现的一些较为重要的地方，完整的代码可以点此，需要的朋友可以直接前往。
实现算法要先实现寻找极大团，这里使用Born_Kerbosch算法，这个算法有两个版本，但我这里采用了经过一些剪枝处理的版本，在递归之前需要先确定需要的枢纽元素，数据结构方面采用集合（自动去重属实是太好用了^_^） /** * 使用BornKerbosch算法寻找最大团 * @param R 存在于极大团中的点 * @param P 可能可以加入极大团的点 * @param X 用于判重的点集合 * @param ans 将最后寻找到的所有极大团保存 * @param neighbor 存储每个节点的邻居节点，是一个map */ def bornKerbosch(R: Set[VertexId], P: Set[VertexId], X: Set[VertexId], ans: Set[Set[VertexId]], neighbor: Map[VertexId, Set[VertexId]]): Unit = { if (P.</description>
    </item>
    
    <item>
      <title>Flask实现Web应用（三）</title>
      <link>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%89/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%89/</guid>
      <description>这篇博文应该是这个应用的最后一个部分，主要是实现调用本地麦克风录音的前后端。
前端页面的实现 在这个页面中，需要实现录音功能，而录音功能在参考了网上的相关资料之后，决定采用recorder.js的现行库（因为如果要造轮子的话需要自己去了解语音采样等过程），这是库的链接。
对于我这种前端小白本来是没看懂要怎么使用的，后来才发现在其项目目录下有dist/recorder.js文件，如果你使用是Flask框架只需要在static文件夹中导入recorder.js以及recorder.js.map两个文件并采用如下方法引入
&amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;{{ url_for(&amp;#39;static&amp;#39;, filename=&amp;#39;recorder.js&amp;#39;) }}&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 通过recorder我决定设置录音相关的六个按钮分别是开始、暂停、继续、结束、上传、播放。于是就有了以下的HTML代码
&amp;lt;body style=&amp;#34;background-size: 100%; background-image:url({{ url_for(&amp;#39;static&amp;#39;, filename=&amp;#39;cool-2.png&amp;#39;) }})&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;items&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;麦克风录制&amp;lt;/p&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;开始录制&amp;#34; id=&amp;#34;record_btn&amp;#34; class=&amp;#34;item_btn_left&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;暂停录制&amp;#34; id=&amp;#34;stop_btn&amp;#34; class=&amp;#34;item_btn_left&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;继续录制&amp;#34; id=&amp;#34;resume_btn&amp;#34; class=&amp;#34;item_btn&amp;#34;&amp;gt; &amp;lt;br&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;结束录制&amp;#34; id=&amp;#34;end_btn&amp;#34; class=&amp;#34;item_btn_left&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;播放录音&amp;#34; id=&amp;#34;play_btn&amp;#34; class=&amp;#34;item_btn_left&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;上传录音&amp;#34; id=&amp;#34;submit_btn&amp;#34; class=&amp;#34;item_btn&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p&amp;gt;识别文本&amp;lt;/p&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;res_text&amp;#34; disabled=&amp;#34;disabled&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; value=&amp;#34;返回主页&amp;#34; onclick=&amp;#34;back()&amp;#34; id=&amp;#34;back_btn&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; 前端CSS样式 没有什么CSS基础又想让界面好看一点的我，在这个页面的按钮样式上参考了其他大佬的所写的CSS代码样式，并修改了其大小和变化时间长短，所以这里并没有太多可以讲述的东西。直接附上相关链接以及我修改后的CSS代码</description>
    </item>
    
    <item>
      <title>Flask实现Web应用（二）</title>
      <link>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%BA%8C/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%BA%8C/</guid>
      <description>书接上回，这篇博文主要是要讲一讲前端页面以及相应的css的变化，虽然是一个简单的web应用，但是在一定程度上还是需要符合人的审美。
基础页面 由于我需要实现两个功能，调用本地麦克风录制和上传录音文件，最开始我是想把这两个功能放在同一个页面，但是最后觉得为了美观和页面逻辑，我就决定设计一个主页面，包含了这两个功能的可选项，之后再通过选择重定向至另一个页面。
因此在基础页面中就有了如下的HTML代码
&amp;lt;body style=&amp;#34;background-size: 100%; background-image:url({{ url_for(&amp;#39;static&amp;#39;, filename=&amp;#39;cool-background.png&amp;#39;) }})&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;items&amp;#34;&amp;gt; &amp;lt;p&amp;gt;选择语音识别方式&amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; id=&amp;#34;choose_btn1&amp;#34; value=&amp;#34;上传文件&amp;#34; class=&amp;#34;choose_btn&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;item&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;button&amp;#34; id=&amp;#34;choose_btn2&amp;#34; value=&amp;#34;麦克风录音&amp;#34; class=&amp;#34;choose_btn&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 当然一个网页好看的背景是不可缺少的，在这里可以给各位有前端需求的朋友推荐一个网站炫酷背景，这个网站可以在线生成一些简单的可以用作网页背景的图片并提供免费下载。
当你使用Flask框架并打算引用外部文件时，你只能将文件放在static文件夹下，并采用url_for函数来作为引用的链接。
按钮链接 可以看见在这个基础页面中有两个按钮，通过这两个按钮的点击重定向至其他页面。这时候需要用到jQuery来判断被点击的是哪个按钮（最开始想用JS实现，但是发现略微麻烦）。
我们可以通过attr来获取相应HTML标签的属性值，通过属性值实现判断和重定向。判断条件满足时使用window.location.href将url导向至其他页面。并将这个函数绑定到按钮的点击事件上。
window.onload = function () { $(&amp;#34;.choose_btn&amp;#34;).click(function () { const text = $(this).attr(&amp;#34;value&amp;#34;); if (text === &amp;#34;上传文件&amp;#34;) { window.location.href = &amp;#39;upload&amp;#39;; } else { window.location.href = &amp;#39;microphone&amp;#39;; } }); } 通过上面的JS，当点击某个按钮，浏览器的url将会改变，因此我们需要将将相应的url在Flask后端进行渲染。
@app.route(&amp;#39;/upload&amp;#39;) def upload(): return render_template(&amp;#39;upload.</description>
    </item>
    
    <item>
      <title>机器学习算法 | K近邻</title>
      <link>https://MUNLELEE.github.io/post/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</guid>
      <description>K近邻算法 K近邻是一种有监督学习算法。因为没有对数据进行训练，而是通过新数据与旧数据的比较得到相应的结果。因此是一种隐式的学习过程和训练过程。K近邻算法可以用来解决分类问题，也可以用来解决回归问题。
步骤 对未知类别的属性的数据集中的每个点依次执行以下操作：
计算已知类别数据集中点与当前点之间的距离 按照距离递增次序排序 选取与当前点距离最小的k个点 确定前k个点所在的类别出现的频率 返回前k个点出现频率最高的类别作为当前点的预测分类 在确定样本和当前点的距离时，通常采用的是欧式距离公式$$d=\sqrt{(x_1-x_0)+(y_1-y_0)}$$ 当公式中的指数变化时，随之也会得到相应的不同的距离公式。
如下图所示的例子中
1、当采用实线的圆作为k近邻的范围，也就是$k=3$时，此时与绿点距离更近的三个点中，三角形出现的频率更大，因此将绿点归为三角形一类
2、当采用虚线的圆作为k近邻的范围，也就是$k=5$，时，此时与绿点距离更近的五个点中，正方形的频率更大，因此将绿点归为正方形一类。
以下采用鸢尾花作为例子进行KNN测试
代码 import numpy as np import pandas as pd from sklearn.datasets import load_iris import matplotlib.pyplot as plt iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) # print(df) df[&amp;#39;label&amp;#39;] = iris.target # print(len(df)) 150 # 绘散点图 # print(df.info()) # 显示数据类型 # 前两个特征 Colors = [] for i in range(df.shape[0]): item = df.iloc[i, -1] # 定位到标签 if item == 0: Colors.</description>
    </item>
    
    <item>
      <title>岛屿问题 | DFS框架</title>
      <link>https://MUNLELEE.github.io/post/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</guid>
      <description>在DFS这一块一直是比较弱的，因此就去看了DFS相关的一些题目，并找到了岛屿的一系列问题。
岛屿数量 岛屿的最大面积 最大人工岛 封闭岛屿的数目 岛屿的周长 图类DFS方法 图通常是由方格组成，通过方格中的元素来对图的DFS进行限制。岛屿问题便是其中经典的一类。在岛屿问题中，通常由$1$表示陆地，由$2$表示海洋，当每个方格都相邻时，组成的一个全$1$方格域即为一个岛屿。（这里不包含对角相邻）
DFS框架 DFS也是一种意义上的递归，因此在一个DFS程序中首先要做的便是设定递归出口。类似于树结构可以利用指针为空等条件，在岛屿问题中，我们需要判断边界，也需要判断当前方格是否是陆地。因此在递归出口设置中就需要两个条件进行限制。
之后DFS就要考虑下一步搜索与前一轮搜索之间的区别。岛屿问题中最主要的区别便是遍历方格的四个邻格，其余的区别便需要依题目而定。因此我们可以得到以下的岛屿类问题的DFS框架
class Solution { private: bool inRange(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int x, int y) { if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; grid.size() &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; grid[0].size()) { return true; } return false; } void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != 1) return; dfs(grid, pos_x - 1, pos_y); dfs(grid, pos_x + 1, pos_y); dfs(grid, pos_x, pos_y + 1); dfs(grid, pos_x, pos_y - 1); } } 避免重复遍历 在DFS中一个重要的问题就是要避免重复遍历，不然可能会造成程序原地打转的现象。在岛屿一类的问题中，可以将已经遍历过的方块修改其元素为$0$或者为非题中给出元素。因此我们可以修改上述的DFS模板如下</description>
    </item>
    
    <item>
      <title>Flask实现Web应用（一）</title>
      <link>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%80/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%80/</guid>
      <description>为了让之后的项目能够专注于算法，于是打算先在近几日解决一定的应用层面的内容。因此也就诞生了这篇文章。
背景 这个Web应用说来其实应该是很简单的，但是由于没有前后端开发经验，对我来说也算是一个挑战。这个应用旨在实现能够通过前端上传录音文件，通过后端的处理将文本返回给前端页面以及能够调用本地的麦克风进行录音最后通过这段录音能够返回文本内容。项目不大，也应该不会太过华丽，所以选用了Flask框架处理。
基本文件上传表单 从客户端的角度来讲，上传文件和提交表单数据一样，因此我们需要定义一个包含文件字段的HTML表单。一个简单的HTML表单如下。这个表单可以接收一个文件。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;语音识别站点&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;录音文件上传&amp;lt;/h1&amp;gt; &amp;lt;form method=&amp;#34;post&amp;#34; action=&amp;#34;&amp;#34; enctype=&amp;#34;multipart/form-data&amp;#34;&amp;gt; &amp;lt;p&amp;gt;&amp;lt;input type=&amp;#34;file&amp;#34; name=&amp;#34;file&amp;#34; accept=&amp;#34;.wav&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;提交&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 这里需要注意的是，&amp;lt;form&amp;gt;元素的method属性可以是get或post。使用get时，数据将在请求URL的查询字符串中提交，而使用post时，数据将进入请求主体。当一个HTML表单中包含文件时，必须使用post方法，因为我们不可能在请求URL字符串中处理提交的文件数据。采用multipart/form-data字段则是因为这个字段可以适用于提交文件。accept属性则是可以限制表单可以接受的文件类型。如上使用了.wav进行限制，当点击选择文件时，系统的资源管理器会帮你过滤类型不匹配的文件。
使用Flask进行文件接收 对于常规表单，Flask提供了对提交表单字段的访问。其中文件字段就包含在 request.files字典中，可以通过键值 file来访问文件列表，从中得出文件名，再用save保存文件。
@app.route(&amp;#39;/upload&amp;#39;, methods=[&amp;#39;post&amp;#39;]) def upload_file(): upload_file = request.files[&amp;#39;file&amp;#39;] if upload_file.filename != &amp;#34;&amp;#34;: upload_file.save(upload_file.filename) return redirect(url_for(&amp;#39;upload_file&amp;#39;)) 这样，每当提交一次文件时，就会将文件保存到你的工程目录中。如下图所示
文件上传效果 添加一些限制 文件大小限制 为了防止上传十分大的文件，我们在后端中添加对文件大小进行限制的配置。
app.config[&amp;#39;MAX_CONTENT_LENGTH&amp;#39;] = 1024 * 1024 添加了如上的配置之后，文件大小将会被限制在1MB，超过此大小的文件将会被拒收。这样在一定程度上也可以防止客户端采用上传大文件的方式过多的占用服务器资源以及，通过大容量文件对服务器进行攻击。
可接收文件类型限制 在前面的HTML表单中提到了accept属性，通过这个属性系统资源管理器会对文件的扩展名进行筛选。在发现了Flask框架可以对文件类型进行限制的时候我决定转到后台进行文件类型的限制。
app.config[&amp;#39;UPLOAD_EXTENSIONS&amp;#39;] = [&amp;#39;.wav&amp;#39;] 上传路径的限制 由于之后需要使用到这个录音文件，所以我将这个录音文件保存在相应的工程路径中，便于之后的获取。据此添加了相关配置
app.config[&amp;#39;UPLOAD_PATH&amp;#39;] = &amp;#39;uploads&amp;#39; 这样当文件上传之后，你就可以看到文件在uploads的文件夹下出现</description>
    </item>
    
    <item>
      <title>Linux下的socket网络通信</title>
      <link>https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/</guid>
      <description>想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。
socket socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。
因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。
对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式
流：基于TCP协议，因此有序，可靠。可以实现可靠传输。 数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。 C/S模式 在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。
服务器工作流程 1、创建服务器socket 在这个阶段我们可以使用socket函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为AF_INET，即表示利用IPv4进行通信。这个函数的返回值为 文件描述符 （类型为整型），当失败时则会返回-1如下
int listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0) 2、将服务器用于通信的地址和端口绑定到socket上 在Linux中，地址信息被封装在了结构体sockaddr中，如下
struct sockaddr { sa_family_t sin_family; //地址族 char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息 }; 想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体sockaddr_in，这个结构体如下
struct sockaddr_in { sa_family_t sin_family; uint16_t sin_port; // 端口号 struct in_addr sin_addr; // IP地址 char sin_zero; } 但如果你进入到Linux的底层代码会发现，sockaddr_in还有一个参数为sockaddr的构造函数。因此使用这个结构体可以让操作更简单，如下
struct sockaddr_in servaddr; memset(&amp;amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 指定为任意IP地址 servaddr.sin_port = htons(atoi(argv[1])); // 将主机字节顺序转换为网络字节顺序 之后将端口绑定。</description>
    </item>
    
    <item>
      <title>应用层协议——HTTP</title>
      <link>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</guid>
      <description>HTTP协议概述 概况 Web的应用层协议是超文本传输协议（HTTP）。HTTP协议由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话。
HTTP定义了Web页面的方式，以及服务器向客户传送Web页面的方式。并 使用TCP作为它的支撑运输协议 。HTTP客户首先发起一个与服务器的TCP链接。连接建立，彼此之间就可以通过 套接字接口 访问TCP。从而利用套接字接口接受和发送HTTP报文。通信过程如下图所示
由于TCP为HTTP提供可靠数据传输服务，因此每个报文都能完整地到达服务器或客户，HTTP协议不关心TCP从网络种如何处理报文的各种问题，也不用担心数据丢失。但又由于服务器只为客户服务，并不存储任何关于客户的状态信息，因此HTTP协议是一个 无状态协议 ，如果需要保存客户的登录信息，则 需要引入相关技术来记录状态，如Cookie 。
持续和非持续连接 在实际情况中，客户可能会发出一系列请求并且服务器会对每个请求进行响应。而这种客户-服务器的交互是经过TCP进行的，因此这些请求是经过单独的TCP连接还是经过相同的TCP连接就是这种交互方式的关键问题。也因此诞生了持续和非持续的HTTP连接。
非持续连接： 使用非持续连接，每个TCP连接在服务器 发送一个对象后就关闭 （对象即HTML文件以及网页图像等），每个TCP连接只传输一个请求报文和一个响应报文。
非持续连接有以下缺点：
必须为每个请求的对象建立和维护一个全新的连接。对于这样的连接要分配TCP缓冲区和保持TCP变量。造成服务器负担。 每个对象经受两倍的RTT交付时间，即一个RTT用于创建，一个RTT用于请求和接受. 持续连接： 服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送，而如果一条连接经过一定时间间隔（配置好的超时间隔）仍未被使用，HTTP服务器就应该关闭这个连接。
HTTP连接流程 （1）、 客户端连接到Web服务器。 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80端口），建立一个TCP套接字连接。
（2）、 发送HTTP请求。 通过TCP套接字，客户端向HTTP服务器发送一个文本的请求报文。
（3）、 服务器接受请求并返回HTTP响应。 Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。
（4）、 释放TCP连接。 若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭TCP连接并释放。反之若为keepalive，则TCP连接会保持一段时间，在这段时间内可以继续接受请求和响应。
（5）、 客户端浏览器解析HTML内容。 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取相应的HTML，根据HTML语法对其进行格式化，并在浏览器窗口显示。
HTTP报文 HTTP请求报文 请求报文格式如下图。其中第一行称为 请求行 ，其后继的行称为 首部行 。
请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以区包括GET、POST、HEAD、PUT和DELETE。这些请求方法将会在下文讲述。
首部行则会包含Host字段，Connection字段以及User-agent字段等。分别指明了对象所在的主机、是否使用持续连接以及用户代理（发送请求的浏览器类型）。其中Host首部行则是Web代理高速缓存所要求的。
HTTP响应报文 响应报文的格式如下图。分为 状态行 ， 首部行 以及 实体体 三个部分。实体体为报文的主要部分，为所请求的对象本身。同样在首部行会包含一些字段。例如：Date：指示发送该报文的日期和时间；Server：指示发送的服务器；Last-Modified：最后修改的日期和时间等。
HTTP状态码 由上述HTTP响应报文可以得出，在状态行中包含状态码字段，这个字段将指示请求的结果。可以将状态码分为以下几类：
1xx： 指示信息 ，表示请求已接收，继续处理 2xx： 成功 ，表示请求已被成功接收、理解、接受 3xx： 重定向 ，要完成请求必须进行进一步的操作 4xx： 客户端错误 ，请求有语法错误或请求无法实现 5xx： 服务器端错误 ，服务器未能实现合法请求 常见的状态码如下：</description>
    </item>
    
    <item>
      <title>“喜帖街”</title>
      <link>https://MUNLELEE.github.io/post/%E5%96%9C%E5%B8%96%E8%A1%97/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E5%96%9C%E5%B8%96%E8%A1%97/</guid>
      <description>这篇文章要说应该是心血来潮，并没有想到要用什么标题会比较合适，于是就起了 “喜帖街” ，因为说到底一切的情感也是由它而来。
喜帖街 喜帖街是躺在我的列表里很久的为数不多的粤语歌，虽然很久就加入了列表，但第一次听时却没有觉得有多惊艳，就一直放在了列表。但今天忽然想起来听一听，在仔细地看过它的歌词，聆听着谢安琪那有一种婉约感觉的歌声。心中却突然有一种说不上来的感慨。
去网上搜了一下喜帖街，这是一条属于香港60年代的老街，之所以称为喜帖街是因为它是当时香港著名的印刷品制作及门市集中地。尤其是以印刷喜帖著名。当有喜事时，香港人便会想起喜帖街而去那里购买喜帖。虽短而窄小，但是也有属于香港百德新街爱侣其乐融融的一面。
随着20世纪初市区重建的需要，市区重建局清拆了喜帖街两侧的店铺，改为大型商场。喜帖街承载的香港那份独特的回忆，也就这样慢慢消失了。这条街也便再也没有属于爱侣的那一部分。
虽然歌曲作词人黄伟文提醒大家喜帖街不是一首情歌，是一首励志的歌曲，鼓励大家在逆境时代要积极面对人生。但是在我看来更多的喜帖街那份香港集体回忆不得不只停留在回忆的惋惜。时代在改变，那些我们认为不应该作出改动的事物可能会在某一天让你发觉沧海桑田也只是一瞬。
人应该接受 都有日倒下
其实没有一种安稳快乐 永远也不差
就似这一区 曾经称得上美满甲天下
但霎眼 全街的单位 快要住满乌鸦
——谢安琪《喜帖街》
从这几句歌词中便能很明显地体会枯荣带来的那种感伤。
所感 对于喜帖街的这种变迁，其实我是深有同感的。在我小学到中学的阶段我一直都住在我们镇上的一条老街。那种一出门就能见到邻里乡亲，想要找玩伴就直接去串门，甚至熟悉每一家每一户的构造。在我们那一带存在着不少的木工，于是由我们爷爷那一代建造的老房子在很多地方还存在着木制结构。虽然只是木制，但是踩上去却依旧能够带给人一种厚实的感觉，现在一想就算不是我们那里的人所造，那也应该是结识了优秀的木工吧。也因为有木制结构，在木墙上钉了一些钉子，那时的我并不知道为什么要这么做，但却给了我们一个类似“闯关”的机会，儿时的玩伴偶尔也会沿着各家各户的墙沿，用手抓着钉子，踩在门槛上就这样从一端到另一端。虽然这种乐趣到了中学便已经消失了，随着学习成绩之间的差异，大家也都各奔东西。
有些人有些事，不管过了多久当想起时总会觉得记忆犹新，在那里从不敢放“蜘蛛炮”，只会拿着一根烟点，到最后到处找大人拿打火机就急着要放鞭炮去；趴在人家的门槛上玩着陀螺（到现在我依旧记得我那个叠了整整五层铁片的陀螺），弹着磁铁片，在学校的门口买磁铁卡包，总是希望能够开出自己想要的样式；买了那种带有饮料的水枪，却只是为了看喷在墙上后谁的水珠会下落的更快。这些都是属于一亩四方地的乐趣，是属于上个上个世纪留下来的邻里乡亲之间的那种情感。这一切也像“喜帖街”一样，随着城区的改造而消失殆尽，每家每户都住到了不同的地方，不同的楼层。再没有出门就能叫到的小炒，出门就能直接去买东西的小卖部。我想那个地方现在剩下的应该就只有一棵见证了世事变迁的榕树了。包括那由五块石板组成的桥（也因此那里被称为“五板桥头”）应该也不复存在了。
虽然喜帖街让我想起了曾经居住的地方，但我从喜帖街这首歌中还看到了兴衰，于是让我思考起了是否所有的事物都会像所有生物一样都会步入暮年，最后都会消亡。说实话，这些东西应该不属于我这个年纪应该考虑的。但在目睹了一个企业的兴衰之后，我想这个问题是每个管理人员不得不去思考甚至应该放在第一位的问题。从父母口中听到了曾经的红火，那种所有人从早忙到晚的状态。</description>
    </item>
    
    <item>
      <title>春招 | 知识点留档</title>
      <link>https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时 （只要求同名，不管参数列表是否相同），访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C++在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C++的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区 （不仅可以是堆还可以是静态存储区） 上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、是否需要指定内存大小。 使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、是否调用构造函数。 使用new操作符分配对象内存时经历如下的几个步骤：
·调用operator new函数（数组是operator new[]）来分配内存空间
·编译器运行相应的构造函数创建对象，并赋初值
·返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
·调用对象的析构函数
·编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、对数组的处理。 C++提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、是否能够重新分配内存。 使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。
虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。
当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。
3.1、虚函数指针 本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。 只有拥有虚函数的类才会拥有虚函数指针 ，每个虚函数也都会对应一个虚函数指针。</description>
    </item>
    
    <item>
      <title>LeetCode 二叉搜索树与双向链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
为了让您更好地理解问题，以下面的二叉搜索树为例：
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
解题想法 题目给出的是一棵二叉搜索树，而要我们整理成一个升序的双向链表，可以很自然的想到二叉搜索树的中序遍历即为升序序列。面对双向链表，我们还需要建立相邻结点之间的关系，因此需要设置前驱结点pre和当前结点cur两个指针来组织结点之间的关系。（具体即为pre-&amp;gt;right = cur和cur-&amp;gt;left = pre），最后则是连接头结点和尾结点。
中序遍历流程 令recur为中序遍历函数
1、终止条件：当cur结点为空时，直接返回，说明此时已经越过了叶节点
2、递归左子树，recur（cur-&amp;gt;left）
3、构建相邻结点之间的关系
（a）、如果pre指针为空，说明当前访问的结点为中序遍历的第一个结点，也就是双向链表的头结点，此时将当前结点cur赋值给head指针。
（b）、如果pre指针非空，需要建立两个结点之间的关系，即pre-&amp;gt;right = cur和cur-&amp;gt;left = pre
（c）、更新前驱结点pre，即pre = cur
4、递归右子树，recur（cur-&amp;gt;right）
最后在执行函数中，需要利用head和pre指针建立双向链表的头尾关系，即head-&amp;gt;left = pre，pre-&amp;gt;right = head，因为当递归完二叉搜索树时，pre会指向中序的最后一个元素。
代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private: Node *head, *pre; void recur(Node *root) { if (root == NULL) return; recur(root-&amp;gt;left); // 如果pre为空，说明当前访问的是头结点 if (pre) pre-&amp;gt;right = root; else head = root; root-&amp;gt;left = pre; // 修改当前的结点为前驱结点 pre = root; recur(root-&amp;gt;right); } public: Node* treeToDoublyList(Node* root) { if (root == NULL) return NULL; recur(root); head-&amp;gt;left = pre; pre-&amp;gt;right = head; return head; } }; </description>
    </item>
    
    <item>
      <title>LeetCode 矩阵中的路径</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。
示例：
输入：board = [[&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;E&amp;#34;],[&amp;#34;S&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;S&amp;#34;],[&amp;#34;A&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;E&amp;#34;]], word = &amp;#34;ABCCED&amp;#34;输出：true 输入：board = [[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;],[&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;]], word = &amp;#34;abcd&amp;#34;输出：false 解题想法 这道题一开始想到的是使用BFS，但是细想发现BFS好像很难处理回溯的问题，应该采用DFS。然后，就是递归的痛了，也借这道题学习一下DFS的写法吧。
**DFS：**即是暴力遍历矩阵的所有元素，来搜索一条可行的路径，通过递归，可以在一条路径中搜索到底，最后回溯到之前已经匹配的节点。
**剪枝：**在DFS过程中如果当前的矩阵字符与字符串字符不等，可以直接回溯。或者路径已经访问过，可以直接跳过。
DFS解析 1、递归终止条件：
（a）、返回true，当匹配到字符串的最后一个字符时，可以直接返回true（至于为什么可以这样返回，参看代码注释）
（b）、返回false，如果矩阵的索引越界，当前矩阵的字符和字符串的字符不匹配，当前元素已经访问过了直接返回false
2、递归过程
（a）、选定当前元素，将当前元素标记为空字符，表明当前元素已经访问过，防止走回头路。
（b）、搜索下一个元素，向四个方向分别匹配字符，如果有一个方向可以匹配就继续递归这个方向的DFS算法，并返回true，否则返回false
（c）、还原当前元素，需要在DFS算法退出之前，将空字符还原为原来的字符，用于回溯时重新寻找路径，否则回溯将找不到正确路径。
代码 class Solution { public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { rows = board.size(); cols = board[0].size(); for (int i = 0; i &amp;lt; rows; ++i) { for (int j = 0; j &amp;lt; cols; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; } private: int rows, cols; // k为单词索引 bool dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board, string word, int i, int j, int k) { // 如果越界或者字符不相等，就停止递归 if (i &amp;gt;= rows || i &amp;lt; 0 || j &amp;gt;= cols || j &amp;lt; 0 || board[i][j] !</description>
    </item>
    
    <item>
      <title>LeetCode 最长不含重复字符的子字符串</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例
输入: &amp;#34;abcabcbb&amp;#34;输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。 输入: &amp;#34;bbbbb&amp;#34;输出: 1解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。 输入: &amp;#34;pwwkew&amp;#34;输出: 3解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。 解题想法 这道题想通了发现也是一道比较常规的动态规划题，但是开始时没有考虑好的细节确实是折磨了我一阵。以及没有想到用哈希表处理属实比较蠢。
动态规划 1、状态的定义，本题依旧需要一个一维的动态规划数组，dp[i]则表示以第i个字符为结尾的子字符串可以得到的最长的含不重复字符的子字符串长度。
2、状态转移方程，首先我们需要固定右边界i，也就是遍历时的索引，设与s[i]相同且距离最近的字符为s[pos]（pos初始化为-1。此时不重复字符子串长度应该是i - pos，但是题目所求为最长，因此根据动态规划的思想就有以下的情况
（a）、当$pos&amp;lt;0$时，说明在s[i]的左侧没有与s[i]相同的字符，那么dp[i] = dp[i - 1] + 1（即最长长度等于遍历到前一字符的长度 + 1）
（b）、当$dp[i - 1]&amp;lt;i - pos$时，说明重复的字符应该在当前最长非重复字符子串的区间外，即在这个子串的左边，此时dp[i] = dp[i - 1] + 1，也就是之前的子串再加上当前的字符。
（c）、当$dp[i - 1]&amp;gt;=i-pos$​时，说明此时重复的字符应该在当前最长的非重复字符子串的区间内，因此dp[i] = i - pos，也就是在之前的子串中截取出非重复的部分。
3、需要一个哈希表用来记录曾经出现过的字符的相对应的索引，每当遍历到一个重复字符时，便要将哈希表中的相应表项更新为当前的索引。
由以上的分析可以看出，dp[i]只由dp[i - 1]决定，所以可以省略动态规划的数组，采用一个变量进行迭代即可，并求取此变量在这个过程中的最大值。
双指针法（滑动窗口） 由于滑动窗口的代码写得比较少，当看到题解有滑动窗口时，便又学习了一下。</description>
    </item>
    
    <item>
      <title>LeetCode 股票的最大利润</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
示例：
输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题想法 这道题首先可以采用暴力的求解方法，只要计算在某一天中，其后的每一天卖出的价钱所得的利润最大，依次遍历每一天，最终就可以求得最大利润，这样可以得到的时间复杂度为$$(n-1)+(n-2)+&amp;hellip;+2+1=n(n-1)/2$$也就是$O(n^2)$，不出所料，在这种解法中，你需要将一些冗余的操作去除，才能通过力扣的判题机。于是就有了下面的解法，也就是动态规划。
动态规划思路 1、状态的定义，首先需要声明一个动态规划数组dp，其中dp[i]表示以第i天为最后一天的子数组所能获得的最大利润。
2、状态转移方程，由于股票只能买卖一次，因此dp[i]（也就是前i天的最大利润），应该是前i-1天的最大利润与第i天卖出股票的利润的最大值，于是就有了$前i天最大利润=max（前i-1天最大利润，第i天价格-前i天最低价格）$即为dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i]))，最终返回dp[n-1]为所求。
优化 我们还可以进行空间和时间上的优化，时间上，可以借助一个变量cost来维护最小值，这样每次进行状态转移时只需要dp[i] = max(dp[i - 1], prices[i] - min(cost, prices[i]))，空间上，由于本道题的状态转移只需要前一次的状态，因此可以采用一个变量maxprofit来代替整个动态规划列表，这样状态转移就简化为了maxprofit = max(maxprofit, prices[i] - min(cost, prices[i]))
代码 /*未优化*/ class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { if (prices.</description>
    </item>
    
    <item>
      <title>LeetCode 树的子结构</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如: 给定的树 A:
3/ \4 5/ \1 2 给定的树 B：
4/1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
解题想法 树的题目是真的让人头疼。在经过几次暴力解的尝试之后我还是放弃了，最后几组数据总是通过不了。还是去翻了题解，发现又是我最烦的递归（永远的痛）
1、首先子结构要么是其本身要么在树的左子树或者右子树里，因此在isSubStructure函数中需要判断是本身匹配还是左子树或者是右子树匹配，这是最外层递归。最外层递归中，如果B树（也就是子结构树）为空，那么直接返回false，同理如果A树（要从这棵树中寻找子结构）为空也可以直接返回false
2、对于子结构是否匹配的判断也需要通过递归实现（也就是isContain函数），但具有以下几种情况，其中包含退出递归的条件
（a）、如果当前的B树为空，且At树（也就是从A树种截取出的子树）非空或者空，此时表明B树是A树的一个子结构，因为可以将B树匹配完。
（b）、如果当前的B树非空，但At树为空，说明此时已经遍历过了A树的叶节点，那么B树一定与At树不匹配，可以直接返回false
（c）、如果此时At树和B树都不为空，且当前匹配中的结点的值不相等，那么B树一定与At树不匹配，可以直接返回false
（d）、如果At树和B树都不为空，且当前匹配中的结点的值相等，那么就继续匹配两棵树当前结点的左结点和右结点（也就是内层的递归）
代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isContain(TreeNode *A, TreeNode *B) { // 递归判断是否包含 // 如果此时B为空树，说明已经递归完了B树，因此是包含的 if (B == NULL) return true; // 如果大树为空，匹配树不是空，那么说明不包含 if (A == NULL) return false; // 如果当前匹配的结点值不相等，那么也是不包含 if (A-&amp;gt;val !</description>
    </item>
    
    <item>
      <title>LeetCode 从上到下打印链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如: 给定二叉树: [3,9,20,null,null,15,7],
3/ \9 20/ \15 7 返回其层次遍历结果：
[[3],[9,20],[15,7]] 解题想法 这道题本身并不是什么难题，也很明显可以看出是一个层序遍历的变种，解决问题的关键就在于如何区分当前层和下一层，最开始是打算使用pair将每个结点与其相应的层序号对应起来。但在实际写代码时发现有点困难，最后还是去翻了题解，发现了利用空指针作为层与层之间分隔的方法。具体做法就是在第一次入队时再入队一个空指针，之后利用队头元素不为空指针作为内循环的判断，如果队头为空，则表明了已经循环完了一层。而由于二叉树的特点，在使用层序遍历时，遍历完一层也即代表着下一层的非空结点已经完全入队，这时便可以再入队一个空指针作为下一个分隔结点。利用这样的循环就能做到以层为序来打印层序遍历。
代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (root == NULL) { return res; } queue&amp;lt;TreeNode*&amp;gt; que; // 用于层序遍历 que.</description>
    </item>
    
    <item>
      <title>观《时光代理人》、《灵笼》所感</title>
      <link>https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/</guid>
      <description> 如题的这两部动漫都是我认为接近于国漫巅峰的动漫，当然我并没有看过多少国漫，因此这一判断也是相当主观的。但确实的是其在我内心中是“前无古人”的。这两部动漫也是将我这一早已不看动漫的人又带回了国创动漫。
动漫情节叙述 由于两部动漫都只做到了第一季，虽能体现一定的设定及世界观，但是很多剧情依旧是在迷雾之中的。这里也就只能讲讲已有的剧情。
《灵笼》的设定之前也是有过，但是灵笼剧情的饱满程度让末日题材的这种设定能够更好的展现出来。开篇便是猎荒者（即在末日中探索旧世界的可利用的东西，为幸存下来的人服务）在探索一篇废墟，并遭遇了噬极兽（因为这种怪兽因而认为地上是无法生存的）。当猎荒者凯旋归来时，之后便迎来了另一个比较重要的情节，也就是城主的更替。当然这里要先说说这个城主的问题，现在的人们生活在一个叫做“灯塔”的建筑上，而现任成主的儿子则是在灯塔上成立了一个类似于教会的“光影会”。这里就权且称这位会长为“黄毛”。城主更希望由猎荒者队长马克来接任下一任城主，但是心胸狭隘的黄毛却利用一些手段导致马克成为了噬极兽并因此被流放。（这里其实省略了很多的情节，但我觉得第一季的主要目的应该就是仅仅为了引出世界观以及《灵笼》整个庞大故事的开端）。最后第一季也是在马克与在地面上的人类相遇而结束。（这么讲其实还是草率了，如果有时间我还是希望能够去看《灵笼》的剧情）。
反观《时光代理人》却是以一个较为新颖的角度作为设定，也即时间。（具体便是主角团能够以自己的特殊能力进入照片，而在照片里的一言一行都有可能对未来造成影响）。时光照相馆是主角团的“基地”，也是通过这个照相馆接取委托人的任务从而帮助委托人实现一些过去或希望从过去得到线索的事情。由于这部动漫是通过一个个的小故事，因此在这里也不好叙述，依旧是推荐能够去观看动漫本身。
谈动漫本身 很明显两部动漫都具有自己的特点，但是我却依旧将他们放在一起谈，是因为它们给我带来足够的震撼，纵使在这之前亦有《百妖谱》等，却没能给我带来那种共鸣与一种仿佛自己置身于其中希望改变世界的情感。
先谈《灵笼》，灵笼首先在建模方面就足够优秀，虽然采用了我不是很喜欢的建模方式，但是却依旧能够吸引我（对于我这种比较叼的人来说，这个方面就已经足够碾压国产大部分动漫了）不仅如此，人物的表情以及动作都十分逼真，其实到这里就已经可以体现制作者的用心了。当然这只是建模这个我比较关注的方面。接下来应该是剧情方面，《灵笼》的设定是动漫中比较不常见的，本以为这样的题材并不能够很好的把握，但事实是艺画开天以一种更为庞大的世界观来描述这个末日世界，这是在之前的各种影视剧中没有出现的。不仅如此，涉及的领域也十分广泛，大部分动漫可能在主题上会展现的只会是比较重要的一部分，例如青春或者爱情、友情等等。但《灵笼》光第一季就像是想要把自己的所有元素都展现出来，其中的光影会代表着类似教会一般的人，没有什么实质性的作用却控制着一部分人的思想，而会长也借助这些力量来实现自己的目标，甚至几乎摧毁了猎荒者这一强大的对抗力量。这如果影射到现实，便是思想、武装与权力之间的关系。除了这个，人性的描述也十分到位，通过对尘民4068的刻画，既展现了末日阶级统治的一种希望成为更高阶级的渴望，也让观众因为这位尘民的所作所为更加拥有共鸣。最终也会更投入到作品本身。
当然，一部好的的作品我觉得感情线应该是必不可少的。在《灵笼》中，并没有婚恋的自由，甚至拥有“三大法则”制约每一个人的情感。所谓的“爱情”更像是统治阶级给予的枷锁，而作为猎荒者队长的马克，本应遵守这些规则，却仍然在第一季的最后体会到了什么是爱，并为自己所爱的人大闹灯塔。虽然并没有成功的将灯塔上的人的思想扭转过来，但也为作品之后奠定了一个基调。第一季的最后则是利用地上的生存的人来表明这仅仅是《灵笼》这个庞大世界观的开始。还有一个吸引我的点是，在第一季末的一个全季最精彩的打斗场面中，背景音乐采用了纯唢呐，这种打破常规的做法也是取得了一个意想不到的效果，导致了各种二创都不及原版。
再看《时光代理人》，这动漫则是一开始便就从一个故事入手，直入主题，直接为观众呈现了这部作品在之后的表现方式。最开始我以为这只会是一种加强版的泡面番，通过一个个的故事来组成一部动漫，但渐渐的我发现我错了，在短短十几集的动漫中，却在最后的几集给你中给你串连起之前的故事。瞬间让你觉得这不是一个个故事那么简单。这也反应了作品中一直在重复的一句话“无论过去，不问将来”。故事也不是那种偏离现实的故事，而是充满人情味，让你觉得这都是可能发生在你身边的故事。其中的一个描述汶川地震的故事，借用了亲情和爱情令人动容。每个故事又都在恰到好处的地方停了下来。（因此我建议如果要看，就干脆一次性看完）
通过这整个主角团在第一季遭遇的整个故事，很精确的展现了主角团三人的性格特点，沉稳缜密的陆光，正义但却有点冲动的程小时，以及开朗能够带动气氛的乔苓。让人多多少少有点羡慕这样的三人组。第一季的最后程小时为了挽救自己之前在照片里所做过的一些错事，却发现最后仍旧没能改变，这也引出了这部动漫的反派（不止有人能够像他们那样穿越时空回到过去）。也因为这个反派最终主角团三人全部都遭到了不同程度的不幸。第一季也是在这样的一种紧张的气氛中结束了。
给我的感受 看完这两部动漫已经很久了，但是仍然给我一种意犹未尽的感觉，最为明显的情感就是让我觉得在中国，在动漫的国创领域，仍然有这一批热爱动漫，能够写出好故事，能够通过讲好故事带给我们不一样的感受，带给我们动漫魅力的这样一群人。国创的在建模和画风上也在寻求创新以及更适合年轻人观感的改变。故事也具有较为厚重的情感，不像以前的日漫虽有情感，却给我一种较为单薄站不住脚的感觉（当然也不能否认有情感浓重的日漫）。《灵笼》带来的是宏大的世界观和巨大的创作空间。《时光代理人》带来的则是新颖的设定和令人出乎意料的编剧创作。两部动漫都以自己独特的一部分吸引着观众，也引起了在B站的极大热度。当然期待越高，不可避免的便是可能会带来失望。高开低走的动漫已经不少，我只希望拥有这么好的创作背景和创作团队，这两部动漫能够好好的珍惜，能够用尽心思来为观众呈现国漫的另一番风景，至少不要让观众对这两部动漫的呼声成为空喊，也不要让推荐这两部动漫的人最后感到太大的失望。
在最后还是希望国创能够走出一条更加新奇的道路，也希望这两部动漫都能够继续自己第一季的辉煌。
我喜欢的《时光代理人》画风 </description>
    </item>
    
    <item>
      <title>Hugo博客 | stack主题修改第一站</title>
      <link>https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/</guid>
      <description>本来是不想用这篇博文作为新博客的第一篇的，但无奈修改这个主题以便让我能够看得舒服确实花费了我很多精力，因此想写下这一篇博文来记录这一历程，当然这次的修改也只是建博客时对于我来说最难以忍受的痛点，如果在使用的时候觉得还有值得修改的地方，那说不定就有第二站。不废话，直接开冲！
自定义的项目 TO-DO · 修改文章的字体为思源宋体（其实我喜欢行楷，但苦于还没有找到解决方法。。）
· 修改站点图标
· 修改站点名称并使其居中，同时具有一定的间隔。
· 修改选中的样式
· 站点头像居中（虽然本来应该就是居中了。。）
· 添加主页按钮点击不会高亮的问题
· 主页样式的修改
· 修改左边栏头像大小
· 返回顶部功能的添加
· 修改Toc的样式
· 修改分类的标签样式
· 修改滚动条样式
· 使文章支持数学公式编辑
具体修改 修改全站的字体 其实修改字体的方案主题的原作者已经给出，有需要的可以参考修改字体，作为一个中国人，好康的中文永远比好康的英文重要。 具体做法是在站点根目录中的layouts/partials/head/custom.html中添加如下代码：
&amp;lt;style&amp;gt; :root { --article-font-family: &amp;#34;Noto Serif SC&amp;#34;, var(--base-font-family); } &amp;lt;/style&amp;gt; &amp;lt;script&amp;gt; // 正文自重300，标题字重700 (function () { const customFont = document.createElement(&amp;#39;link&amp;#39;); customFont.href = &amp;#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&amp;amp;display=swap&amp;#34;; customFont.type = &amp;#34;text/css&amp;#34;; customFont.rel = &amp;#34;stylesheet&amp;#34;; document.head.appendChild(customFont); }()); &amp;lt;/script&amp;gt; 以上是作者给出的，我只是在字重上做了修改。除此之外我还修改了hugo-theme-stack/assets/scss/variable.scss文件，具体就是调整了--zh-font-family和--base-font-family的顺序，代码如下：
--zh-font-family: &amp;#34;Noto Serif SC&amp;#34;, &amp;#34;Hiragino Sans GB&amp;#34;, &amp;#34;Droid Sans Fallback&amp;#34;, &amp;#34;Microsoft YaHei&amp;#34;; --base-font-family: &amp;#34;Noto Serif SC&amp;#34;, var(--sys-font-family), var(--zh-font-family), sans-serif; 修改站点的图标 这个问题起先困扰了我很久（虽然期间可能已经修改好了，但因为网站cookie的原因导致修改没有及时显示），具体做法如下，先将你需要的图片转换为.</description>
    </item>
    
    <item>
      <title>LeetCode 复杂链表的复制</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 解题 题目的意思很简单，就是返回一个一模一样的链表头结点。由于随机指针的存在，链表的复制不能够像正常链表那样直接遍历，也因此没想明白要怎么做，最后翻了题解，才发现又是我最烦的递归。
这道题采用的递归解法其实本质就是遇到问题再解决问题，在还没有开始复制之前，所有的复制结点都是虚无的，要让这些结点和已知的结点一一对应起来就需要一个map数据结构。用来对应新旧两个链表的结点。这样从第一个结点入手，当这个结点不在map中时，就立刻创建这个结点并于原链表中的相应结点建立对应关系。之后的每一个结点都可以根据这样的逻辑进行创建，而因为有map这个数据结构的存在，这样每个结点都不是虚空存在的，而是可以在map中找到与之对应的结点。可以解决随机结点创建的问题。具体代码如下：
class Solution { public: unordered_map&amp;lt;Node*, Node*&amp;gt; um; // 用来存储两个链表，结点之间一一对应 Node* copyRandomList(Node* head) { if (head == NULL) { // 如果链表本就为空，那么直接返回空 return NULL; } // 遵循边遍历边创建的原则 if (!um.count(head)) { // 如果此时哈希表中没有这个结点，就直接创建 Node* headNew = new Node(head-&amp;gt;val); // 初始化一个相同的结点 um.insert(make_pair(head, headNew)); // 将这两个位置一样的结点对应起来 headNew-&amp;gt;next = copyRandomList(head-&amp;gt;next); // 同理下一个结点也应该这样拷贝，依旧遵循上面的原则 headNew-&amp;gt;random = copyRandomList(head-&amp;gt;random); } // 如果这个结点已经在哈希表中存在，那么就直接返回 return um[head]; } }; </description>
    </item>
    
    <item>
      <title>LeetCode 141 环形链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
示例 在这里插入图片描述 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 在这里插入图片描述 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 在这里插入图片描述 输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示 链表中节点的数目范围是 [0, 104]-105 &amp;lt;= Node.val &amp;lt;= 105pos 为 -1 或者链表中的一个 有效索引 。 解题想法 这道题在leetcode上属于简单题，但由于第一次遇见这种解法（也由于第一次想错了，根本不是正解）所以就想记录一下。 很明显题目要判断链表中是否有环，于是可以想到如果在链表中有两个指针分别向前跑，当两个指针指向的结点相同的时候便证明链表中有环存在。这个时候就需要一个循环来判断两个指针是否相等。此时条件应该是first != second因此如果我们初始化两个指针在同一个位置，那么将无法进入循环，因此需要将两个指针分别初始化在头结点以及头结点的下一个结点，还要注意的是，first指针的速度应该要快于second指针的速度，这样，当链表中有环时，first指针会先进入环中，并一直在环中循环，而当second指针进入环时，由于first指针速度快，将会在某个循环时刻追上second指针，这样当两个指针重合后就能够判断出链表存在环，下面附上C++代码
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>LeetCode 862 和至少为K的最短子数组</title>
      <link>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目描述 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。
如果没有和至少为 K 的非空子数组，返回 -1
示例 输入：A = [1], K = 1输出：1输入：A = [1,2], K = 4输出：-1输入：A = [2,-1,2], K = 3输出：3 提示 1. 1 &amp;lt;= A.length &amp;lt;= 500002. -10 ^ 5 &amp;lt;= A[i] &amp;lt;= 10 ^ 53. 1 &amp;lt;= K &amp;lt;= 10 ^ 9 首先对于我这样一个不怎么有基础的人来说，这道题着实是令我作呕。。解题也是通过了其它题解的启发。下面就开始吧。
解题想法 由于题目中已经明确表示了数组的长度为50000，因此如果要使用暴力接法，势必造成O(n^2)的时间复杂度。因此就要想办法让i， j两个循环变量只跑一遍。而对于这道题因为绕不开要求取数组中的区间和。所以可以采用的一个方法是前缀和思想。大致的意思就是sum[i] = array[0] + array[1] + &amp;hellip; + array[i - 1]利用这个前缀和数组就可以较为方便的得到一个数组的区间和，例如要知道区间[1, 3]的和，我们可以利用前缀和数组得到sum[4] - sum[1]（这里需要注意的是，为了便于计算前缀和数组的第零个元素默认为零）</description>
    </item>
    
  </channel>
</rss>
