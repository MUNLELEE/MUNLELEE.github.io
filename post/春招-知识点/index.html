<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列*（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时**（只要求同名，不管参数列表是否相同）**，访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区*（不仅可以是堆还可以是静态存储区）*上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、**是否需要指定内存大小。**使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、**是否调用构造函数。**使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、**对数组的处理。**C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、**是否能够重新分配内存。**使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。
虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。
当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。
3.1、虚函数指针 本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。只有拥有虚函数的类才会拥有虚函数指针，只有拥有虚函数的类才会拥有虚函数指针，每个虚函数也都会对应一个虚函数指针。
3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？ 两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。
3.3、虚构函数可以是虚函数吗？ 析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。'><title>春招 | 知识点留档</title>

<link rel='canonical' href='https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/'>

<link rel="stylesheet" href="/scss/style.min.36d617335b89745195c2d170d40e8c72216d9b8d13e2f80ba988a10f8c83b6ea.css"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script>
    
    $(window).scroll(function() {
    if ($(this).scrollTop()) {
        $('#go-top').fadeIn();
    } else {
        $('#go-top').fadeOut();
    }
    });

    
    $('#go-top').click(function() {
    $('html, body').animate({scrollTop: 0}, 1000);
    return false;
    });
</script>
<meta property='og:title' content='春招 | 知识点留档'>
<meta property='og:description' content='春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列*（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时**（只要求同名，不管参数列表是否相同）**，访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区*（不仅可以是堆还可以是静态存储区）*上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、**是否需要指定内存大小。**使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、**是否调用构造函数。**使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、**对数组的处理。**C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、**是否能够重新分配内存。**使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。
虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。
当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。
3.1、虚函数指针 本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。只有拥有虚函数的类才会拥有虚函数指针，只有拥有虚函数的类才会拥有虚函数指针，每个虚函数也都会对应一个虚函数指针。
3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？ 两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。
3.3、虚构函数可以是虚函数吗？ 析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。'>
<meta property='og:url' content='https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/'>
<meta property='og:site_name' content='墨纹'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='春招' /><meta property='article:published_time' content='2022-02-02T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-02-02T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="春招 | 知识点留档">
<meta name="twitter:description" content="春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列*（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时**（只要求同名，不管参数列表是否相同）**，访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区*（不仅可以是堆还可以是静态存储区）*上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、**是否需要指定内存大小。**使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、**是否调用构造函数。**使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、**对数组的处理。**C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、**是否能够重新分配内存。**使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。
虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。
当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。
3.1、虚函数指针 本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。只有拥有虚函数的类才会拥有虚函数指针，只有拥有虚函数的类才会拥有虚函数指针，每个虚函数也都会对应一个虚函数指针。
3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？ 两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。
3.3、虚构函数可以是虚函数吗？ 析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><style>
    :root {
        --article-font-family: "Noto Serif SC", var(--base-font-family);
    }
</style>

<script> 
		(function () {
		    const customFont = document.createElement('link');
		    customFont.href = "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap"; 
		    customFont.type = "text/css";
		    customFont.rel = "stylesheet";
		
		    document.head.appendChild(customFont);
		}());
</script>
<style>
	h1 {
		letter-spacing: 6px;
	}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%AD%A6%E4%B9%A0/" >
                学习
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/">春招 | 知识点留档</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 02, 2022</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。</p>
<h2 id="1重载隐藏重写覆盖三者的区别">1、重载、隐藏、重写（覆盖）三者的区别</h2>
<p><strong>重载：<strong>是指同一可访问区内被声明的几个具有</strong>不同参数列</strong>*（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。</p>
<p><strong>隐藏：<strong>指的是派生类类型的对象、指针引用访问基类和派生类</strong>都有</strong>的同名函数时**（只要求同名，不管参数列表是否相同）**，访问的是派生类的函数，即隐藏了基类的同名函数。</p>
<p><strong>重写（覆盖）：<strong>是</strong>指派生类</strong>中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p>此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。</p>
<h3 id="三者更为深入的一些问题">三者更为深入的一些问题</h3>
<h4 id="11-重载为什么改变参数就可以实现调用不同函数">1.1 重载为什么改变参数就可以实现调用不同函数？</h4>
<p>因为C++在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。</p>
<h4 id="12-构造函数可以被重载吗析构函数呢">1.2 构造函数可以被重载吗？析构函数呢？</h4>
<p>构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。</p>
<h2 id="2new和malloc的区别">2、new和malloc的区别</h2>
<p>据说是C++的经典问题，在综合了网络上的一些博文后，得出以下几点不同。</p>
<p>（1）、<strong>申请内存所在区域。</strong><code>new</code>操作符从自由存储区*（不仅可以是堆还可以是静态存储区）*上为对象动态分配内存，而<code>malloc</code>从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。</p>
<p>（2）、<strong>返回类型。</strong><code>new</code>操作符返回的是对象类型指针，不需要进行强制转换；<code>malloc</code>内存分配成功则是返回<code>void*</code>，需要通过强制类型转换成指定类型。</p>
<p>（3）、<strong>内存分配失败时的返回值。</strong><code>new</code>内存分配失败时，会抛出<code>bad_alloc</code>异常，不会返回<code>NULL</code>，<code>malloc</code>分配内存失败时返回<code>NULL</code></p>
<p>（4）、**是否需要指定内存大小。**使用<code>new</code>操作符时进行内存分配时无需指定内存块的大小，使用<code>malloc</code>需要显式的指定内存的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {...}
A <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A;
A <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> (A<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(A));
</code></pre></div><p>（5）、**是否调用构造函数。**使用<code>new</code>操作符分配对象内存时经历如下的几个步骤：</p>
<p>· 调用<code>operator new</code>函数（数组是<code>operator new[]</code>）来分配内存空间</p>
<p>· 编译器运行相应的构造函数创建对象，并赋初值</p>
<p>· 返回指向这个对象的指针</p>
<p>使用<code>delete</code>操作符释放内存空间时会经历如下步骤：</p>
<p>· 调用对象的析构函数</p>
<p>· 编译器调用<code>operator delete</code>（<code>operator delete[]</code>）释放内存空间</p>
<p>使用<code>malloc</code>分配内存则不会调用构造函数</p>
<p>（6）、**对数组的处理。**C++提供了<code>new []</code>和<code>delete []</code>来专门处理数组类型，而malloc需要自己指定数组的大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>)  <span style="color:#75715e">// 分配一个十个int大小的数组
</span></code></pre></div><p>（7）、**是否能够重新分配内存。**使用<code>malloc</code>分配内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code>函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。<code>new</code>没有扩充内存的配套操作</p>
<p>（8）、<strong>客户处理内存分配不足。</strong><code>new</code>会有异常机制，而<code>malloc</code>只能返回<code>NULL</code></p>
<h2 id="3虚函数">3、虚函数</h2>
<p>虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成<strong>运行时决议</strong>，与传统的编译时决定有本质区别。</p>
<p>虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。</p>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。</strong></p>
<h4 id="31虚函数指针">3.1、虚函数指针</h4>
<p>本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。只有拥有虚函数的类才会拥有虚函数指针，只有拥有虚函数的类才会拥有虚函数指针，每个虚函数也都会对应一个虚函数指针。</p>
<h4 id="32ab两个类类中有虚函数c继承ab有几张虚函数表">3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？</h4>
<p>两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。</p>
<h4 id="33虚构函数可以是虚函数吗">3.3、虚构函数可以是虚函数吗？</h4>
<p>析构函数必须是虚函数。因为如果不是虚函数，<strong>当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。</strong></p>
<h2 id="4什么是多态机制">4、什么是多态机制</h2>
<p>面向对象的三大特征：封装，继承，多态。</p>
<p>多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。<strong>运行时的多态则和虚函数、继承有关。</strong></p>
<h3 id="深入">深入</h3>
<h4 id="31多态底层的实现机制">3.1、多态底层的实现机制</h4>
<p>利用虚函数表，先构建一个基类，然后在<strong>基类的构造函数中会建立虚函数表</strong>，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。</p>
<p>虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在<code>.rdata</code>只读数据段。</p>
<h4 id="32父类构造函数中是否可以调用虚函数">3.2、父类构造函数中是否可以调用虚函数</h4>
<p>可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。这是因为在定义子类对象的时候，会先调用父类的构造函数，<strong>而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存</strong>，C++标准规范中规定了在这种情况下，**即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。**所以使用的是静态绑定，调用了父类的函数。</p>
<h4 id="33构造函数可以是虚函数吗">3.3、构造函数可以是虚函数吗？</h4>
<p>不可以，因为虚函数存在的**唯一目的就是为了多态。**而子类并不继承父类的构造函数，所以没有使父类构造函数变成虚函数的必要。另一方面，构造函数为类对象初始化了内存空间，里面保存了指向虚函数的指针，如果构造函数是虚函数，导致没有实例化对象，也就没有内存空间，更不会有虚函数。</p>
<h4 id="34静态函数可以是虚函数吗">3.4、静态函数可以是虚函数吗？</h4>
<ul>
<li><code>static</code>成员不属于任何类对象或实例，所以即使给<code>static</code>函数加上<code>virtual</code>也是没有任何意义的。</li>
<li>静态与非静态成员函数之间有一个主要区别。那就是静态成员函数<strong>没有<code>this</code>指针</strong>，所以无法访问<code>vptr</code>，进而不能访问虚函数表</li>
</ul>
<h2 id="5指针和引用的区别">5、指针和引用的区别</h2>
<p>**指针：**指针是一个变量，用于保存另一个变量的地址，指针需要用<code>*</code>来进行解引用，以获取它指向的内存地址上的内容。</p>
<p>**引用：**引用是一个已经存在的变量的别名，但引用也是通过存储变量的地址来实现对变量的修改的</p>
<p>两者的区别：</p>
<ul>
<li>引用必须<strong>定义时初始化</strong>，不能像指针一样，指针可以定义后视情况初始化</li>
<li>引用本身、就不能改变指向因此不存在引用常量（<code>int &amp;const r = a</code>）</li>
<li>指针可以有多级，但是引用只能有一级</li>
<li>指针的<code>++</code>、<code>--</code>代表下一个数据，而引用的<code>++</code>、<code>--</code>则代表数据本身的修改。</li>
<li><code>sizeof(引用)</code>得到的是所指向的变量（对象）的大小，而<code>sizeof(指针)</code>得到的是指针本身的大小</li>
<li>当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会产生一个临时变量。</li>
</ul>
<h2 id="6static关键字">6、static关键字</h2>
<h3 id="面向过程的static">面向过程的static</h3>
<p>（1）、<strong>函数中的静态变量。<strong>当变量声明为<code>static</code>时，其空间在程序的生命周期内分配，被存放在</strong>全局数据区</strong>。即使多次调用此函数，静态变量的空间也只<strong>分配一次</strong>，前一次调用的变量值通过下一次调用传递。</p>
<p><em>静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。</em></p>
<h3 id="面向对象的static">面向对象的static</h3>
<p>（1）、<strong>类中的静态变量。<strong>声明为<code>static</code>的变量只能被初始化一次，而且</strong>必须初始化</strong>，且类中的静态变量由<strong>对象共享</strong>，类中的静态成员变量必须在类内声明，在类外定义（<code>const</code>修饰可以直接定义）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> num;  <span style="color:#75715e">// 类内声明
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> num_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// const可以在声明时就初始化
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// 类外初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
    A a;
    cout <span style="color:#f92672">&lt;&lt;</span> a.num; <span style="color:#75715e">// 输出10
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> A<span style="color:#f92672">::</span>num; <span style="color:#75715e">// 输出10
</span><span style="color:#75715e"></span>}
</code></pre></div><p>（2）、**类中的静态成员函数。**静态成员函数不依赖于类的对象。允许使用<code>.</code>和类名来调用静态成员函数。<strong>静态成员函数只能访问静态成员变量或其它静态成员函数。</strong></p>
<p>此外还有以下特点</p>
<ul>
<li>static成员变量不占用对象的内存，而是在所有对象之外开辟内存</li>
<li>static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在<strong>类外初始化时分配</strong>，即没有在类外初始化的静态成员变量不能使用</li>
</ul>
<h2 id="7const关键字">7、const关键字</h2>
<p>作用：被其修饰的值不能改变，是只读变量。必须在定义时就赋初值。</p>
<p>const关键字还可以用来修饰指针，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p; <span style="color:#75715e">// 常量指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p; <span style="color:#75715e">// 指针常量 
</span></code></pre></div><h3 id="常量指针">常量指针</h3>
<p>也称为底层const，指针指向的值被指针限定住，不能通过指针改变指向的值。但此时可以修改指针的指向。</p>
<h3 id="指针常量">指针常量</h3>
<p>也称为顶层const，指针指向的地址不能修改，并且<strong>声明时必须初始化</strong>，但是指针指向的地址的内容可以通过指针修改。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%98%A5%E6%8B%9B/">春招</a>
        
    </section>


    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">LeetCode 二叉搜索树与双向链表</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">
        
        

        <div class="article-details">
            <h2 class="article-title">LeetCode 矩阵中的路径</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">
        
        

        <div class="article-details">
            <h2 class="article-title">LeetCode 最长不含重复字符的子字符串</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2022 墨纹
    </section>
    
    <section class="powerby">
        
            你要相信流星划过会带给我们幸运，就像现实告诉你我要心存感激 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#1重载隐藏重写覆盖三者的区别">1、重载、隐藏、重写（覆盖）三者的区别</a>
      <ul>
        <li><a href="#三者更为深入的一些问题">三者更为深入的一些问题</a></li>
      </ul>
    </li>
    <li><a href="#2new和malloc的区别">2、new和malloc的区别</a></li>
    <li><a href="#3虚函数">3、虚函数</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#4什么是多态机制">4、什么是多态机制</a>
      <ul>
        <li><a href="#深入">深入</a></li>
      </ul>
    </li>
    <li><a href="#5指针和引用的区别">5、指针和引用的区别</a></li>
    <li><a href="#6static关键字">6、static关键字</a>
      <ul>
        <li><a href="#面向过程的static">面向过程的static</a></li>
        <li><a href="#面向对象的static">面向对象的static</a></li>
      </ul>
    </li>
    <li><a href="#7const关键字">7、const关键字</a>
      <ul>
        <li><a href="#常量指针">常量指针</a></li>
        <li><a href="#指针常量">指针常量</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
                
                
                <a class="go-top" id="go-top" href="#top">
                    <img src="/img/top3_hu2d68ddee36f4745c9b8a323729022ab3_7941_35x0_resize_box_3.png" />
                </a>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<div class="btn-scroll-top">
    <i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>


    </body>
</html>
