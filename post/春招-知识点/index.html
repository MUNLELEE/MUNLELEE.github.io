<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时 （只要求同名，不管参数列表是否相同），访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区 （不仅可以是堆还可以是静态存储区） 上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、是否需要指定内存大小。 使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、是否调用构造函数。 使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、对数组的处理。 C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、是否能够重新分配内存。 使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。'><title>春招 | 知识点留档</title>

<link rel='canonical' href='https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/'>

<link rel="stylesheet" href="/scss/style.min.36d617335b89745195c2d170d40e8c72216d9b8d13e2f80ba988a10f8c83b6ea.css"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script>
    
    $(window).scroll(function() {
    if ($(this).scrollTop()) {
        $('#go-top').fadeIn();
    } else {
        $('#go-top').fadeOut();
    }
    });

    
    $('#go-top').click(function() {
    $('html, body').animate({scrollTop: 0}, 1000);
    return false;
    });
</script>
<meta property='og:title' content='春招 | 知识点留档'>
<meta property='og:description' content='春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时 （只要求同名，不管参数列表是否相同），访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区 （不仅可以是堆还可以是静态存储区） 上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、是否需要指定内存大小。 使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、是否调用构造函数。 使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、对数组的处理。 C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、是否能够重新分配内存。 使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。'>
<meta property='og:url' content='https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/'>
<meta property='og:site_name' content='墨纹'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='春招' /><meta property='article:published_time' content='2022-02-02T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-02-02T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="春招 | 知识点留档">
<meta name="twitter:description" content="春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。
1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。
隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时 （只要求同名，不管参数列表是否相同），访问的是派生类的函数，即隐藏了基类的同名函数。
重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。
此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。
三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C&#43;&#43;在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。
1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。
2、new和malloc的区别 据说是C&#43;&#43;的经典问题，在综合了网络上的一些博文后，得出以下几点不同。
（1）、申请内存所在区域。new操作符从自由存储区 （不仅可以是堆还可以是静态存储区） 上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。
（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。
（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL
（4）、是否需要指定内存大小。 使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。
class A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、是否调用构造函数。 使用new操作符分配对象内存时经历如下的几个步骤：
· 调用operator new函数（数组是operator new[]）来分配内存空间
· 编译器运行相应的构造函数创建对象，并赋初值
· 返回指向这个对象的指针
使用delete操作符释放内存空间时会经历如下步骤：
· 调用对象的析构函数
· 编译器调用operator delete（operator delete[]）释放内存空间
使用malloc分配内存则不会调用构造函数
（6）、对数组的处理。 C&#43;&#43;提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小
int *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、是否能够重新分配内存。 使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作
（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL
3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><style>
    :root {
        --article-font-family: "Noto Serif SC", var(--base-font-family);
    }
</style>

<script> 
		(function () {
		    const customFont = document.createElement('link');
		    customFont.href = "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap"; 
		    customFont.type = "text/css";
		    customFont.rel = "stylesheet";
		
		    document.head.appendChild(customFont);
		}());
</script>
<style>
	h1 {
		letter-spacing: 6px;
	}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%AD%A6%E4%B9%A0/" >
                学习
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/">春招 | 知识点留档</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 02, 2022</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。</p>
<h2 id="1重载隐藏重写覆盖三者的区别">1、重载、隐藏、重写（覆盖）三者的区别</h2>
<p><strong>重载：<strong>是指同一可访问区内被声明的几个具有</strong>不同参数列</strong>（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。</p>
<p><strong>隐藏：<strong>指的是派生类类型的对象、指针引用访问基类和派生类</strong>都有</strong>的同名函数时 <em>（只要求同名，不管参数列表是否相同）</em>，访问的是派生类的函数，即隐藏了基类的同名函数。</p>
<p><strong>重写（覆盖）：<strong>是</strong>指派生类</strong>中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p>
<p>此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。</p>
<h3 id="三者更为深入的一些问题">三者更为深入的一些问题</h3>
<h4 id="11-重载为什么改变参数就可以实现调用不同函数">1.1 重载为什么改变参数就可以实现调用不同函数？</h4>
<p>因为C++在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。</p>
<h4 id="12-构造函数可以被重载吗析构函数呢">1.2 构造函数可以被重载吗？析构函数呢？</h4>
<p>构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。</p>
<h2 id="2new和malloc的区别">2、new和malloc的区别</h2>
<p>据说是C++的经典问题，在综合了网络上的一些博文后，得出以下几点不同。</p>
<p>（1）、<strong>申请内存所在区域。</strong><code>new</code>操作符从自由存储区 <em>（不仅可以是堆还可以是静态存储区）</em> 上为对象动态分配内存，而<code>malloc</code>从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。</p>
<p>（2）、<strong>返回类型。</strong><code>new</code>操作符返回的是对象类型指针，不需要进行强制转换；<code>malloc</code>内存分配成功则是返回<code>void*</code>，需要通过强制类型转换成指定类型。</p>
<p>（3）、<strong>内存分配失败时的返回值。</strong><code>new</code>内存分配失败时，会抛出<code>bad_alloc</code>异常，不会返回<code>NULL</code>，<code>malloc</code>分配内存失败时返回<code>NULL</code></p>
<p>（4）、<strong>是否需要指定内存大小。</strong> 使用<code>new</code>操作符时进行内存分配时无需指定内存块的大小，使用<code>malloc</code>需要显式的指定内存的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {...}
A <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A;
A <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> (A<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(A));
</code></pre></div><p>（5）、<strong>是否调用构造函数。</strong> 使用<code>new</code>操作符分配对象内存时经历如下的几个步骤：</p>
<p>· 调用<code>operator new</code>函数（数组是<code>operator new[]</code>）来分配内存空间</p>
<p>· 编译器运行相应的构造函数创建对象，并赋初值</p>
<p>· 返回指向这个对象的指针</p>
<p>使用<code>delete</code>操作符释放内存空间时会经历如下步骤：</p>
<p>· 调用对象的析构函数</p>
<p>· 编译器调用<code>operator delete</code>（<code>operator delete[]</code>）释放内存空间</p>
<p>使用<code>malloc</code>分配内存则不会调用构造函数</p>
<p>（6）、<strong>对数组的处理。</strong> C++提供了<code>new []</code>和<code>delete []</code>来专门处理数组类型，而malloc需要自己指定数组的大小</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>)  <span style="color:#75715e">// 分配一个十个int大小的数组
</span></code></pre></div><p>（7）、<strong>是否能够重新分配内存。</strong> 使用<code>malloc</code>分配内存后，如果在使用过程中发现内存不足，可以使用<code>realloc</code>函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。<code>new</code>没有扩充内存的配套操作</p>
<p>（8）、<strong>客户处理内存分配不足。</strong><code>new</code>会有异常机制，而<code>malloc</code>只能返回<code>NULL</code></p>
<h2 id="3虚函数">3、虚函数</h2>
<p>虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成<strong>运行时决议</strong>，与传统的编译时决定有本质区别。</p>
<p>虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。</p>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。</strong></p>
<h3 id="31虚函数指针">3.1、虚函数指针</h3>
<p>本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。 <strong>只有拥有虚函数的类才会拥有虚函数指针</strong> ，每个虚函数也都会对应一个虚函数指针。</p>
<h3 id="32ab两个类类中有虚函数c继承ab有几张虚函数表">3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？</h3>
<p>两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。</p>
<h3 id="33虚构函数可以是虚函数吗">3.3、虚构函数可以是虚函数吗？</h3>
<p>析构函数必须是虚函数。因为如果不是虚函数，<strong>当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。</strong></p>
<h2 id="4什么是多态机制">4、什么是多态机制</h2>
<p>面向对象的三大特征：封装，继承，多态。</p>
<p>多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。<strong>运行时的多态则和虚函数、继承有关。</strong></p>
<h3 id="深入">深入</h3>
<h4 id="31多态底层的实现机制">3.1、多态底层的实现机制</h4>
<p>利用虚函数表，先构建一个基类，然后在<strong>基类的构造函数中会建立虚函数表</strong>，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。</p>
<p>虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在<code>.rdata</code>只读数据段。</p>
<h4 id="32父类构造函数中是否可以调用虚函数">3.2、父类构造函数中是否可以调用虚函数</h4>
<p>可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。这是因为在定义子类对象的时候，会先调用父类的构造函数，<strong>而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存</strong>，C++标准规范中规定了在这种情况下，**即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。**所以使用的是静态绑定，调用了父类的函数。</p>
<h4 id="33构造函数可以是虚函数吗">3.3、构造函数可以是虚函数吗？</h4>
<p>不可以，因为虚函数存在的 <strong>唯一目的就是为了多态。</strong> 而子类并不继承父类的构造函数，所以没有使父类构造函数变成虚函数的必要。另一方面，构造函数为类对象初始化了内存空间，里面保存了指向虚函数的指针，如果构造函数是虚函数，导致没有实例化对象，也就没有内存空间，更不会有虚函数。</p>
<h4 id="34静态函数可以是虚函数吗">3.4、静态函数可以是虚函数吗？</h4>
<ul>
<li><code>static</code>成员不属于任何类对象或实例，所以即使给<code>static</code>函数加上<code>virtual</code>也是没有任何意义的。</li>
<li>静态与非静态成员函数之间有一个主要区别。那就是静态成员函数<strong>没有<code>this</code>指针</strong>，所以无法访问<code>vptr</code>，进而不能访问虚函数表</li>
</ul>
<h2 id="5指针和引用的区别">5、指针和引用的区别</h2>
<p><strong>指针：</strong> 指针是一个变量，用于保存另一个变量的地址，指针需要用<code>*</code>来进行解引用，以获取它指向的内存地址上的内容。</p>
<p><strong>引用：</strong> 引用是一个已经存在的变量的别名，但引用也是通过存储变量的地址来实现对变量的修改的</p>
<p>两者的区别：</p>
<ul>
<li>引用必须<strong>定义时初始化</strong>，不能像指针一样，指针可以定义后视情况初始化</li>
<li>引用本身、就不能改变指向因此不存在引用常量（<code>int &amp;const r = a</code>）</li>
<li>指针可以有多级，但是引用只能有一级</li>
<li>指针的<code>++</code>、<code>--</code>代表下一个数据，而引用的<code>++</code>、<code>--</code>则代表数据本身的修改。</li>
<li><code>sizeof(引用)</code>得到的是所指向的变量（对象）的大小，而<code>sizeof(指针)</code>得到的是指针本身的大小</li>
<li>当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会产生一个临时变量。</li>
</ul>
<h2 id="6static关键字">6、static关键字</h2>
<h3 id="面向过程的static">面向过程的static</h3>
<p>（1）、<strong>函数中的静态变量。<strong>当变量声明为<code>static</code>时，其空间在程序的生命周期内分配，被存放在</strong>全局数据区</strong>。即使多次调用此函数，静态变量的空间也只<strong>分配一次</strong>，前一次调用的变量值通过下一次调用传递。</p>
<p><em>静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。</em></p>
<h3 id="面向对象的static">面向对象的static</h3>
<p>（1）、<strong>类中的静态变量。<strong>声明为<code>static</code>的变量只能被初始化一次，而且</strong>必须初始化</strong>，且类中的静态变量由<strong>对象共享</strong>，类中的静态成员变量必须在类内声明，在类外定义（<code>const</code>修饰可以直接定义）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> num;  <span style="color:#75715e">// 类内声明
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> num_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// const可以在声明时就初始化
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>num <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// 类外初始化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
    A a;
    cout <span style="color:#f92672">&lt;&lt;</span> a.num; <span style="color:#75715e">// 输出10
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> A<span style="color:#f92672">::</span>num; <span style="color:#75715e">// 输出10
</span><span style="color:#75715e"></span>}
</code></pre></div><p>（2）、<strong>类中的静态成员函数。</strong> 静态成员函数不依赖于类的对象。允许使用<code>.</code>和类名来调用静态成员函数。<strong>静态成员函数只能访问静态成员变量或其它静态成员函数。</strong></p>
<p>此外还有以下特点</p>
<ul>
<li>static成员变量不占用对象的内存，而是在所有对象之外开辟内存</li>
<li>static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在<strong>类外初始化时分配</strong>，即没有在类外初始化的静态成员变量不能使用</li>
</ul>
<h2 id="7const关键字">7、const关键字</h2>
<p>作用：被其修饰的值不能改变，是只读变量。必须在定义时就赋初值。</p>
<p>const关键字还可以用来修饰指针，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p; <span style="color:#75715e">// 常量指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p; <span style="color:#75715e">// 指针常量 
</span></code></pre></div><h3 id="常量指针">常量指针</h3>
<p>底层const，指针指向的值被指针限定住，不能通过指针改变指向的值。但此时可以修改指针的指向。</p>
<h3 id="指针常量">指针常量</h3>
<p>顶层const，指针指向的地址不能修改，并且<strong>声明时必须初始化</strong>，但是指针指向的地址的内容可以通过指针修改。</p>
<h2 id="8stl专题">8、STL专题</h2>
<h3 id="1vector">（1）、vector</h3>
<p>可变大小的数组， <strong>支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</strong>。</p>
<ul>
<li><strong>底层原理</strong></li>
</ul>
<p>底层为动态数组，包括三个迭代器，<code>begin</code>和<code>end</code>是已经被使用的空间范围，<code>end_of_storage</code>是整块连续空间包括备用空间的尾部。</p>
<p>当空间不够装下数据时，会<strong>自动申请另一片更大的空间</strong>（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的内存空间，而当释放或者删除vector里面的数据时（<code>v.clear()</code>），其存储空间不释放，仅仅是清空了里面的数据。</p>
<ul>
<li><strong>reserve和resize的区别</strong></li>
</ul>
<p><strong>reserve：</strong> 是直接扩充到已经确定的大小，可以减少开辟、释放空间的问题，提高效率。</p>
<p><strong>resize：</strong> 可以改变有效空间的大小，因此<code>capacity</code>的大小也会随之改变。</p>
<ul>
<li><strong>size和capacity的区别</strong></li>
</ul>
<p>size表示当前vector中有多少个元素，而capacity函数表示它已经分配的内存中可以容纳多少元素。</p>
<ul>
<li><strong>vector元素是否可以是引用</strong></li>
</ul>
<p>vector的底层实现要求连续的 <strong>对象排列</strong> ， <strong>引用并非对象</strong> ，没有实际地址，因此元素不能是引用。</p>
<h3 id="2list">（2）、list</h3>
<ul>
<li><strong>底层原理</strong></li>
</ul>
<p>list底层是一个<strong>双向链表</strong>，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间，<strong>不支持随机存取</strong>，适合需要大量的插入和删除操作的数据结构。</p>
<p><em>一些函数操作：</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">list.unique()  <span style="color:#75715e">// 移除数值相同的连续元素
</span><span style="color:#75715e"></span>list.sort()  <span style="color:#75715e">// 对list进行排序，通常可以和上面的函数连用
</span></code></pre></div><h3 id="3deque">（3）、deque</h3>
<ul>
<li><strong>底层原理</strong></li>
</ul>
<p>deque是一个双向开口的连续性空间（双端队列），在头尾两端插入都有理想的时间复杂度。但是<strong>整个空间并不是连续的，而是一段一段的</strong>，为了维护其整体连续的假象，并提供随机存取的接口。设计了一个中控器，用来记录deque内部每一段连续空间的地址。类似于数据结构中的map。对象的<code>key</code>值为地址，而<code>value</code>则是对应的连续的地址空间。是一个动态数组，一旦需要扩容，就是在<strong>首尾配置一段定量连续空间。</strong></p>
<h3 id="4setmapmultisetmultimap">（4）、set、map、multiset、multimap</h3>
<ul>
<li><strong>底层原理</strong></li>
</ul>
<p>这些容器的底层实现都是<strong>红黑树</strong>。由于采用红黑树实现，因此在插入和删除时，都需要<strong>寻找结点</strong>，因此会损失一定的效率。</p>
<p><em>关于红黑树：</em></p>
<p>1、每个结点是红色或者是黑色</p>
<p>2、根结点是黑色的</p>
<p>3、每个叶结点是黑的</p>
<p>4、如果一个结点是红的，那么它的两个孩子结点都是黑色</p>
<p>5、每个结点到其子孙结点的所有路径上包含相同数目的黑色结点</p>
<ul>
<li><strong>容器特点</strong></li>
</ul>
<p>set与multiset容器会根据特定的排序准则<strong>自动将元素排序</strong>，set中元素<strong>不允许重复</strong>，multiset中<strong>元素允许重复</strong>。</p>
<p>map与multimap容器则是以<code>key</code>和<code>value</code>组成的<code>pair</code>作为元素，根据key的排序准则，自动将元素排序，在map中<code>key</code>值<strong>不允许重复</strong>，而multimap中key值<strong>可以重复</strong>。</p>
<h3 id="5unordered_mapunordered_set">（5）、unordered_map、unordered_set</h3>
<ul>
<li><strong>底层原理</strong></li>
</ul>
<p>底层是一个<strong>防冗余</strong>的哈希表（采用除留余数法）。能够尽可能的降低数据的存储和查找的时间，若产生哈希冲突，一般采用<strong>拉链法</strong>来解决冲突</p>
<ul>
<li><strong>与map、set相比</strong></li>
</ul>
<p>查找速度比map、set快，通常为常数级别，但会<strong>消耗较多的内存</strong>，且构造速度较慢。</p>
<h2 id="9c内存分区">9、C++内存分区</h2>
<p>在C++中分为五大内存分区，分别是 <strong>堆</strong> 、 <strong>栈</strong>  、 <strong>自由存储区</strong> 、 <strong>全局/静态存储区</strong> 和 <strong>常量存储区</strong></p>
<ul>
<li>
<p><strong>栈：</strong> 由编译器在 <strong>需要时分配</strong>，在 <strong>不需要时自动清除</strong> 的变量存储区。里面的变量通常是局部变量，函数参数等。</p>
</li>
<li>
<p><strong>堆：</strong> 操作系统层面的术语，为<code>malloc</code>等分配的内存块，用<code>free</code>结束自己的生命周期。</p>
</li>
<li>
<p><strong>自由存储区：</strong> C++层面上的术语，为<code>new</code>分配的内存块，它们的释放编译器不进行管理，而是由应用程序控制，一般<code>new</code>后需要<code>delete</code>，如果没有释放，操作系统会在程序结束之后回收</p>
<p><em>因为 <code>new</code> 的申请是调用 <code>malloc</code> 的，自由存储区就和堆类似，但不等价</em></p>
</li>
<li>
<p><strong>全局/静态存储区：</strong> 全局变量和静态变量被分配到同一块内存中。</p>
<p><em>初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束之后由系统释放。</em></p>
</li>
<li>
<p><strong>常量存储区：</strong> 一块特殊的存储区，存放 <strong>常量</strong> ，这些常量不允许被修改，程序结束后由系统释放</p>
</li>
</ul>
<h2 id="10智能指针">10、智能指针</h2>
<p>在C++中，动态内存管理是用一对运算符（<code>new</code>和<code>delete</code>）完成的。但是动态管理经常出现两种问题：一是忘记释放内存，会造成内存泄漏；另一是在尚有指针引用内存的情况下就释放了它，会导致产生引用非法内存的指针。因此引入了智能指针的概念。 <strong>智能指针负责自动释放所指向的对象，可以更安全的使用动态内存。</strong> C++中存在三种类型的智能指针，分别为<code>shared_ptr</code>、<code>weak_ptr</code>以及<code>unique_ptr</code>。</p>
<p>在创建智能指针时，必须提供额外的信息即指针可以指向的类型如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>;
shared_ptr<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> ptr;
</code></pre></div><h3 id="1shared_ptr">（1）<strong>shared_ptr</strong></h3>
<p>其实就是对资源做引用计数——当引用计数为0时自动释放资源。可以使用<code>ptr.use_count()</code>来获取当前的引用数。也可以实现对数组的引用，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[]<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">13</span>]);  <span style="color:#75715e">// 引用计数为1
</span><span style="color:#75715e"></span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[]<span style="color:#f92672">&gt;</span> prt1 <span style="color:#f92672">=</span> ptr;  <span style="color:#75715e">// 引用计数为2，ptr1和ptr共享资源
</span><span style="color:#75715e"></span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ptr3 <span style="color:#f92672">=</span> make_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>);  <span style="color:#75715e">// 这种做法较为高效。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i) {
	ptr[i] <span style="color:#f92672">=</span> i;
}
</code></pre></div><p>智能指针在初始化时还可以指定删除器，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DeleteIntPtr</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p) {
	<span style="color:#66d9ef">delete</span> p;
	p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
}
std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>), DeleteIntPtr);
</code></pre></div><p><strong>实现原理：</strong></p>
<p>一个<code>shared_ptr</code>对象的内存开销要比裸指针和无自定义<code>deleter</code>的<code>unique_ptr</code>对象略大。</p>
<p><code>shared_ptr</code>需要 <strong>维护的信息</strong> 有两部分：</p>
<ul>
<li>指向共享资源的指针</li>
<li>引用计数等共享资源的控制信息——实际上是维护一个指向控制信息的指针</li>
</ul>
<p>当我们实现一个shared_ptr时，其实现一般如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>;
std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> T);
</code></pre></div><p><figure 
	>
	<a href="https://pic.imgdb.cn/item/62106cd42ab3f51d9128008b.png" >
		<img src="https://pic.imgdb.cn/item/62106cd42ab3f51d9128008b.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>在使用<code>shared_ptr</code>时，要注意的时要避免 <strong>循环引用</strong> ，循环引用会导致内存泄漏，经典的循环引用如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> bptr;
	<span style="color:#f92672">~</span>A() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;A is deleted&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> {
	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> aptr;
	<span style="color:#f92672">~</span>B() {
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;B is deleted&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
}
<span style="color:#66d9ef">void</span> TestPtr {
	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> ap(<span style="color:#66d9ef">new</span> A);
	std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span> bp(<span style="color:#66d9ef">new</span> B);
	ap<span style="color:#f92672">-&gt;</span>bptr <span style="color:#f92672">=</span> bp;
	bp<span style="color:#f92672">-&gt;</span>aptr <span style="color:#f92672">=</span> ap;
}
</code></pre></div><p>这样两个指针最后都不会被删除，循环引用导致<code>ap</code>和<code>bp</code>的引用计数为2，在离开作用域之后两者的引用计数都为1，因此两个指针都不会被析构。</p>
<h3 id="2weak_ptr">（2）weak_ptr</h3>
<p>弱引用指针<code>weak_ptr</code>是用来监视<code>shared_ptr</code>的，不会使引用计数加1，因此可以通过<code>weak_ptr</code>来解决循环引用的问题。（如可以B类的<code>shared_ptr</code>成员改为<code>weak_ptr</code>成员）它不管理shared_ptr内部的指针，主要使为了监视<code>shared_ptr</code>的生命周期，不能操作资源。使用方法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sp(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">10</span>));
weak_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> wp(sp);
</code></pre></div><p>同时weak_ptr还有一些特殊的方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sp(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">20</span>));
weak_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> wp(sp);

wp.expired()  <span style="color:#75715e">// 判断所观测的资源是否已经被释放
</span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> spt <span style="color:#f92672">=</span> wp.lock()  <span style="color:#75715e">// 获取所监视的shared_ptr
</span></code></pre></div><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/62109c352ab3f51d915791d8.jpg" >
		<img src="https://pic.imgdb.cn/item/62109c352ab3f51d915791d8.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="3unique_ptr">（3）unique_ptr</h3>
<p>unique_ptr是一个独占型的智能指针，它不允许其它的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。但是可以通过函数返回给其它的unique_ptr，这样它本身就不再拥有原来指针的所有权了。如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">unique_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> T);
unique_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Otherptr <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(ptr);
</code></pre></div><h2 id="11函数指针和指针函数">11、函数指针和指针函数</h2>
<h3 id="1指针函数">（1）指针函数</h3>
<p>简单来说，就是一个返回指针的函数，本质是一个函数。声明格式为<code>*类型标识符 函数名(参数)</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>;
A<span style="color:#f92672">*</span> <span style="color:#a6e22e">fun</span>(params...);
</code></pre></div><h3 id="2函数指针">（2）函数指针</h3>
<p>本质是一个指针变量，该指针指向这个函数。声明格式为<code>类型标识符 (*函数名)()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>;
A (<span style="color:#f92672">*</span>fun)(params...);
</code></pre></div><p>函数指针需要把一个函数的地址赋值给它，具体示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
	<span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y;
}
<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>fun)(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y);
fun <span style="color:#f92672">=</span> add;
fun <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>add;  <span style="color:#75715e">// 两种写法都行
</span></code></pre></div><p><em>可以不用取址符是因为函数名就代表函数的地址</em></p>
<h2 id="12操作系统专题">12、操作系统专题</h2>
<h3 id="121-操作系统特性">12.1 操作系统特性</h3>
<ul>
<li><strong>并发：</strong> 同一段时间内多个程序执行</li>
<li><strong>共享：</strong> 系统中的资源可以被内存中多个并发执行的线程共同使用</li>
<li><strong>虚拟：</strong> 通过时分复用以及空分复用（如虚拟内存），把一个物理实体虚拟为多个</li>
<li><strong>异步：</strong> 系统中的进程以走走停停的方式执行的，且以一种不可预知的速度推进</li>
</ul>
<h3 id="122-动态链接库与静态链接库">12.2 动态链接库与静态链接库</h3>
<ul>
<li>静态链接库一般为<code>.lib</code>文件，在项目界面直接加入工程，程序编译时，将文件中的代码加入到程序中，不能手动移除此文件的代码。</li>
<li>动态链接库一般为<code>.dll</code>文件，是程序运行时动态装入内存模块，程序运行时可以随意加载和移除。</li>
</ul>
<h3 id="123-协程">12.3 协程</h3>
<p>协程是一种比 <strong>线程更加轻量级</strong> 的存在，正如一个进程可以拥有多个线程一样， <strong>一个线程也可以拥有多个协程</strong> 。协程 <strong>不被操作系统内核管理</strong> ，完全由程序所控制，运行在 <strong>用户态</strong> 。协程不是进程也不是线程，而 <strong>是一个特殊的函数</strong> ，这个函数可以在某个地方挂起，并且可以重新在挂起处外运行。</p>
<h2 id="13常见的设计模式">13、常见的设计模式</h2>
<h3 id="131-工厂模式">13.1 工厂模式</h3>
<h4 id="1简单工厂">（1）简单工厂</h4>
<p>简单工厂包含以下角色</p>
<ul>
<li>Factory：工厂角色，负责实现创建所有实例的内部逻辑</li>
<li>Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li>
<li>ConcreteProduct：具体产品角色，是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li>
</ul>
<p>如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e04a02ab3f51d91973b30.jpg" >
		<img src="https://pic.imgdb.cn/item/621e04a02ab3f51d91973b30.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h4 id="2工厂方法">（2）工厂方法</h4>
<p>工厂方法模式包含以下结构</p>
<ul>
<li>Product：抽象产品</li>
<li>ConcreteProduct：具体产品</li>
<li>Factory：抽象工厂</li>
<li>ConcreteFactory：具体工厂</li>
</ul>
<p>如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e06822ab3f51d919abd2b.png" >
		<img src="https://pic.imgdb.cn/item/621e06822ab3f51d919abd2b.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="132-单例模式">13.2 单例模式</h3>
<p><strong>只对外提供<code>getInstance</code>方法，不提供任何构造函数</strong> ，适用于 <strong>全局统一</strong> 如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e06c42ab3f51d919b3ce2.png" >
		<img src="https://pic.imgdb.cn/item/621e06c42ab3f51d919b3ce2.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="133-装饰模式">13.3 装饰模式</h3>
<p><strong>适合需要（通过配置，如：diamond）来动态增减对象功能的场景</strong> 。装饰模式包含以下角色：</p>
<ul>
<li>Component：抽象构件</li>
<li>ConcreteComponent：具体构件</li>
<li>Decorator：抽象装饰类</li>
<li>ConcreteDecorator：具体装饰类</li>
</ul>
<p>如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e082f2ab3f51d919de278.jpg" >
		<img src="https://pic.imgdb.cn/item/621e082f2ab3f51d919de278.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p><strong>注意</strong></p>
<ul>
<li>一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。</li>
<li>尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。</li>
</ul>
<h3 id="134-策略模式">13.4 策略模式</h3>
<p>适用于一个系统需要动态地在几种可替换算法中选择一种。不希望使用者关心算法细节，将具体算法封装进策略类中。包含以下几个角色：</p>
<ul>
<li>Context：环境类</li>
<li>Strategy：抽象策略类</li>
<li>ConcreteStrategy：具体策略类</li>
</ul>
<p>如图：</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e0a372ab3f51d91a19da2.jpg" >
		<img src="https://pic.imgdb.cn/item/621e0a372ab3f51d91a19da2.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="135-代理模式">13.5 代理模式</h3>
<p>包括远程代理，虚拟代理等多种代理。</p>
<ul>
<li>虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
</ul>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e19ae2ab3f51d91b9855c.jpg" >
		<img src="https://pic.imgdb.cn/item/621e19ae2ab3f51d91b9855c.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h3 id="136-观察者模式">13.6 观察者模式</h3>
<p>适用于一对多的的业务场景，一个对象发生变更，会触发N个对象做相应处理的场景。例如：订单调度通知，任务状态变化等。包含以下角色：</p>
<ul>
<li>Subject：目标</li>
<li>ConcreteSubject：具体目标</li>
<li>Observer：观察者</li>
<li>ConcreteObserver：具体观察者</li>
</ul>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621e1a2f2ab3f51d91b9f6a0.jpg" >
		<img src="https://pic.imgdb.cn/item/621e1a2f2ab3f51d91b9f6a0.jpg"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%98%A5%E6%8B%9B/">春招</a>
        
    </section>


    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/">
        
        

        <div class="article-details">
            <h2 class="article-title">应用层协议——HTTP</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">LeetCode 二叉搜索树与双向链表</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/">
        
        

        <div class="article-details">
            <h2 class="article-title">LeetCode 矩阵中的路径</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2022 墨纹
    </section>
    
    <section class="powerby">
        
            你要相信流星划过会带给我们幸运，就像现实告诉你我要心存感激 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#1重载隐藏重写覆盖三者的区别">1、重载、隐藏、重写（覆盖）三者的区别</a>
      <ul>
        <li><a href="#三者更为深入的一些问题">三者更为深入的一些问题</a></li>
      </ul>
    </li>
    <li><a href="#2new和malloc的区别">2、new和malloc的区别</a></li>
    <li><a href="#3虚函数">3、虚函数</a>
      <ul>
        <li><a href="#31虚函数指针">3.1、虚函数指针</a></li>
        <li><a href="#32ab两个类类中有虚函数c继承ab有几张虚函数表">3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？</a></li>
        <li><a href="#33虚构函数可以是虚函数吗">3.3、虚构函数可以是虚函数吗？</a></li>
      </ul>
    </li>
    <li><a href="#4什么是多态机制">4、什么是多态机制</a>
      <ul>
        <li><a href="#深入">深入</a></li>
      </ul>
    </li>
    <li><a href="#5指针和引用的区别">5、指针和引用的区别</a></li>
    <li><a href="#6static关键字">6、static关键字</a>
      <ul>
        <li><a href="#面向过程的static">面向过程的static</a></li>
        <li><a href="#面向对象的static">面向对象的static</a></li>
      </ul>
    </li>
    <li><a href="#7const关键字">7、const关键字</a>
      <ul>
        <li><a href="#常量指针">常量指针</a></li>
        <li><a href="#指针常量">指针常量</a></li>
      </ul>
    </li>
    <li><a href="#8stl专题">8、STL专题</a>
      <ul>
        <li><a href="#1vector">（1）、vector</a></li>
        <li><a href="#2list">（2）、list</a></li>
        <li><a href="#3deque">（3）、deque</a></li>
        <li><a href="#4setmapmultisetmultimap">（4）、set、map、multiset、multimap</a></li>
        <li><a href="#5unordered_mapunordered_set">（5）、unordered_map、unordered_set</a></li>
      </ul>
    </li>
    <li><a href="#9c内存分区">9、C++内存分区</a></li>
    <li><a href="#10智能指针">10、智能指针</a>
      <ul>
        <li><a href="#1shared_ptr">（1）<strong>shared_ptr</strong></a></li>
        <li><a href="#2weak_ptr">（2）weak_ptr</a></li>
        <li><a href="#3unique_ptr">（3）unique_ptr</a></li>
      </ul>
    </li>
    <li><a href="#11函数指针和指针函数">11、函数指针和指针函数</a>
      <ul>
        <li><a href="#1指针函数">（1）指针函数</a></li>
        <li><a href="#2函数指针">（2）函数指针</a></li>
      </ul>
    </li>
    <li><a href="#12操作系统专题">12、操作系统专题</a>
      <ul>
        <li><a href="#121-操作系统特性">12.1 操作系统特性</a></li>
        <li><a href="#122-动态链接库与静态链接库">12.2 动态链接库与静态链接库</a></li>
        <li><a href="#123-协程">12.3 协程</a></li>
      </ul>
    </li>
    <li><a href="#13常见的设计模式">13、常见的设计模式</a>
      <ul>
        <li><a href="#131-工厂模式">13.1 工厂模式</a></li>
        <li><a href="#132-单例模式">13.2 单例模式</a></li>
        <li><a href="#133-装饰模式">13.3 装饰模式</a></li>
        <li><a href="#134-策略模式">13.4 策略模式</a></li>
        <li><a href="#135-代理模式">13.5 代理模式</a></li>
        <li><a href="#136-观察者模式">13.6 观察者模式</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
                
                
                <a class="go-top" id="go-top" href="#top">
                    <img src="/img/top3_hu2d68ddee36f4745c9b8a323729022ab3_7941_35x0_resize_box_3.png" />
                </a>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<div class="btn-scroll-top">
    <i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>


    </body>
</html>
