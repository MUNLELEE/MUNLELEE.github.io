<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。
socket socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。
 
因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。
对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式
 流：基于TCP协议，因此有序，可靠。可以实现可靠传输。 数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。  C/S模式 在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。
服务器工作流程 1、创建服务器socket 在这个阶段我们可以使用socket函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为AF_INET，即表示利用IPv4进行通信。这个函数的返回值为 文件描述符 （类型为整型），当失败时则会返回-1如下
int listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0) 2、将服务器用于通信的地址和端口绑定到socket上 在Linux中，地址信息被封装在了结构体sockaddr中，如下
struct sockaddr { sa_family_t sin_family; //地址族 	char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息 }; 想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体sockaddr_in，这个结构体如下
struct sockaddr_in { sa_family_t sin_family; uint16_t sin_port; // 端口号 	struct in_addr sin_addr; // IP地址 	char sin_zero; } 但如果你进入到Linux的底层代码会发现，sockaddr_in还有一个参数为sockaddr的构造函数。因此使用这个结构体可以让操作更简单，如下
struct sockaddr_in servaddr; memset(&amp;amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 指定为任意IP地址 servaddr.'><title>Linux下的socket网络通信</title>

<link rel='canonical' href='https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/'>

<link rel="stylesheet" href="/scss/style.min.36d617335b89745195c2d170d40e8c72216d9b8d13e2f80ba988a10f8c83b6ea.css"><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script>
    
    $(window).scroll(function() {
    if ($(this).scrollTop()) {
        $('#go-top').fadeIn();
    } else {
        $('#go-top').fadeOut();
    }
    });

    
    $('#go-top').click(function() {
    $('html, body').animate({scrollTop: 0}, 1000);
    return false;
    });
</script>
<meta property='og:title' content='Linux下的socket网络通信'>
<meta property='og:description' content='想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。
socket socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。
 
因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。
对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式
 流：基于TCP协议，因此有序，可靠。可以实现可靠传输。 数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。  C/S模式 在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。
服务器工作流程 1、创建服务器socket 在这个阶段我们可以使用socket函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为AF_INET，即表示利用IPv4进行通信。这个函数的返回值为 文件描述符 （类型为整型），当失败时则会返回-1如下
int listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0) 2、将服务器用于通信的地址和端口绑定到socket上 在Linux中，地址信息被封装在了结构体sockaddr中，如下
struct sockaddr { sa_family_t sin_family; //地址族 	char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息 }; 想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体sockaddr_in，这个结构体如下
struct sockaddr_in { sa_family_t sin_family; uint16_t sin_port; // 端口号 	struct in_addr sin_addr; // IP地址 	char sin_zero; } 但如果你进入到Linux的底层代码会发现，sockaddr_in还有一个参数为sockaddr的构造函数。因此使用这个结构体可以让操作更简单，如下
struct sockaddr_in servaddr; memset(&amp;amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 指定为任意IP地址 servaddr.'>
<meta property='og:url' content='https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/'>
<meta property='og:site_name' content='墨纹'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='计算机网络' /><meta property='article:tag' content='技术' /><meta property='article:published_time' content='2022-02-28T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2022-02-28T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="Linux下的socket网络通信">
<meta name="twitter:description" content="想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。
socket socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。
 
因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。
对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式
 流：基于TCP协议，因此有序，可靠。可以实现可靠传输。 数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。  C/S模式 在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。
服务器工作流程 1、创建服务器socket 在这个阶段我们可以使用socket函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为AF_INET，即表示利用IPv4进行通信。这个函数的返回值为 文件描述符 （类型为整型），当失败时则会返回-1如下
int listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0) 2、将服务器用于通信的地址和端口绑定到socket上 在Linux中，地址信息被封装在了结构体sockaddr中，如下
struct sockaddr { sa_family_t sin_family; //地址族 	char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息 }; 想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体sockaddr_in，这个结构体如下
struct sockaddr_in { sa_family_t sin_family; uint16_t sin_port; // 端口号 	struct in_addr sin_addr; // IP地址 	char sin_zero; } 但如果你进入到Linux的底层代码会发现，sockaddr_in还有一个参数为sockaddr的构造函数。因此使用这个结构体可以让操作更简单，如下
struct sockaddr_in servaddr; memset(&amp;amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 指定为任意IP地址 servaddr."><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" /><style>
    :root {
        --article-font-family: "Noto Serif SC", var(--base-font-family);
    }
</style>

<script> 
		(function () {
		    const customFont = document.createElement('link');
		    customFont.href = "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@300;700&display=swap"; 
		    customFont.type = "text/css";
		    customFont.rel = "stylesheet";
		
		    document.head.appendChild(customFont);
		}());
</script>
<style>
	h1 {
		letter-spacing: 6px;
	}
</style>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%AE%9E%E8%B7%B5/" >
                实践
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/socket%E7%BC%96%E7%A8%8B/">Linux下的socket网络通信</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 28, 2022</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。</p>
<h2 id="socket">socket</h2>
<p>socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621c69da2ab3f51d912afc07.png" >
		<img src="https://pic.imgdb.cn/item/621c69da2ab3f51d912afc07.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。</p>
<p>对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式</p>
<ul>
<li>流：基于TCP协议，因此有序，可靠。可以实现可靠传输。</li>
<li>数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。</li>
</ul>
<h2 id="cs模式">C/S模式</h2>
<p>在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。</p>
<h3 id="服务器工作流程">服务器工作流程</h3>
<h4 id="1创建服务器socket">1、创建服务器socket</h4>
<p>在这个阶段我们可以使用<code>socket</code>函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为<code>AF_INET</code>，即表示利用IPv4进行通信。这个函数的返回值为 <strong>文件描述符</strong> （类型为整型），当失败时则会返回<code>-1</code>如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> listenfd;
listenfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>)
</code></pre></div><h4 id="2将服务器用于通信的地址和端口绑定到socket上">2、将服务器用于通信的地址和端口绑定到socket上</h4>
<p>在Linux中，地址信息被封装在了结构体<code>sockaddr</code>中，如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span> {  
	sa_family_t sin_family;  <span style="color:#75715e">//地址族
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> sa_data[<span style="color:#ae81ff">14</span>];  <span style="color:#75715e">//14字节，包含套接字中的目标地址和端口信息               
</span><span style="color:#75715e"></span>};
</code></pre></div><p>想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体<code>sockaddr_in</code>，这个结构体如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> {
	sa_family_t sin_family;  
	<span style="color:#66d9ef">uint16_t</span> sin_port;  <span style="color:#75715e">// 端口号
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">in_addr</span> sin_addr;  <span style="color:#75715e">// IP地址
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">char</span> sin_zero;
}
</code></pre></div><p>但如果你进入到Linux的底层代码会发现，<code>sockaddr_in</code>还有一个参数为<code>sockaddr</code>的构造函数。因此使用这个结构体可以让操作更简单，如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> servaddr;
memset(<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(servaddr));
servaddr.sin_family <span style="color:#f92672">=</span> AF_INET;
servaddr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);  <span style="color:#75715e">// 指定为任意IP地址
</span><span style="color:#75715e"></span>servaddr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));  <span style="color:#75715e">// 将主机字节顺序转换为网络字节顺序
</span></code></pre></div><p>之后将端口绑定。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">bind(listenfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#66d9ef">sizeof</span>(servaddr);
</code></pre></div><h4 id="3将socket设置为监听模式">3、将socket设置为监听模式</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">listen(listenfd, <span style="color:#ae81ff">5</span>);  <span style="color:#75715e">// 5表示准备接受5个连接
</span></code></pre></div><h4 id="4等待并接受客户端连接">4、等待并接受客户端连接</h4>
<p>使用<code>accept</code>函数来连接客户端</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> clientfd;
clientfd <span style="color:#f92672">=</span> accept(listenfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clientaddr, (socklen_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>socklen);
</code></pre></div><p><strong>这里需要解释的是，服务器端其实建立了两个socket，第一个socket为被动的socket用来监听，当经过监听阶段后，Linux内核拥有accept函数借助监听的socket创建出连接客户端的socket</strong></p>
<h4 id="5与客户端通信接受客户端发送的信息并返回响应">5、与客户端通信，接受客户端发送的信息，并返回响应</h4>
<p>通过<code>recv</code>和<code>send</code>函数进行通信</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">while</span> (true) {
    <span style="color:#66d9ef">int</span> iret;
    memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
    <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> recv(clientfd, buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
    	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;iret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> iret <span style="color:#f92672">&lt;&lt;</span> endl;
    	<span style="color:#66d9ef">break</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;receive &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
    strcpy(buffer, <span style="color:#e6db74">&#34;ACCEPT&#34;</span>);
    <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> send(clientfd, buffer, strlen(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
    	perror(<span style="color:#e6db74">&#34;send&#34;</span>);
    	<span style="color:#66d9ef">break</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;SEND: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="6重复5中操作直到客户端断开连接">6、重复（5）中操作，直到客户端断开连接</h4>
<h4 id="7释放socket连接">7、释放socket连接</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">close(listenfd);
close(clientfd);  <span style="color:#75715e">// 释放监听socket和连接socket
</span></code></pre></div><h4 id="代码">代码</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;netdb.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Using server port&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Example: ./server 5005&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> listenfd;
    <span style="color:#66d9ef">if</span> ((listenfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        perror(<span style="color:#e6db74">&#34;socket&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> servaddr;
    memset(<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(servaddr));
    servaddr.sin_family <span style="color:#f92672">=</span> AF_INET;
    servaddr.sin_addr.s_addr <span style="color:#f92672">=</span> htonl(INADDR_ANY);
    <span style="color:#75715e">//servaddr.sin_addr.s_addr = inet_addr(&#34;192.168.190.134&#34;);  // 手动指定IP地址
</span><span style="color:#75715e"></span>    servaddr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">1</span>]));
    <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (bind(listenfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#66d9ef">sizeof</span>(servaddr)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;bind&#34;</span>);
        close(listenfd);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">if</span> (listen(listenfd, <span style="color:#ae81ff">5</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;listen&#34;</span>);
        close(listenfd);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> clientfd;
    <span style="color:#66d9ef">int</span> socklen <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span>);
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> clientaddr;
    clientfd <span style="color:#f92672">=</span> accept(listenfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>clientaddr, (socklen_t<span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>socklen);
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;clinet has connected&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;IP is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> inet_ntoa(clientaddr.sin_addr) <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#75715e">// 5
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">1024</span>];
    <span style="color:#66d9ef">while</span> (true) {
        <span style="color:#66d9ef">int</span> iret;
        memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
        <span style="color:#75715e">// 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> recv(clientfd, buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;iret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> iret <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">break</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;receive &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
        strcpy(buffer, <span style="color:#e6db74">&#34;ACCEPT&#34;</span>);
        <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> send(clientfd, buffer, strlen(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            perror(<span style="color:#e6db74">&#34;send&#34;</span>);
            <span style="color:#66d9ef">break</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;SEND: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    close(listenfd);
    close(clientfd);
}
</code></pre></div><h3 id="客户端工作流程">客户端工作流程</h3>
<h4 id="1创建客户端socket">1、创建客户端socket</h4>
<p>同样采用<code>socket</code>函数创建套接字，用来主动连接，与服务器的创建方式一样。</p>
<h4 id="2向服务器发起连接请求">2、向服务器发起连接请求</h4>
<p>使用<code>gethostbyname</code>函数将IP地址转换为<code>hostent</code>结构体所表示的格式。<code>hostent</code>结构体如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hostent</span>  {  
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>h_name;         <span style="color:#75715e">//正式主机名  
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>h_aliases;     <span style="color:#75715e">//主机别名  
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> h_addrtype;       <span style="color:#75715e">//主机IP地址类型：IPV4-AF_INET  
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> h_length;         <span style="color:#75715e">//主机IP地址字节长度，对于IPv4是四字节，即32位  
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>h_addr_list;   <span style="color:#75715e">//主机的IP地址列表  
</span><span style="color:#75715e"></span>};
</code></pre></div><p>建立连接的过程如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> sockfd;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> servaddr;
memset(<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(servaddr));
servaddr.sin_family <span style="color:#f92672">=</span> AF_INET;  <span style="color:#75715e">// 手动指定相关参数
</span><span style="color:#75715e"></span>servaddr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">2</span>]));
memcpy(<span style="color:#f92672">&amp;</span>servaddr.sin_addr, hostcon<span style="color:#f92672">-&gt;</span>h_addr, hostcon<span style="color:#f92672">-&gt;</span>h_length);
connect(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#66d9ef">sizeof</span>(servaddr)  <span style="color:#75715e">// 连接
</span></code></pre></div><h4 id="3与服务器通信将消息通过socket发送给服务器每发送一个消息等待回复">3、与服务器通信，将消息通过socket发送给服务器，每发送一个消息等待回复</h4>
<p>同样使用<code>recv</code>和<code>send</code>函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">1024</span>];
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) {
    <span style="color:#66d9ef">int</span> iret;
    memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
    sprintf(buffer, <span style="color:#e6db74">&#34;this is %d data&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> send(sockfd, buffer, strlen(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;send&#34;</span>);
        <span style="color:#66d9ef">break</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;send: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
    memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
    <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> recv(sockfd, buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;iret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> iret <span style="color:#f92672">&lt;&lt;</span> endl;
        <span style="color:#66d9ef">break</span>;
    }
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;receive &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h4 id="4重复操作3直至数据发送完毕">4、重复操作（3），直至数据发送完毕</h4>
<h4 id="5释放socket">5、释放socket</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">close(sockfd);
</code></pre></div><h4 id="代码-1">代码</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;netdb.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdlib&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;arpa/inet.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">3</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Using client port&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Example: ./client 127.0.0.1 5005&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl; 
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sockfd;
    <span style="color:#66d9ef">if</span> ((sockfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
        perror(<span style="color:#e6db74">&#34;socket&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hostent</span><span style="color:#f92672">*</span> hostcon;
    <span style="color:#66d9ef">if</span> ((hostcon <span style="color:#f92672">=</span> gethostbyname(argv[<span style="color:#ae81ff">1</span>])) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;gethostbyname failed&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
        close(sockfd);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> servaddr;
    memset(<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(servaddr));
    servaddr.sin_family <span style="color:#f92672">=</span> AF_INET;
    servaddr.sin_port <span style="color:#f92672">=</span> htons(atoi(argv[<span style="color:#ae81ff">2</span>]));
    memcpy(<span style="color:#f92672">&amp;</span>servaddr.sin_addr, hostcon<span style="color:#f92672">-&gt;</span>h_addr, hostcon<span style="color:#f92672">-&gt;</span>h_length);
    <span style="color:#75715e">// 3    
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (connect(sockfd, (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>servaddr, <span style="color:#66d9ef">sizeof</span>(servaddr)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
        perror(<span style="color:#e6db74">&#34;connect&#34;</span>);
        close(sockfd);
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buffer[<span style="color:#ae81ff">1024</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#f92672">++</span>i) {
        <span style="color:#66d9ef">int</span> iret;
        memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
        sprintf(buffer, <span style="color:#e6db74">&#34;this is %d data&#34;</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> send(sockfd, buffer, strlen(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            perror(<span style="color:#e6db74">&#34;send&#34;</span>);
            <span style="color:#66d9ef">break</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;send: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
        memset(buffer, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(buffer));
        <span style="color:#66d9ef">if</span> ((iret <span style="color:#f92672">=</span> recv(sockfd, buffer, <span style="color:#66d9ef">sizeof</span>(buffer), <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;iret = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> iret <span style="color:#f92672">&lt;&lt;</span> endl;
            <span style="color:#66d9ef">break</span>;
        }
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;receive &#34;</span> <span style="color:#f92672">&lt;&lt;</span> buffer <span style="color:#f92672">&lt;&lt;</span> endl;
    }
    <span style="color:#75715e">// 5
</span><span style="color:#75715e"></span>    close(sockfd);
}
</code></pre></div><h2 id="运行结果">运行结果</h2>
<p>在工程目录中打开两个终端，在编译后通过命令<code>./server 5005</code>启动服务器，之后在另一个终端通过命令<code>./client 127.0.0.1 5005</code>运行客户端，最终结果呈现如下。</p>
<p><figure 
	>
	<a href="https://pic.imgdb.cn/item/621cca3c2ab3f51d91db196d.png" >
		<img src="https://pic.imgdb.cn/item/621cca3c2ab3f51d91db196d.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<h2 id="参考">参考</h2>
<p>[1] <a class="link" href="https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html"  target="_blank" rel="noopener"
    >网络通信基础socket</a></p>
<p>[2] <a class="link" href="https://blog.csdn.net/dosthing/article/details/80383817"  target="_blank" rel="noopener"
    >hostent实例讲解</a></p>
<p>[3] <a class="link" href="https://blog.csdn.net/will130/article/details/53326740"  target="_blank" rel="noopener"
    >sockaddr和sockaddr_in详解</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
        
            <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
        
    </section>


    </footer>


    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%80/">
        
        

        <div class="article-details">
            <h2 class="article-title">Flask实现Web应用（一）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/">
        
        

        <div class="article-details">
            <h2 class="article-title">Hugo博客 | stack主题修改第一站</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2022 墨纹
    </section>
    
    <section class="powerby">
        
            你要相信流星划过会带给我们幸运，就像现实告诉你我要心存感激 <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#socket">socket</a></li>
    <li><a href="#cs模式">C/S模式</a>
      <ul>
        <li><a href="#服务器工作流程">服务器工作流程</a></li>
        <li><a href="#客户端工作流程">客户端工作流程</a></li>
      </ul>
    </li>
    <li><a href="#运行结果">运行结果</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
                </div>
                
                
                <a class="go-top" id="go-top" href="#top">
                    <img src="/img/top3_hu2d68ddee36f4745c9b8a323729022ab3_7941_35x0_resize_box_3.png" />
                </a>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>
<div class="btn-scroll-top">
    <i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>


    </body>
</html>
