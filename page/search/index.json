[{"content":"题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如: 给定的树 A:\n 3\r/ \\\r4 5\r/ \\\r1 2\r给定的树 B：\n 4\r/\r1\r返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n解题想法 树的题目是真的让人头疼。在经过几次暴力解的尝试之后我还是放弃了，最后几组数据总是通过不了。还是去翻了题解，发现又是我最烦的递归（永远的痛）\n1、首先子结构要么是其本身要么在树的左子树或者右子树里，因此在isSubStructure函数中需要判断是本身匹配还是左子树或者是右子树匹配，这是最外层递归。最外层递归中，如果B树（也就是子结构树）为空，那么直接返回false，同理如果A树（要从这棵树中寻找子结构）为空也可以直接返回false 2、对于子结构是否匹配的判断也需要通过递归实现（也就是isContain函数），但具有以下几种情况，其中包含退出递归的条件 （a）、如果当前的B树为空，且At树（也就是从A树种截取出的子树）非空或者空，此时表明B树是A树的一个子结构，因为可以将B树匹配完。 （b）、如果当前的B树非空，但At树为空，说明此时已经遍历过了A树的叶节点，那么B树一定与At树不匹配，可以直接返回false （c）、如果此时At树和B树都不为空，且当前匹配中的结点的值不相等，那么B树一定与At树不匹配，可以直接返回false （d）、如果At树和B树都不为空，且当前匹配中的结点的值相等，那么就继续匹配两棵树当前结点的左结点和右结点（也就是内层的递归）\n代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isContain(TreeNode *A, TreeNode *B) { // 递归判断是否包含  // 如果此时B为空树，说明已经递归完了B树，因此是包含的  if (B == NULL) return true; // 如果大树为空，匹配树不是空，那么说明不包含  if (A == NULL) return false; // 如果当前匹配的结点值不相等，那么也是不包含  if (A-\u0026gt;val != B-\u0026gt;val) return false; // 如果以上条件都不满足就继续判断子树  return isContain(A-\u0026gt;left, B-\u0026gt;left) \u0026amp;\u0026amp; isContain(A-\u0026gt;right, B-\u0026gt;right); } bool isSubStructure(TreeNode* A, TreeNode* B) { // B树为空，则为false  if (B == NULL) return false; // A树为空，也为false  if (A == NULL) return false; return isContain(A, B) || isSubStructure(A-\u0026gt;left, B) || isSubStructure(A-\u0026gt;right, B); } }; ","date":"2022-01-21T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","title":"leetcode 树的子结构"},{"content":"题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n 3\r/ \\\r9 20\r/ \\\r15 7\r返回其层次遍历结果：\n[\r[3],\r[9,20],\r[15,7]\r]\r解题想法  这道题本身并不是什么难题，也很明显可以看出是一个层序遍历的变种，解决问题的关键就在于如何区分当前层和下一层，最开始是打算使用pair将每个结点与其相应的层序号对应起来。但在实际写代码时发现有点困难，最后还是去翻了题解，发现了利用空指针作为层与层之间分隔的方法。具体做法就是在第一次入队时再入队一个空指针，之后利用队头元素不为空指针作为内循环的判断，如果队头为空，则表明了已经循环完了一层。而由于二叉树的特点，在使用层序遍历时，遍历完一层也即代表着下一层的非空结点已经完全入队，这时便可以再入队一个空指针作为下一个分隔结点。利用这样的循环就能做到以层为序来打印层序遍历。\n代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que; // 用于层序遍历  que.push(root); que.push(NULL); // 利用空指针作为每层之间的分隔  while (que.size()) { vector\u0026lt;int\u0026gt; vtemp; // 队列不为空时，就申请空间存储本层数据  while (que.front()) { // 用这个条件判断是否属于同一层数据  TreeNode *temp = que.front(); vtemp.push_back(temp-\u0026gt;val); que.pop(); if (temp-\u0026gt;left) que.push(temp-\u0026gt;left); if (temp-\u0026gt;right) que.push(temp-\u0026gt;right); } // 退出上面的循环表示已经到了层与层之间的界线  que.pop(); if (que.size()) { // 如果此时队列非空，则表明不是最后一层  // 遍历过一层即表示队列中已经保存了下一层，因此需要加入空指针分割  que.push(NULL); } res.push_back(vtemp); } return res; } }; ","date":"2022-01-20T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","title":"leetcode 从上到下打印链表"},{"content":" 如题的这两部动漫都是我认为接近于国漫巅峰的动漫，当然我并没有看过多少国漫，因此这一判断也是相当主观的。但确实的是其在我内心中是“前无古人”的。这两部动漫也是将我这一早已不看动漫的人又带回了国创动漫。\n动漫情节叙述  由于两部动漫都只做到了第一季，虽能体现一定的设定及世界观，但是很多剧情依旧是在迷雾之中的。这里也就只能讲讲已有的剧情。\n 《灵笼》的设定之前也是有过，但是灵笼剧情的饱满程度让末日题材的这种设定能够更好的展现出来。开篇便是猎荒者（即在末日中探索旧世界的可利用的东西，为幸存下来的人服务）在探索一篇废墟，并遭遇了噬极兽（因为这种怪兽因而认为地上是无法生存的）。当猎荒者凯旋归来时，之后便迎来了另一个比较重要的情节，也就是城主的更替。当然这里要先说说这个城主的问题，现在的人们生活在一个叫做“灯塔”的建筑上，而现任成主的儿子则是在灯塔上成立了一个类似于教会的“光影会”。这里就权且称这位会长为“黄毛”。城主更希望由猎荒者队长马克来接任下一任城主，但是心胸狭隘的黄毛却利用一些手段导致马克成为了噬极兽并因此被流放。（这里其实省略了很多的情节，但我觉得第一季的主要目的应该就是仅仅为了引出世界观以及《灵笼》整个庞大故事的开端）。最后第一季也是在马克与在地面上的人类相遇而结束。（这么讲其实还是草率了，如果有时间我还是希望能够去看《灵笼》的剧情）。\n 反观《时光代理人》却是以一个较为新颖的角度作为设定，也即时间。（具体便是主角团能够以自己的特殊能力进入照片，而在照片里的一言一行都有可能对未来造成影响）。时光照相馆是主角团的“基地”，也是通过这个照相馆接取委托人的任务从而帮助委托人实现一些过去或希望从过去得到线索的事情。由于这部动漫是通过一个个的小故事，因此在这里也不好叙述，依旧是推荐能够去观看动漫本身。\n谈动漫本身  很明显两部动漫都具有自己的特点，但是我却依旧将他们放在一起谈，是因为它们给我带来足够的震撼，纵使在这之前亦有《百妖谱》等，却没能给我带来那种共鸣与一种仿佛自己置身于其中希望改变世界的情感。\n 先谈《灵笼》，灵笼首先在建模方面就足够优秀，虽然采用了我不是很喜欢的建模方式，但是却依旧能够吸引我（对于我这种比较叼的人来说，这个方面就已经足够碾压国产大部分动漫了）不仅如此，人物的表情以及动作都十分逼真，其实到这里就已经可以体现制作者的用心了。当然这只是建模这个我比较关注的方面。接下来应该是剧情方面，《灵笼》的设定是动漫中比较不常见的，本以为这样的题材并不能够很好的把握，但事实是艺画开天以一种更为庞大的世界观来描述这个末日世界，这是在之前的各种影视剧中没有出现的。不仅如此，涉及的领域也十分广泛，大部分动漫可能在主题上会展现的只会是比较重要的一部分，例如青春或者爱情、友情等等。但《灵笼》光第一季就像是想要把自己的所有元素都展现出来，其中的光影会代表着类似教会一般的人，没有什么实质性的作用却控制着一部分人的思想，而会长也借助这些力量来实现自己的目标，甚至几乎摧毁了猎荒者这一强大的对抗力量。这如果影射到现实，便是思想、武装与权力之间的关系。除了这个，人性的描述也十分到位，通过对尘民4068的刻画，既展现了末日阶级统治的一种希望成为更高阶级的渴望，也让观众因为这位尘民的所作所为更加拥有共鸣。最终也会更投入到作品本身。\n 当然，一部好的的作品我觉得感情线应该是必不可少的。在《灵笼》中，并没有婚恋的自由，甚至拥有“三大法则”制约每一个人的情感。所谓的“爱情”更像是统治阶级给予的枷锁，而作为猎荒者队长的马克，本应遵守这些规则，却仍然在第一季的最后体会到了什么是爱，并为自己所爱的人大闹灯塔。虽然并没有成功的将灯塔上的人的思想扭转过来，但也为作品之后奠定了一个基调。第一季的最后则是利用地上的生存的人来表明这仅仅是《灵笼》这个庞大世界观的开始。还有一个吸引我的点是，在第一季末的一个全季最精彩的打斗场面中，背景音乐采用了纯唢呐，这种打破常规的做法也是取得了一个意想不到的效果，导致了各种二创都不及原版。\n 再看《时光代理人》，这动漫则是一开始便就从一个故事入手，直入主题，直接为观众呈现了这部作品在之后的表现方式。最开始我以为这只会是一种加强版的泡面番，通过一个个的故事来组成一部动漫，但渐渐的我发现我错了，在短短十几集的动漫中，却在最后的几集给你中给你串连起之前的故事。瞬间让你觉得这不是一个个故事那么简单。这也反应了作品中一直在重复的一句话“无论过去，不问将来”。故事也不是那种偏离现实的故事，而是充满人情味，让你觉得这都是可能发生在你身边的故事。其中的一个描述汶川地震的故事，借用了亲情和爱情令人动容。每个故事又都在恰到好处的地方停了下来。（因此我建议如果要看，就干脆一次性看完）\n 通过这整个主角团在第一季遭遇的整个故事，很精确的展现了主角团三人的性格特点，沉稳缜密的陆光，正义但却有点冲动的程小时，以及开朗能够带动气氛的乔苓。让人多多少少有点羡慕这样的三人组。第一季的最后程小时为了挽救自己之前在照片里所做过的一些错事，却发现最后仍旧没能改变，这也引出了这部动漫的反派（不止有人能够像他们那样穿越时空回到过去）。也因为这个反派最终主角团三人全部都遭到了不同程度的不幸。第一季也是在这样的一种紧张的气氛中结束了。\n给我的感受  看完这两部动漫已经很久了，但是仍然给我一种意犹未尽的感觉，最为明显的情感就是让我觉得在中国，在动漫的国创领域，仍然有这一批热爱动漫，能够写出好故事，能够通过讲好故事带给我们不一样的感受，带给我们动漫魅力的这样一群人。国创的在建模和画风上也在寻求创新以及更适合年轻人观感的改变。故事也具有较为厚重的情感，不像以前的日漫虽有情感，却给我一种较为单薄站不住脚的感觉（当然也不能否认有情感浓重的日漫）。《灵笼》带来的是宏大的世界观和巨大的创作空间。《时光代理人》带来的则是新颖的设定和令人出乎意料的编剧创作。两部动漫都以自己独特的一部分吸引着观众，也引起了在B站的极大热度。当然期待越高，不可避免的便是可能会带来失望。高开低走的动漫已经不少，我只希望拥有这么好的创作背景和创作团队，这两部动漫能够好好的珍惜，能够用尽心思来为观众呈现国漫的另一番风景，至少不要让观众对这两部动漫的呼声成为空喊，也不要让推荐这两部动漫的人最后感到太大的失望。\n 在最后还是希望国创能够走出一条更加新奇的道路，也希望这两部动漫都能够继续自己第一季的辉煌。\n 我喜欢的《时光代理人》画风 \n","date":"2022-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/","title":"观《时光代理人》、《灵笼》所感"},{"content":"本来是不想用这篇博文作为新博客的第一篇的，但无奈修改这个主题以便让我能够看得舒服确实花费了我很多精力，因此想写下这一篇博文来记录这一历程，当然这次的修改也只是建博客时对于我来说最难以忍受的痛点，如果在使用的时候觉得还有值得修改的地方，那说不定就有第二站。不废话，直接开冲！\nTO-DO · 修改文章的字体为思源宋体（其实我喜欢行楷，但苦于还没有找到解决方法。。）\n· 修改站点图标\n· 修改站点名称并使其居中，同时具有一定的间隔。\n· 修改选中的样式\n· 站点头像居中（虽然本来应该就是居中了。。）\n· 添加主页按钮点击不会高亮的问题\n· 主页样式的修改\n· 修改左边栏头像大小\n· 返回顶部功能的添加\n· 修改Toc的样式\n· 修改分类的标签样式\n修改全站的字体 其实修改字体的方案主题的原作者已经给出，有需要的可以参考修改字体，作为一个中国人，好康的中文永远比好康的英文重要。 具体做法是在站点根目录中的layouts/partials/head/custom.html中添加如下代码：\n\u0026lt;style\u0026gt; :root { --article-font-family: \u0026#34;Noto Serif SC\u0026#34;, var(--base-font-family); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // 正文自重300，标题字重700 \t(function () { const customFont = document.createElement(\u0026#39;link\u0026#39;); customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700\u0026amp;display=swap\u0026#34;; customFont.type = \u0026#34;text/css\u0026#34;; customFont.rel = \u0026#34;stylesheet\u0026#34;; document.head.appendChild(customFont); }()); \u0026lt;/script\u0026gt; 以上是作者给出的，我只是在字重上做了修改。除此之外我还修改了hugo-theme-stack/assets/scss/variable.scss文件，具体就是调整了--zh-font-family和--base-font-family的顺序，代码如下：\n--zh-font-family: \u0026#34;Noto Serif SC\u0026#34;, \u0026#34;Hiragino Sans GB\u0026#34;, \u0026#34;Droid Sans Fallback\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --base-font-family: \u0026#34;Noto Serif SC\u0026#34;, var(--sys-font-family), var(--zh-font-family), sans-serif; 修改站点的图标 这个问题起先困扰了我很久（虽然期间可能已经修改好了，但因为网站cookie的原因导致修改没有及时显示），具体做法如下，先将你需要的图片转换为.ico文件（其它类型的图片文件应该也行），如需转换可以借助这个网站。之后将转换后的文件保存在网站根目录的static文件夹中。之后修改主题的配置文件config.yaml。\nparams: mainSections: - post featuredImageField: image rssFullContent: true favicon: favicon.ico 修改站点名称 站点名称对大家来说应该不是什么难事，这里就说说居中以及间隔。这里需要修改主题根目录的assets/scss/partials/siderbar.scss文件。如下：\n.site-name { color: var(--accent-color); margin: 0; font-size: 1.8rem; text-align: center; // 站点名称文本居中  @includerespond(2xl) { font-size: 2rem; } } .site-description { color: var(--body-text-color); font-weight: normal; margin: 10px 0; font-size: 1.2rem; text-align: center; // 站点描述居中  @includerespond(2xl) { font-size: 1.6rem; } } 当然如果站点名称之间具有一定的间隔的话，应该是会更美观一点的。方法是在layouts/partials/head/custom.html文件上加入以下代码\n\u0026lt;style\u0026gt; h1 { letter-spacing: 6px; } \u0026lt;/style\u0026gt; 这个代码将会对全站的h1标题进行修改，因此业也会导致其它h1标签也发生改变，但目前只注意到进入一个分类页面时，分类的字距变大了，因此我们需要将\n修改选中的样式 原来作者的选中样式和当前的大多数网站是一样的，给我一种十年前互联网的感觉，于是喜欢深色系的我修改了选中样式。需要在assets/scss/custom.scss文件中加入如下代码：\n::selection { color: #fff; background: #557697; } 站点头像居中 这个可能只是心理作用。。 同样是在assets/scss/partials/siderbar.scss文件中加入修改以下代码\n.site-avatar { position: relative; margin-left: auto; // 站点头像居中  margin-right: auto; // 站点头像居中  width: var(--sidebar-avatar-size); height: var(--sidebar-avatar-size); margin-bottom: var(--sidebar-element-separation); } 主页按钮高亮问题 这个虽然不算是什么大问题吧，但是主页不高亮我就觉得很难受。。于是就找到了layouts/partials/sidebar/left.html这个文件。我们可以看到一下代码：\n{{ $currentPage := . }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .)($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} 这段代码大概的逻辑就是如果当前的页面是菜单中的页面之一就设定为激活状态，而如果要让主页高亮的话需要加入以下代码：\n{{ $siteTitle := .Site.Title }} {{ $active := or ($active) (and (eq $currentPage.Title $siteTitle) (eq .Identifier \u0026#34;home\u0026#34;)) }} 这样就会使若当前的网站的标题等于网站名称就会令其为激活状态，而之后的Identifier则是为了区分主页页面，否则就会出现点击主页所有页面都是高亮的情况。\n主页样式的修改 第一次看到这个主题时就对它的主页布局感到不舒服，尤其是在笔记本电脑上挤满了整个屏幕令人难受，于是希望左右两边能够有一定的留白，这样可以美观一些。\n从开发者工具中我们可以得知主页的class是container，经过查找可以知道其样式是在assets/scss/grid.css中定义的。于是可以发现如下这段代码\n.container { margin-left: auto; margin-right: auto; .left-sidebar { max-width: var(--left-sidebar-max-width); margin-right: 1%; } .right-sidebar { max-width: var(--right-sidebar-max-width); /// Display right sidebar when min-width: lg  @includerespond(lg) { display: block; } } \u0026amp;.extended { @includerespond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } @includerespond(lg) { max-width: 1280px; --left-sidebar-max-width: 20%; --right-sidebar-max-width: 30%; } @includerespond(xl) { max-width: 1536px; --left-sidebar-max-width: 15%; --right-sidebar-max-width: 25%; } } } 这段代码对左边栏和右边栏进行了最大宽度的限制，这也就是我们要修改的地方。但是这其中的各个@include函数又代表什么呢？我们可以观察asset/scss/breakpoints.scss这个文件，如下：\n$breakpoints: ( sm: 640px, md: 768px, lg: 1024px, xl: 1280px, 2xl: 1536px, ); @mixinrespond($breakpoint) { @if not map-has-key($breakpoints, $breakpoint) { @warn \u0026#34;\u0026#39;#{$breakpoint}\u0026#39; is not a valid breakpoint\u0026#34;; } @else { @media (min-width: map-get($breakpoints, $breakpoint)) { @content; } } } 没有学过css的我也就只能大致看出这是封装了各种屏幕尺寸类似于map，而在笔记本电脑上，屏幕宽度是1024px以上的，因此我们只需要修改@include respond(lg)函数下的样式就可以了。在asset/scss/custom.scss下添加如下代码：\n.container { margin-left: auto; margin-right: auto; \u0026amp;.extended { /* range: 768-1024 */ @includerespond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } /* range: 1024-1280 */ @includerespond(lg) { // 修改主页的三个组件的显示比例  max-width: 1280px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 22%; } } \u0026amp;.compact { @includerespond(md) { --left-sidebar-max-width: 25%; max-width: 768px; } @includerespond(lg) { max-width: 1024px; --left-sidebar-max-width: 20%; } @includerespond(xl) { max-width: 1280px; } } } 至此，主页的修改也告一段落了。以上都是从这位大佬那里学来。\n修改左侧边栏头像的大小 左侧边栏的元素太多，显得实在有点挤，于是索性修改了一下博客的头像大小。需要在主题根目录下的assets/scss/partials/sidebar.scss文件。\n@includerespond(2xl) { --sidebar-avatar-size: 125px; // 修改头像大小的代码 --sidebar-element-separation: 10px; } 返回顶部按钮的添加 在参考过其它使用这个主题的博主之后发现，如果一篇文章太长，没有返回顶部这个按钮可能会在某些情况下造成体验的不舒适，于是决定加上这个功能。最开始是希望能够在一个页面的右下角添加这个按钮，但是无法解决页面缩放时显示位置与主页面之间的关系的问题，因此决定借助目录放置于目录的下方。\n首先是按钮的函数，参考了slim主题，具体是在layouts/partials/head/script.html中加入如下代码：\n\u0026lt;script src=\u0026#34;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // Check to see if the window is top if not then display button  $(window).scroll(function() { if ($(this).scrollTop()) { $(\u0026#39;#back-to-top\u0026#39;).fadeIn(); } else { $(\u0026#39;#back-to-top\u0026#39;).fadeOut(); } }); // Click event to scroll to top  $(\u0026#39;#back-to-top\u0026#39;).click(function() { $(\u0026#39;html, body\u0026#39;).animate({scrollTop: 0}, 1000); return false; }); \u0026lt;/script\u0026gt; 这段代码可以监听窗口抖动，从而控制按钮的显示和隐藏。\n然后是添加返回顶部的按钮，由于这个按钮需要和文章目录保持一个相对固定的位置，因此需要修改layouts/_default/single.html，在aside标签下加入如下代码：\n{{ $topImg := resources.Get (\u0026#34;img/top.png\u0026#34;) }} {{ $topImg := $topImg.Resize \u0026#34;40x\u0026#34; }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $topImg.RelPermalink }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; 利用一张图片作为返回顶部的链接。最后我们需要通过css来为这个按钮添加样式。首先我们需要找到之前提过的custom.scss文件，在文件中加入如下代码：\n#go-top { bottom: -15px; right: 2px; display: none; position: absolute; border: 0; \u0026amp;:hover { filter: opacity(60%); // 悬停淡化  } 其中bottom值是我觉得可以避免当目录过长时会几乎占满整个屏幕，导致按钮没有地方放的问题。\n修改Toc样式 由于Toc每个标题之间的行间距有点大，于是就缩了缩，在custom.scss文件中又追加了如下的修改：\n.widget--toc { background-color: var(--card-background); border-radius: var(--card-border-radius); display: flex; flex-direction: column; color: var(--card-text-color-main); overflow: hidden; // display:inline-block;  font-size: 16px; #TableOfContents { overflow-x: auto; ol, ul { margin: 10; padding: 0; } ol { list-style-type: none; counter-reset: item; li:before { counter-increment: item; content: counters(item, \u0026#34;.\u0026#34;) \u0026#34;. \u0026#34;; font-weight: bold; margin-right: 0px; } } \u0026amp; \u0026gt; ul { padding: 0 1em; } li { margin: 5px 20px; padding: 6px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 6px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 修改分类标签样式 这个stack主题属实是有点迷，一样的主题推送到GitHub居然能产生不同的效果，无奈的我只能又去修改原先又大又丑的分类标签，根据我个人的喜好，将标签修改为小巧一点，放弃了原来的图片修饰，相关的代码写于custom.scss文件中：\n.subsection-list { margin-bottom: var(--section-separation); overflow-x: auto; .article-list--tile { display: flex; padding-bottom: 15px; article { width: 200px; // 修改分类的标签大小  height: 50px; margin-right: 5px; flex-shrink: 0; // box-shadow: var(--shadow-l2);  .article-title { margin: 0; font-size: 1.5rem; text-align: center; // 保证字居中美观一点  } .article-details { padding: 20px; justify-content: center; } } } } 修改相关文章图标 样式 在第一次推送到GitHub之后发现，相关文章的推荐标签有点与当前屏幕不相符，于是决定将相关文章的标签的大小调整到与分类的大小差不多大，于是我们依旧在custom.scss文件中追加修改样式的代码：\n.related-contents--wrapper { .related-contents { article { width: 200px; height: 85px; .article-title { font-size: 1.6rem; } } } } ","date":"2022-01-15T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/","title":"Hugo博客 | stack主题修改第一站"},{"content":"题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n示例  \n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\r输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\r解题 题目的意思很简单，就是返回一个一模一样的链表头结点。由于随机指针的存在，链表的复制不能够像正常链表那样直接遍历，也因此没想明白要怎么做，最后翻了题解，才发现又是我最烦的递归。\n这道题采用的递归解法其实本质就是遇到问题再解决问题，在还没有开始复制之前，所有的复制结点都是虚无的，要让这些结点和已知的结点一一对应起来就需要一个map数据结构。用来对应新旧两个链表的结点。这样从第一个结点入手，当这个结点不在map中时，就立刻创建这个结点并于原链表中的相应结点建立对应关系。之后的每一个结点都可以根据这样的逻辑进行创建，而因为有map这个数据结构的存在，这样每个结点都不是虚空存在的，而是可以在map中找到与之对应的结点。可以解决随机结点创建的问题。具体代码如下：\nclass Solution { public: unordered_map\u0026lt;Node*, Node*\u0026gt; um; // 用来存储两个链表，结点之间一一对应  Node* copyRandomList(Node* head) { if (head == NULL) { // 如果链表本就为空，那么直接返回空  return NULL; } // 遵循边遍历边创建的原则  if (!um.count(head)) { // 如果此时哈希表中没有这个结点，就直接创建  Node* headNew = new Node(head-\u0026gt;val); // 初始化一个相同的结点  um.insert(make_pair(head, headNew)); // 将这两个位置一样的结点对应起来  headNew-\u0026gt;next = copyRandomList(head-\u0026gt;next); // 同理下一个结点也应该这样拷贝，依旧遵循上面的原则  headNew-\u0026gt;random = copyRandomList(head-\u0026gt;random); } // 如果这个结点已经在哈希表中存在，那么就直接返回  return um[head]; } }; ","date":"2022-01-10T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","title":"leetcode 复杂链表的复制"},{"content":"题目描述 给定一个链表，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n示例  在这里插入图片描述 \n输入：head = [3,2,0,-4], pos = 1\r输出：true\r解释：链表中有一个环，其尾部连接到第二个节点。\r 在这里插入图片描述 \n输入：head = [1,2], pos = 0\r输出：true\r解释：链表中有一个环，其尾部连接到第一个节点。\r 在这里插入图片描述 \n输入：head = [1], pos = -1\r输出：false\r解释：链表中没有环。\r提示 链表中节点的数目范围是 [0, 104]\r-105 \u0026lt;= Node.val \u0026lt;= 105\rpos 为 -1 或者链表中的一个 有效索引 。\r解题想法 这道题在leetcode上属于简单题，但由于第一次遇见这种解法（也由于第一次想错了，根本不是正解）所以就想记录一下。 很明显题目要判断链表中是否有环，于是可以想到如果在链表中有两个指针分别向前跑，当两个指针指向的结点相同的时候便证明链表中有环存在。这个时候就需要一个循环来判断两个指针是否相等。此时条件应该是first != second因此如果我们初始化两个指针在同一个位置，那么将无法进入循环，因此需要将两个指针分别初始化在头结点以及头结点的下一个结点，还要注意的是，first指针的速度应该要快于second指针的速度，这样，当链表中有环时，first指针会先进入环中，并一直在环中循环，而当second指针进入环时，由于first指针速度快，将会在某个循环时刻追上second指针，这样当两个指针重合后就能够判断出链表存在环，下面附上C++代码\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { if (head == nullptr || head-\u0026gt;next == nullptr) { return false; } ListNode *first = head-\u0026gt;next; ListNode *second = head; while (first != second) { if (first == nullptr || first-\u0026gt;next == nullptr) { return false; } second = second-\u0026gt;next; first = first-\u0026gt;next-\u0026gt;next; } return true; } }; ","date":"2021-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","title":"leetcode 141 环形链表"},{"content":"题目描述 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。\n如果没有和至少为 K 的非空子数组，返回 -1\n示例 输入：A = [1], K = 1\r输出：1\r输入：A = [1,2], K = 4\r输出：-1\r输入：A = [2,-1,2], K = 3\r输出：3\r提示 1. 1 \u0026lt;= A.length \u0026lt;= 50000\r2. -10 ^ 5 \u0026lt;= A[i] \u0026lt;= 10 ^ 5\r3. 1 \u0026lt;= K \u0026lt;= 10 ^ 9\r首先对于我这样一个不怎么有基础的人来说，这道题着实是令我作呕。。解题也是通过了其它题解的启发。下面就开始吧。\n解题想法 由于题目中已经明确表示了数组的长度为50000，因此如果要使用暴力接法，势必造成O(n^2)的时间复杂度。因此就要想办法让i， j两个循环变量只跑一遍。而对于这道题因为绕不开要求取数组中的区间和。所以可以采用的一个方法是前缀和思想。大致的意思就是sum[i] = array[0] + array[1] + \u0026hellip; + array[i - 1]利用这个前缀和数组就可以较为方便的得到一个数组的区间和，例如要知道区间[1, 3]的和，我们可以利用前缀和数组得到sum[4] - sum[1]（这里需要注意的是，为了便于计算前缀和数组的第零个元素默认为零）\n解决了前缀和之后就要解决更加关键的问题，如何能够得到最短长度的和最小序列。首先我们不妨先这么想，如果我们当前的索引为i， 此时若区间[0, i]的和比区间[0, i - 1]的和要小，那么就不需要再考虑i - 1这个位置的索引了（因为这个时候有sum[A.length] - sum[i] \u0026gt; sum[A.length] - sum[i - 1] 且前者的区间长度要小于后者）而这个时候就要原先的存储的i - 1这个索引弹出，再将更优的i索引加入。这个时候可以利用队列这样的数据结构来保存。有了这个存删的机制就可以保证每次能够得到的长度都是最短且和最大的。之后就是获得长度的问题了。如果这个队列中还有元素的话，就从当前遍历到的索引i的前缀和减去队列头部保存的索引，即（sum[i] - sum[queue.front()]）这个条件需要满足题目中给出的K。由此可以看出这个队列需要两端都能出，因此我们需要维护一个单调递增的双端队列。下面附上C++代码\nclass Solution { public: int shortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; vec, int threshold) { int len = vec.size(); int minLength = 5e4 + 11; deque\u0026lt;int\u0026gt; dque; vector\u0026lt;int\u0026gt; sum(len + 1, 0); // 初始化前缀和数组  for (int i = 1; i \u0026lt;= len; ++i) { sum[i] = sum[i - 1] + vec[i - 1]; } for (int i = 0; i \u0026lt; len + 1; ++i) { if (i != 0) { // 满足性质就将队列尾部的索引给删除不再考虑  while (dque.size() \u0026amp;\u0026amp; sum[dque.back()] \u0026gt;= sum[i]) { dque.pop_back(); } // 从队列头部开始寻找满足条件的最短区间  // 如果不满足条件就要将队列头部元素删除  while (dque.size() \u0026amp;\u0026amp; sum[i] - sum[dque.front()] \u0026gt;= threshold) { minLength = min(minLength, i - dque.front()); dque.pop_front(); } } dque.push_back(i); } return minLength == 5e4 + 11 ? -1 : minLength; } }; ","date":"2021-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"leetcode 862 和至少为K的最短子数组"}]