[{"content":"书接上回，这篇博文主要是要讲一讲前端页面以及相应的css的变化，虽然是一个简单的web应用，但是在一定程度上还是需要符合人的审美。\n基础页面 由于我需要实现两个功能，调用本地麦克风录制和上传录音文件，最开始我是想把这两个功能放在同一个页面，但是最后觉得为了美观和页面逻辑，我就决定设计一个主页面，包含了这两个功能的可选项，之后再通过选择重定向至另一个页面。\n因此在基础页面中就有了如下的HTML代码\n\u0026lt;body style=\u0026#34;background-size: 100%; background-image:url({{ url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;cool-background.png\u0026#39;) }})\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;items\u0026#34;\u0026gt; \u0026lt;p\u0026gt;选择语音识别方式\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;choose_btn1\u0026#34; value=\u0026#34;上传文件\u0026#34; class=\u0026#34;choose_btn\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;choose_btn2\u0026#34; value=\u0026#34;麦克风录音\u0026#34; class=\u0026#34;choose_btn\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 当然一个网页好看的背景是不可缺少的，在这里可以给各位有前端需求的朋友推荐一个网站炫酷背景，这个网站可以在线生成一些简单的可以用作网页背景的图片并提供免费下载。\n当你使用Flask框架并打算引用外部文件时，你只能将文件放在static文件夹下，并采用url_for函数来作为引用的链接。\n按钮链接 可以看见在这个基础页面中有两个按钮，通过这两个按钮的点击重定向至其他页面。这时候需要用到jQuery来判断被点击的是哪个按钮（最开始想用JS实现，但是发现略微麻烦）。\n我们可以通过attr来获取相应HTML标签的属性值，通过属性值实现判断和重定向。判断条件满足时使用window.location.href将url导向至其他页面。并将这个函数绑定到按钮的点击事件上。\nwindow.onload = function () { $(\u0026#34;.choose_btn\u0026#34;).click(function () { const text = $(this).attr(\u0026#34;value\u0026#34;); if (text === \u0026#34;上传文件\u0026#34;) { window.location.href = \u0026#39;upload\u0026#39;; } else { window.location.href = \u0026#39;microphone\u0026#39;; } }); } 通过上面的JS，当点击某个按钮，浏览器的url将会改变，因此我们需要将将相应的url在Flask后端进行渲染。\n@app.route(\u0026#39;/upload\u0026#39;) def upload(): return render_template(\u0026#39;upload.html\u0026#39;) @app.route(\u0026#39;/microphone\u0026#39;) def microphone(): return render_template(\u0026#39;microphone.html\u0026#39;) 背景CSS样式 段落字体 这一块其实没什么好说的，就是将网站的默认字体修改了一下，设置了字体间距和文字居中\np { color: white; font-family: \u0026#34;Microsoft YaHei UI Light\u0026#34;; font-size: 20px; letter-spacing: 3px; /*文字间间距*/ text-align: center; /* 居中 */ } 卡片样式 我希望能够将两个功能的选择放在一个卡片上，这样不会显得一个页面上的元素过少，只有两个按钮元素毕竟难以撑起整个页面。同时修改了卡片的样式。\n 通过background: rgba(0, 0, 0, .5)修改卡片的背景 利用属性border-radius来改变卡片四周的角 利用box-shadow属性来使卡片显得更立体 通过transform属性来让卡片位于居中位置  相应的CSS文件属性如下\n.items { position: absolute; top: 50%; left: 50%; width: 400px; height: 300px; padding: 40px; transform: translate(-50%, -50%); background: rgba(0, 0, 0, .5); box-sizing: border-box; box-shadow: 0 15px 25px rgba(0, 0, 0, .6); border-radius: 20px; } 卡片动画效果 通过以上的CSS打开网页时，卡片将会直接出现在页面上。这样显然是不是很美观的，在好友的帮助下实现了卡片的淡出效果。首先我们需要在CSS上设置opacity属性为透明，并设置相关的transition过渡。最后就是通过jQuery来修改网页加载后的CSS属性（之前不知到jQuery能操作CSS一直觉得没有逻辑可以实现这样的动态效果）。\n相关的CSS和JS的修改如下\n.items { position: absolute; top: 50%; left: 50%; width: 400px; height: 300px; padding: 40px; transform: translate(-50%, -50%); background: rgba(0, 0, 0, .5); box-sizing: border-box; box-shadow: 0 15px 25px rgba(0, 0, 0, .6); border-radius: 20px; opacity: 0; transition: opacity 1.5s ease-in; } window.onload = function () { $(\u0026#34;.items\u0026#34;).css(\u0026#39;opacity\u0026#39;, \u0026#39;1\u0026#39;); $(\u0026#34;.choose_btn\u0026#34;).click(function () { const text = $(this).attr(\u0026#34;value\u0026#34;); if (text === \u0026#34;上传文件\u0026#34;) { window.location.href = \u0026#39;upload\u0026#39;; } else { window.location.href = \u0026#39;microphone\u0026#39;; } }); } 当使用了以上的组合之后就会有打开网页之后卡片淡入的效果了。\n按钮悬停样式 为了能够让按钮在鼠标悬停的时候有一定的反应，就在按钮上加上一些鼠标悬停时的动态效果。\n悬停效果其实和上面的卡片动画效果异曲同工，只不过动画的最后效果采用CSS中的hover伪元素进行修改，而非采用JS进行修改。\n相关代码如下\n.item:before { content: \u0026#39;\u0026#39;; height: 4px; background-color: #BADFED; width: 100%; position: absolute; left: 0; bottom: 0; transform: scaleX(0); transition: .3s; } .item:hover:before { transform: scaleX(1); } 最后实现的效果如下：\n 选择按钮动效 \n基础页面效果  页面效果 \n","date":"2022-04-10T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%BA%8C/","title":"Flask实现Web应用（二）"},{"content":"K近邻算法 K近邻是一种有监督学习算法。因为没有对数据进行训练，而是通过新数据与旧数据的比较得到相应的结果。因此是一种隐式的学习过程和训练过程。K近邻算法可以用来解决分类问题，也可以用来解决回归问题。\n步骤 对未知类别的属性的数据集中的每个点依次执行以下操作：\n 计算已知类别数据集中点与当前点之间的距离 按照距离递增次序排序 选取与当前点距离最小的k个点 确定前k个点所在的类别出现的频率 返回前k个点出现频率最高的类别作为当前点的预测分类  在确定样本和当前点的距离时，通常采用的是欧式距离公式$$d=\\sqrt{(x_1-x_0)+(y_1-y_0)}$$ 当公式中的指数变化时，随之也会得到相应的不同的距离公式。\n如下图所示的例子中\n \n1、当采用实线的圆作为k近邻的范围，也就是$k=3$时，此时与绿点距离更近的三个点中，三角形出现的频率更大，因此将绿点归为三角形一类\n2、当采用虚线的圆作为k近邻的范围，也就是$k=5$，时，此时与绿点距离更近的五个点中，正方形的频率更大，因此将绿点归为正方形一类。\n以下采用鸢尾花作为例子进行KNN测试\n代码 import numpy as np import pandas as pd from sklearn.datasets import load_iris import matplotlib.pyplot as plt iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) # print(df) df[\u0026#39;label\u0026#39;] = iris.target # print(len(df)) 150 # 绘散点图 # print(df.info()) # 显示数据类型 # 前两个特征 Colors = [] for i in range(df.shape[0]): item = df.iloc[i, -1] # 定位到标签 if item == 0: Colors.append(\u0026#39;black\u0026#39;) if item == 1: Colors.append(\u0026#39;red\u0026#39;) if item == 2: Colors.append(\u0026#39;orange\u0026#39;) plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;Simhei\u0026#39;] bgplt = plt.figure(figsize=(12, 8)) fig1 = bgplt.add_subplot(221) plt.scatter(df.iloc[:, 0], df.iloc[:, 1], marker=\u0026#39;.\u0026#39;, c=Colors) plt.xlabel(\u0026#39;sepal length\u0026#39;) plt.ylabel(\u0026#39;sepal width\u0026#39;) # 13两个特征 fig2 = bgplt.add_subplot(222) plt.scatter(df.iloc[:, 0], df.iloc[:, 2], marker=\u0026#39;.\u0026#39;, c=Colors) plt.xlabel(\u0026#39;sepal length\u0026#39;) plt.ylabel(\u0026#39;petal length\u0026#39;) # 34两个特征 fig3 = bgplt.add_subplot(223) plt.scatter(df.iloc[:, 2], df.iloc[:, 3], marker=\u0026#39;.\u0026#39;, c=Colors) plt.xlabel(\u0026#39;petal length\u0026#39;) plt.ylabel(\u0026#39;petal width\u0026#39;) plt.show() new_data = [5.7, 3.3, 6.2, 0.7] def KnnAlgorithm(data, target, k=3): tmp_list = list((((data.iloc[:150, 0:4] - target) ** 2).sum(1)) ** 0.5) dist_l = pd.DataFrame({\u0026#39;dist\u0026#39;: tmp_list, \u0026#39;label\u0026#39;: (data.iloc[:150, -1])}) # 加上标签 dist_sort = dist_l.sort_values(by=\u0026#39;dist\u0026#39;)[: k] # print(dist_sort) res = dist_sort.loc[:, \u0026#39;label\u0026#39;].value_counts() return res.index[0] print(KnnAlgorithm(df, new_data, k=4)) ","date":"2022-04-06T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/","title":"机器学习算法 | K近邻"},{"content":"在DFS这一块一直是比较弱的，因此就去看了DFS相关的一些题目，并找到了岛屿的一系列问题。\n 岛屿数量 岛屿的最大面积 最大人工岛 封闭岛屿的数目 岛屿的周长  图类DFS方法 图通常是由方格组成，通过方格中的元素来对图的DFS进行限制。岛屿问题便是其中经典的一类。在岛屿问题中，通常由$1$表示陆地，由$2$表示海洋，当每个方格都相邻时，组成的一个全$1$方格域即为一个岛屿。（这里不包含对角相邻）\nDFS框架 DFS也是一种意义上的递归，因此在一个DFS程序中首先要做的便是设定递归出口。类似于树结构可以利用指针为空等条件，在岛屿问题中，我们需要判断边界，也需要判断当前方格是否是陆地。因此在递归出口设置中就需要两个条件进行限制。\n之后DFS就要考虑下一步搜索与前一轮搜索之间的区别。岛屿问题中最主要的区别便是遍历方格的四个邻格，其余的区别便需要依题目而定。因此我们可以得到以下的岛屿类问题的DFS框架\nclass Solution { private: bool inRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != 1) return; dfs(grid, pos_x - 1, pos_y); dfs(grid, pos_x + 1, pos_y); dfs(grid, pos_x, pos_y + 1); dfs(grid, pos_x, pos_y - 1); } } 避免重复遍历 在DFS中一个重要的问题就是要避免重复遍历，不然可能会造成程序原地打转的现象。在岛屿一类的问题中，可以将已经遍历过的方块修改其元素为$0$或者为非题中给出元素。因此我们可以修改上述的DFS模板如下\nclass Solution { private: bool inRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != 1) return; grid[pos_x][pos_y] = 2; dfs(grid, pos_x - 1, pos_y); dfs(grid, pos_x + 1, pos_y); dfs(grid, pos_x, pos_y + 1); dfs(grid, pos_x, pos_y - 1); } }; 岛屿问题解法 岛屿数量问题 其实粗看题目，很容易能想到并查集能够解决这类问题，但是DFS应该较为常见的解法，这道题也是最为简单的DFS。\n我们可以这么想，当你使用DFS时，每次遍历到的都是相邻的方格，因此在一次DFS过程中，遍历过的所有陆地应该是属于同一块岛屿的，而在遍历的过程中我们应当将已走过的陆地更改为不可走。这样一来就会使之前的岛屿失效。\n那么如何寻找下一个岛屿呢？答案也就是寻找下一个在地图中尚未使用过的$1$，之后在对这个$1$进行DFS，也就可以得到另一个岛屿了。\n因此要想获得岛屿的数量，其实就是在整个地图执行DFS算法的次数。\nclass Solution { private: bool inRange(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != \u0026#39;1\u0026#39;) return; grid[pos_x][pos_y] = \u0026#39;2\u0026#39;; dfs(grid, pos_x - 1, pos_y); dfs(grid, pos_x + 1, pos_y); dfs(grid, pos_x, pos_y + 1); dfs(grid, pos_x, pos_y - 1); } public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); int res = 0; for (int i = 0; i \u0026lt; row; ++i) { for (int j = 0; j \u0026lt; col; ++j) { if (grid[i][j] == \u0026#39;1\u0026#39;) { ++res; dfs(grid, i, j); } } } return res; } }; 岛屿的最大面积 这个问题和上一个问题其实本质上没什么区别，你都需要在整个地图中去遍历出所有的岛屿，无非需要的就是在DFS的过程中，你需要统计已走过的陆地数量。当遍历完所有的岛屿之后，取这些值中的最大值即可。\n因此在这个问题中，我们只需要在每次进入DFS函数中，如果走过的是陆地，那么就对其面积（area）$+1$即可。（使用C++时，可以传递引用避免无法改变形参的问题）。\nclass Solution { private: bool inRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int pos_x, int pos_y, int\u0026amp; area) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != 1) return; ++area; grid[pos_x][pos_y] = 2; dfs(grid, pos_x - 1, pos_y, area); dfs(grid, pos_x + 1, pos_y, area); dfs(grid, pos_x, pos_y + 1, area); dfs(grid, pos_x, pos_y - 1, area); } public: int maxAreaOfIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); int res = 0; for (int i = 0; i \u0026lt; row; ++i) { for (int j = 0; j \u0026lt; col; ++j) { if (grid[i][j] == 1) { int area = 0; dfs(grid, i, j, area); res = max(res, area); } } } return res; } }; 岛屿的周长 这道题要求的是岛屿的周长，这道题最终是在题解的启发下才做出来的。\n对于一张地图，如果我们遍历到一个海洋结点（$0$），这时候表明岛屿有一条边与其相接，而当我们遍历出地图时，也表明有一条边与岛屿相接，相反，如果是陆地，则对岛屿的周长没有影响。\n所以我们只需要在DFS中分以上三种情况进行讨论，将最后的结果相加即可得到岛屿的周长。\nclass Solution { private: bool inRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } int dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return 1; if (grid[pos_x][pos_y] == 0) return 1; if (grid[pos_x][pos_y] != 1) return 0; // 说明这个方格已经是遍历过的陆地  grid[pos_x][pos_y] = 2; return dfs(grid, pos_x - 1, pos_y) + dfs(grid, pos_x + 1, pos_y) + dfs(grid, pos_x, pos_y - 1) + dfs(grid, pos_x, pos_y + 1); } public: int islandPerimeter(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int row = grid.size(); int col = grid[0].size(); int res = 0; for (int i = 0; i \u0026lt; row; ++i) { for (int j = 0; j \u0026lt; col; ++j) { if (grid[i][j] == 1) { res += dfs(grid, i, j); } } } return res; } }; 封闭岛屿的数目 这道题与求岛屿的数目有点像，稍有不同的是，当岛屿以地图边界为边时，此时这个岛屿不算是封闭的。\n因此我们可以自然的想到，利用DFS将不算封闭的边界岛屿找出来，而在这个算法执行的过程中就会将这些岛屿修改为海洋，因此剩下的岛屿就全为封闭岛屿，计算这些剩下的岛屿即可。\nclass Solution { private: constexpr static int dx[4] = {0, -1, 0, 1}; constexpr static int dy[4] = {1, 0, -1, 0}; bool inRange(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int x, int y) { if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; grid.size() \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; grid[0].size()) { return true; } return false; } void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, int pox, int poy) { if (!inRange(grid, pox, poy)) return; if (grid[pox][poy] != 0) return; grid[pox][poy] = 1; for (int i = 0; i \u0026lt; 4; ++i) { dfs(grid, pox + dx[i], poy + dy[i]); } } public: int closedIsland(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int res = 0; int row = grid.size(), col = grid[0].size(); // 优先处理边界，将边界岛屿剔除  for (int i = 0; i \u0026lt; row; ++i) { dfs(grid, i, 0); dfs(grid, i, col - 1); } for (int j = 0; j \u0026lt; col; ++j) { dfs(grid, 0, j); dfs(grid, row - 1, j); } for (int i = 0; i \u0026lt; row; ++i) { for (int j = 0; j \u0026lt; col; ++j) { if (grid[i][j] == 0) { ++res; dfs(grid, i, j); } } } return res; } }; ","date":"2022-04-02T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/","title":"岛屿问题 | DFS框架"},{"content":"为了让之后的项目能够专注于算法，于是打算先在近几日解决一定的应用层面的内容。因此也就诞生了这篇文章。\n背景 这个Web应用说来其实应该是很简单的，但是由于没有前后端开发经验，对我来说也算是一个挑战。这个应用旨在实现能够通过前端上传录音文件，通过后端的处理将文本返回给前端页面以及能够调用本地的麦克风进行录音最后通过这段录音能够返回文本内容。项目不大，也应该不会太过华丽，所以选用了Flask框架处理。\n基本文件上传表单 从客户端的角度来讲，上传文件和提交表单数据一样，因此我们需要定义一个包含文件字段的HTML表单。一个简单的HTML表单如下。这个表单可以接收一个文件。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;语音识别站点\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;录音文件上传\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; accept=\u0026#34;.wav\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里需要注意的是，\u0026lt;form\u0026gt;元素的method属性可以是get或post。使用get时，数据将在请求URL的查询字符串中提交，而使用post时，数据将进入请求主体。当一个HTML表单中包含文件时，必须使用post方法，因为我们不可能在请求URL字符串中处理提交的文件数据。采用multipart/form-data字段则是因为这个字段可以适用于提交文件。accept属性则是可以限制表单可以接受的文件类型。如上使用了.wav进行限制，当点击选择文件时，系统的资源管理器会帮你过滤类型不匹配的文件。\n使用Flask进行文件接收 对于常规表单，Flask提供了对提交表单字段的访问。其中文件字段就包含在 request.files字典中，可以通过键值 file来访问文件列表，从中得出文件名，再用save保存文件。\n@app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;post\u0026#39;]) def upload_file(): upload_file = request.files[\u0026#39;file\u0026#39;] if upload_file.filename != \u0026#34;\u0026#34;: upload_file.save(upload_file.filename) return redirect(url_for(\u0026#39;upload_file\u0026#39;)) 这样，每当提交一次文件时，就会将文件保存到你的工程目录中。如下图所示\n 文件上传效果 \n添加一些限制 文件大小限制 为了防止上传十分大的文件，我们在后端中添加对文件大小进行限制的配置。\napp.config[\u0026#39;MAX_CONTENT_LENGTH\u0026#39;] = 1024 * 1024 添加了如上的配置之后，文件大小将会被限制在1MB，超过此大小的文件将会被拒收。这样在一定程度上也可以防止客户端采用上传大文件的方式过多的占用服务器资源以及，通过大容量文件对服务器进行攻击。\n可接收文件类型限制 在前面的HTML表单中提到了accept属性，通过这个属性系统资源管理器会对文件的扩展名进行筛选。在发现了Flask框架可以对文件类型进行限制的时候我决定转到后台进行文件类型的限制。\napp.config[\u0026#39;UPLOAD_EXTENSIONS\u0026#39;] = [\u0026#39;.wav\u0026#39;] 上传路径的限制 由于之后需要使用到这个录音文件，所以我将这个录音文件保存在相应的工程路径中，便于之后的获取。据此添加了相关配置\napp.config[\u0026#39;UPLOAD_PATH\u0026#39;] = \u0026#39;uploads\u0026#39; 这样当文件上传之后，你就可以看到文件在uploads的文件夹下出现\n 文件上传路径限制 \n综合以上几点限制之后我们可以得到后端接收录音文件的完整代码如下。\n@app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;post\u0026#39;]) def upload_file(): upload_file = request.files[\u0026#39;file\u0026#39;] filename = secure_filename(upload_file.filename) if filename != \u0026#34;\u0026#34;: file_ext = os.path.splitext(filename)[1] if file_ext not in app.config[\u0026#39;UPLOAD_EXTENSIONS\u0026#39;]: abort(400) upload_file.save(os.path.join(app.config[\u0026#39;UPLOAD_PATH\u0026#39;], filename)) return redirect(url_for(\u0026#39;upload_file\u0026#39;)) 使用dropzone的css框架 当采用HTML自带的表单文件上传时，生成的页面显示的更像是一个登录的文本框，在我看来如果要提交一个文件的话这样的文本框未免太小气了，因此在查阅相关资料后，发现了dropzone这个css框架，通过这个框架可以得到一个范围较大且可拖拽上传的文本框以及一个上传动画（虽然HTML表单也可以拖拽）。\n要使用这个框架我们只需要在前端页面中添加如下的代码即可\n\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.7.1/min/dropzone.min.css\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;{{ url_for(\u0026#39;upload_file\u0026#39;) }}\u0026#34; class=\u0026#34;dropzone\u0026#34;\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/dropzone/5.7.1/min/dropzone.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 此处的action属性即是Flask后端中用来接收上传文件的处理函数。这样一个简单的录音文件上传的前后端应用就已经初具模样了。\n最后的页面效果  页面效果 \n","date":"2022-03-15T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/flask%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BA%94%E7%94%A8%E4%B8%80/","title":"Flask实现Web应用（一）"},{"content":"想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。\nsocket socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。\n \n因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。\n对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式\n 流：基于TCP协议，因此有序，可靠。可以实现可靠传输。 数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。  C/S模式 在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。\n服务器工作流程 1、创建服务器socket 在这个阶段我们可以使用socket函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为AF_INET，即表示利用IPv4进行通信。这个函数的返回值为 文件描述符 （类型为整型），当失败时则会返回-1如下\nint listenfd; listenfd = socket(AF_INET, SOCK_STREAM, 0) 2、将服务器用于通信的地址和端口绑定到socket上 在Linux中，地址信息被封装在了结构体sockaddr中，如下\nstruct sockaddr { sa_family_t sin_family; //地址族 \tchar sa_data[14]; //14字节，包含套接字中的目标地址和端口信息 }; 想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体sockaddr_in，这个结构体如下\nstruct sockaddr_in { sa_family_t sin_family; uint16_t sin_port; // 端口号 \tstruct in_addr sin_addr; // IP地址 \tchar sin_zero; } 但如果你进入到Linux的底层代码会发现，sockaddr_in还有一个参数为sockaddr的构造函数。因此使用这个结构体可以让操作更简单，如下\nstruct sockaddr_in servaddr; memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // 指定为任意IP地址 servaddr.sin_port = htons(atoi(argv[1])); // 将主机字节顺序转换为网络字节顺序 之后将端口绑定。\nbind(listenfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr); 3、将socket设置为监听模式 listen(listenfd, 5); // 5表示准备接受5个连接 4、等待并接受客户端连接 使用accept函数来连接客户端\nint clientfd; clientfd = accept(listenfd, (struct sockaddr*)\u0026amp;clientaddr, (socklen_t*)\u0026amp;socklen); 这里需要解释的是，服务器端其实建立了两个socket，第一个socket为被动的socket用来监听，当经过监听阶段后，Linux内核拥有accept函数借助监听的socket创建出连接客户端的socket\n5、与客户端通信，接受客户端发送的信息，并返回响应 通过recv和send函数进行通信\nwhile (true) { int iret; memset(buffer, 0, sizeof(buffer)); if ((iret = recv(clientfd, buffer, sizeof(buffer), 0)) \u0026lt;= 0) { cout \u0026lt;\u0026lt; \u0026#34;iret = \u0026#34; \u0026lt;\u0026lt; iret \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; \u0026#34;receive \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; strcpy(buffer, \u0026#34;ACCEPT\u0026#34;); if ((iret = send(clientfd, buffer, strlen(buffer), 0)) \u0026lt;= 0) { perror(\u0026#34;send\u0026#34;); break; } cout \u0026lt;\u0026lt; \u0026#34;SEND: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } 6、重复（5）中操作，直到客户端断开连接 7、释放socket连接 close(listenfd); close(clientfd); // 释放监听socket和连接socket 代码 #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;unistd.h\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;netdb.h\u0026gt;#include\u0026lt;sys/types.h\u0026gt;#include\u0026lt;sys/socket.h\u0026gt;#include\u0026lt;arpa/inet.h\u0026gt;using namespace std; int main(int argc, char *argv[]) { if (argc != 2) { cout \u0026lt;\u0026lt; \u0026#34;Using server port\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Example: ./server 5005\u0026#34; \u0026lt;\u0026lt; endl; return -1; } // 1  int listenfd; if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket\u0026#34;); return -1; } // 2  struct sockaddr_in servaddr; memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //servaddr.sin_addr.s_addr = inet_addr(\u0026#34;192.168.190.134\u0026#34;); // 手动指定IP地址  servaddr.sin_port = htons(atoi(argv[1])); // 3  if (bind(listenfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) != 0) { perror(\u0026#34;bind\u0026#34;); close(listenfd); return -1; } if (listen(listenfd, 5) != 0) { perror(\u0026#34;listen\u0026#34;); close(listenfd); return -1; } // 4  int clientfd; int socklen = sizeof(struct sockaddr_in); struct sockaddr_in clientaddr; clientfd = accept(listenfd, (struct sockaddr*)\u0026amp;clientaddr, (socklen_t*)\u0026amp;socklen); cout \u0026lt;\u0026lt; \u0026#34;clinet has connected\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;IP is: \u0026#34; \u0026lt;\u0026lt; inet_ntoa(clientaddr.sin_addr) \u0026lt;\u0026lt; endl; // 5  char buffer[1024]; while (true) { int iret; memset(buffer, 0, sizeof(buffer)); //  if ((iret = recv(clientfd, buffer, sizeof(buffer), 0)) \u0026lt;= 0) { cout \u0026lt;\u0026lt; \u0026#34;iret = \u0026#34; \u0026lt;\u0026lt; iret \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; \u0026#34;receive \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; strcpy(buffer, \u0026#34;ACCEPT\u0026#34;); if ((iret = send(clientfd, buffer, strlen(buffer), 0)) \u0026lt;= 0) { perror(\u0026#34;send\u0026#34;); break; } cout \u0026lt;\u0026lt; \u0026#34;SEND: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } close(listenfd); close(clientfd); } 客户端工作流程 1、创建客户端socket 同样采用socket函数创建套接字，用来主动连接，与服务器的创建方式一样。\n2、向服务器发起连接请求 使用gethostbyname函数将IP地址转换为hostent结构体所表示的格式。hostent结构体如下\nstruct hostent { char *h_name; //正式主机名  char **h_aliases; //主机别名  int h_addrtype; //主机IP地址类型：IPV4-AF_INET  int h_length; //主机IP地址字节长度，对于IPv4是四字节，即32位  char **h_addr_list; //主机的IP地址列表 }; 建立连接的过程如下\nint sockfd; struct sockaddr_in servaddr; memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; // 手动指定相关参数 servaddr.sin_port = htons(atoi(argv[2])); memcpy(\u0026amp;servaddr.sin_addr, hostcon-\u0026gt;h_addr, hostcon-\u0026gt;h_length); connect(sockfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr) // 连接 3、与服务器通信，将消息通过socket发送给服务器，每发送一个消息等待回复 同样使用recv和send函数\nchar buffer[1024]; for (int i = 0; i \u0026lt; 3; ++i) { int iret; memset(buffer, 0, sizeof(buffer)); sprintf(buffer, \u0026#34;this is %d data\u0026#34;, i + 1); if ((iret = send(sockfd, buffer, strlen(buffer), 0)) \u0026lt;= 0) { perror(\u0026#34;send\u0026#34;); break; } cout \u0026lt;\u0026lt; \u0026#34;send: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; memset(buffer, 0, sizeof(buffer)); if ((iret = recv(sockfd, buffer, sizeof(buffer), 0)) \u0026lt;= 0) { cout \u0026lt;\u0026lt; \u0026#34;iret = \u0026#34; \u0026lt;\u0026lt; iret \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; \u0026#34;receive \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } 4、重复操作（3），直至数据发送完毕 5、释放socket close(sockfd); 代码 #include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;unistd.h\u0026gt;#include\u0026lt;netdb.h\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;sys/types.h\u0026gt;#include\u0026lt;sys/socket.h\u0026gt;#include\u0026lt;arpa/inet.h\u0026gt;#include\u0026lt;iostream\u0026gt;using namespace std; int main(int argc, char *argv[]) { if (argc != 3) { cout \u0026lt;\u0026lt; \u0026#34;Using client port\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Example: ./client 127.0.0.1 5005\u0026#34; \u0026lt;\u0026lt; endl; return -1; } // 1  int sockfd; if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { perror(\u0026#34;socket\u0026#34;); return -1; } // 2  struct hostent* hostcon; if ((hostcon = gethostbyname(argv[1])) == 0) { cout \u0026lt;\u0026lt; \u0026#34;gethostbyname failed\u0026#34; \u0026lt;\u0026lt; endl; close(sockfd); return -1; } struct sockaddr_in servaddr; memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(atoi(argv[2])); memcpy(\u0026amp;servaddr.sin_addr, hostcon-\u0026gt;h_addr, hostcon-\u0026gt;h_length); // 3  if (connect(sockfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) != 0) { perror(\u0026#34;connect\u0026#34;); close(sockfd); return -1; } // 4  char buffer[1024]; for (int i = 0; i \u0026lt; 3; ++i) { int iret; memset(buffer, 0, sizeof(buffer)); sprintf(buffer, \u0026#34;this is %d data\u0026#34;, i + 1); if ((iret = send(sockfd, buffer, strlen(buffer), 0)) \u0026lt;= 0) { perror(\u0026#34;send\u0026#34;); break; } cout \u0026lt;\u0026lt; \u0026#34;send: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; memset(buffer, 0, sizeof(buffer)); if ((iret = recv(sockfd, buffer, sizeof(buffer), 0)) \u0026lt;= 0) { cout \u0026lt;\u0026lt; \u0026#34;iret = \u0026#34; \u0026lt;\u0026lt; iret \u0026lt;\u0026lt; endl; break; } cout \u0026lt;\u0026lt; \u0026#34;receive \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; endl; } // 5  close(sockfd); } 运行结果 在工程目录中打开两个终端，在编译后通过命令./server 5005启动服务器，之后在另一个终端通过命令./client 127.0.0.1 5005运行客户端，最终结果呈现如下。\n \n参考 [1] 网络通信基础socket\n[2] hostent实例讲解\n[3] sockaddr和sockaddr_in详解\n","date":"2022-02-28T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/","title":"Linux下的socket网络通信"},{"content":"HTTP协议概述 概况 Web的应用层协议是超文本传输协议（HTTP）。HTTP协议由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话。\nHTTP定义了Web页面的方式，以及服务器向客户传送Web页面的方式。并 使用TCP作为它的支撑运输协议 。HTTP客户首先发起一个与服务器的TCP链接。连接建立，彼此之间就可以通过 套接字接口 访问TCP。从而利用套接字接口接受和发送HTTP报文。通信过程如下图所示\n \n由于TCP为HTTP提供可靠数据传输服务，因此每个报文都能完整地到达服务器或客户，HTTP协议不关心TCP从网络种如何处理报文的各种问题，也不用担心数据丢失。但又由于服务器只为客户服务，并不存储任何关于客户的状态信息，因此HTTP协议是一个 无状态协议 ，如果需要保存客户的登录信息，则 需要引入相关技术来记录状态，如Cookie 。\n持续和非持续连接 在实际情况中，客户可能会发出一系列请求并且服务器会对每个请求进行响应。而这种客户-服务器的交互是经过TCP进行的，因此这些请求是经过单独的TCP连接还是经过相同的TCP连接就是这种交互方式的关键问题。也因此诞生了持续和非持续的HTTP连接。\n非持续连接： 使用非持续连接，每个TCP连接在服务器 发送一个对象后就关闭 （对象即HTML文件以及网页图像等），每个TCP连接只传输一个请求报文和一个响应报文。\n非持续连接有以下缺点：\n 必须为每个请求的对象建立和维护一个全新的连接。对于这样的连接要分配TCP缓冲区和保持TCP变量。造成服务器负担。 每个对象经受两倍的RTT交付时间，即一个RTT用于创建，一个RTT用于请求和接受.  持续连接： 服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送，而如果一条连接经过一定时间间隔（配置好的超时间隔）仍未被使用，HTTP服务器就应该关闭这个连接。\nHTTP连接流程 （1）、 客户端连接到Web服务器。 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80端口），建立一个TCP套接字连接。\n（2）、 发送HTTP请求。 通过TCP套接字，客户端向HTTP服务器发送一个文本的请求报文。\n（3）、 服务器接受请求并返回HTTP响应。 Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。\n（4）、 释放TCP连接。 若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭TCP连接并释放。反之若为keepalive，则TCP连接会保持一段时间，在这段时间内可以继续接受请求和响应。\n（5）、 客户端浏览器解析HTML内容。 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取相应的HTML，根据HTML语法对其进行格式化，并在浏览器窗口显示。\nHTTP报文 HTTP请求报文 请求报文格式如下图。其中第一行称为 请求行 ，其后继的行称为 首部行 。\n请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以区包括GET、POST、HEAD、PUT和DELETE。这些请求方法将会在下文讲述。\n首部行则会包含Host字段，Connection字段以及User-agent字段等。分别指明了对象所在的主机、是否使用持续连接以及用户代理（发送请求的浏览器类型）。其中Host首部行则是Web代理高速缓存所要求的。\n \nHTTP响应报文 响应报文的格式如下图。分为 状态行 ， 首部行 以及 实体体 三个部分。实体体为报文的主要部分，为所请求的对象本身。同样在首部行会包含一些字段。例如：Date：指示发送该报文的日期和时间；Server：指示发送的服务器；Last-Modified：最后修改的日期和时间等。\n \nHTTP状态码 由上述HTTP响应报文可以得出，在状态行中包含状态码字段，这个字段将指示请求的结果。可以将状态码分为以下几类：\n 1xx： 指示信息 ，表示请求已接收，继续处理 2xx： 成功 ，表示请求已被成功接收、理解、接受 3xx： 重定向 ，要完成请求必须进行进一步的操作 4xx： 客户端错误 ，请求有语法错误或请求无法实现 5xx： 服务器端错误 ，服务器未能实现合法请求  常见的状态码如下：\n 200 OK：请求成功，信息在返回的响应报文中。 301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL 400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。 404 Not Found：被请求的文档不在服务器上。 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。  更多的状态码及其对应短语可以参考此网址。\nHTTP请求方法 HTTP1.0定义了三种请求方法：GET、POST和HEAD。\nHTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE和CONNECT方法\n每种方法的特点如下：\n GET。 请求指定的页面信息，并返回实体主体。 HEAD。 类似于GET请求，只不过返回的响应中没有主体内容，用于获取报头。 POST。 向指定资源提交提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT。 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE。 请求服务器删除指定的页面。 CONNECT。 HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS。 允许客户端查看服务器的性能。 TRACE。 回显服务器收到的请求，主要用于测试或诊断。  GET和POST请求的区别 （1）、 GET提交： 请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用\u0026amp;连接；例如：login.action?name=hyddd\u0026amp;password=idontknow\u0026amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交： 把提交的数据放置在是HTTP包的包体中。\n也即 GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变\n（2）、传输数据的大小：首先 HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制 。\n而在实际的开发中：\nGET： 特定浏览器和服务器对URL长度有限制，例如：IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。\nPOST： 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对POST提交数据大小进行限制，Apache、IIS6都有各自的配置。\n（3）、安全性\nPOST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存；其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击\nHTTPS HTTP的不足  通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改  HTTPS介绍 HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer， 安全套接层 ）或TLS（Transport Layer Security， 安全传输协议 ）的组合使用，加密HTTP通信内容。属于通信加密，即在整个通信线路中加密。如图\n \nHTTPS采用 共享密钥加密（对称） 和 公开密钥加密（非对称） 两者并用的混合加密机制，若密钥能够实现安全交换，那么有可能仅考虑使用公开密钥来加密通信。但是公开密钥加密相对于共享密钥加密处理速度较慢。因此可以在交换密钥阶段使用 公开密钥 加密方式，之后建立通信交换报文阶段则使用 共享密钥 加密方式。\nHTTPS握手流程简单描述如下：\n \n（1）、浏览器将自己支持的一套加密规则发送给网站 （服务器获得浏览器公钥）\n（2）、网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥等信息 （浏览器获得服务器公钥）\n（3）、获得网站证书后浏览器需要进行以下操作\n（a）、验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。\n（b）、如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。\n（c）、使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。\n（4）、网站接受浏览器发来的数据之后要做以下的操作：\n（a）、使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。\n（b）、使用密码加密一段握手消息，发送给浏览器。\n","date":"2022-02-14T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/","title":"应用层协议——HTTP"},{"content":"春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。\n1、重载、隐藏、重写（覆盖）三者的区别 重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。\n隐藏：指的是派生类类型的对象、指针引用访问基类和派生类都有的同名函数时 （只要求同名，不管参数列表是否相同），访问的是派生类的函数，即隐藏了基类的同名函数。\n重写（覆盖）：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。\n此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。\n三者更为深入的一些问题 1.1 重载为什么改变参数就可以实现调用不同函数？ 因为C++在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。\n1.2 构造函数可以被重载吗？析构函数呢？ 构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。\n2、new和malloc的区别 据说是C++的经典问题，在综合了网络上的一些博文后，得出以下几点不同。\n（1）、申请内存所在区域。new操作符从自由存储区 （不仅可以是堆还可以是静态存储区） 上为对象动态分配内存，而malloc从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。\n（2）、返回类型。new操作符返回的是对象类型指针，不需要进行强制转换；malloc内存分配成功则是返回void*，需要通过强制类型转换成指定类型。\n（3）、内存分配失败时的返回值。new内存分配失败时，会抛出bad_alloc异常，不会返回NULL，malloc分配内存失败时返回NULL\n（4）、是否需要指定内存大小。 使用new操作符时进行内存分配时无需指定内存块的大小，使用malloc需要显式的指定内存的大小。\nclass A {...} A *ptr = new A; A *ptr = (A*)malloc(sizeof(A)); （5）、是否调用构造函数。 使用new操作符分配对象内存时经历如下的几个步骤：\n  ·调用operator new函数（数组是operator new[]）来分配内存空间\n  ·编译器运行相应的构造函数创建对象，并赋初值\n  ·返回指向这个对象的指针\n  使用delete操作符释放内存空间时会经历如下步骤：\n  ·调用对象的析构函数\n  ·编译器调用operator delete（operator delete[]）释放内存空间\n  使用malloc分配内存则不会调用构造函数\n（6）、对数组的处理。 C++提供了new []和delete []来专门处理数组类型，而malloc需要自己指定数组的大小\nint *ptr = (int*)malloc(sizeof(int) * 10) // 分配一个十个int大小的数组 （7）、是否能够重新分配内存。 使用malloc分配内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。new没有扩充内存的配套操作\n（8）、客户处理内存分配不足。new会有异常机制，而malloc只能返回NULL\n3、虚函数 虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成运行时决议，与传统的编译时决定有本质区别。\n虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。\n当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。\n3.1、虚函数指针 本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。 只有拥有虚函数的类才会拥有虚函数指针 ，每个虚函数也都会对应一个虚函数指针。\n3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？ 两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。\n3.3、析构函数可以是虚函数吗？ 析构函数必须是虚函数。因为如果不是虚函数，当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。\n4、什么是多态机制 面向对象的三大特征：封装，继承，多态。\n多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。运行时的多态则和虚函数、继承有关。\n深入 3.1、多态底层的实现机制 利用虚函数表，先构建一个基类，然后在基类的构造函数中会建立虚函数表，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。\n虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在.rdata只读数据段。\n3.2、父类构造函数中是否可以调用虚函数 可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。这是因为在定义子类对象的时候，会先调用父类的构造函数，而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存，C++标准规范中规定了在这种情况下，**即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。**所以使用的是静态绑定，调用了父类的函数。\n3.3、构造函数可以是虚函数吗？ 不可以，因为虚函数存在的 唯一目的就是为了多态。 而子类并不继承父类的构造函数，所以没有使父类构造函数变成虚函数的必要。另一方面，构造函数为类对象初始化了内存空间，里面保存了指向虚函数的指针，如果构造函数是虚函数，导致没有实例化对象，也就没有内存空间，更不会有虚函数。\n3.4、静态函数可以是虚函数吗？  static成员不属于任何类对象或实例，所以即使给static函数加上virtual也是没有任何意义的。 静态与非静态成员函数之间有一个主要区别。那就是静态成员函数没有this指针，所以无法访问vptr，进而不能访问虚函数表  5、指针和引用的区别 指针： 指针是一个变量，用于保存另一个变量的地址，指针需要用*来进行解引用，以获取它指向的内存地址上的内容。\n引用： 引用是一个已经存在的变量的别名，但引用也是通过存储变量的地址来实现对变量的修改的\n两者的区别：\n 引用必须定义时初始化，不能像指针一样，指针可以定义后视情况初始化 引用本身、就不能改变指向因此不存在引用常量（int \u0026amp;const r = a） 指针可以有多级，但是引用只能有一级 指针的++、--代表下一个数据，而引用的++、--则代表数据本身的修改。 sizeof(引用)得到的是所指向的变量（对象）的大小，而sizeof(指针)得到的是指针本身的大小 当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会产生一个临时变量。  6、static关键字 面向过程的static （1）、函数中的静态变量。当变量声明为static时，其空间在程序的生命周期内分配，被存放在全局数据区。即使多次调用此函数，静态变量的空间也只分配一次，前一次调用的变量值通过下一次调用传递。\n静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。\n面向对象的static （1）、类中的静态变量。声明为static的变量只能被初始化一次，而且必须初始化，且类中的静态变量由对象共享，类中的静态成员变量必须在类内声明，在类外定义（const修饰可以直接定义）。\nclass A { public: static int num; // 类内声明 \tstatic const int num_2 = 10; // const可以在声明时就初始化 } int A::num = 10; // 类外初始化 int main(void) { A a; cout \u0026lt;\u0026lt; a.num; // 输出10  cout \u0026lt;\u0026lt; A::num; // 输出10 } （2）、类中的静态成员函数。 静态成员函数不依赖于类的对象。允许使用.和类名来调用静态成员函数。静态成员函数只能访问静态成员变量或其它静态成员函数。\n此外还有以下特点\n static成员变量不占用对象的内存，而是在所有对象之外开辟内存 static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在类外初始化时分配，即没有在类外初始化的静态成员变量不能使用  7、const关键字 作用：被其修饰的值不能改变，是只读变量。必须在定义时就赋初值。\nconst关键字还可以用来修饰指针，如下：\nconst int* p; // 常量指针 int* const p; // 指针常量 常量指针 底层const，指针指向的值被指针限定住，不能通过指针改变指向的值。但此时可以修改指针的指向。\n指针常量 顶层const，指针指向的地址不能修改，并且声明时必须初始化，但是指针指向的地址的内容可以通过指针修改。\n8、STL专题 （1）、vector 可变大小的数组， 支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。\n 底层原理  底层为动态数组，包括三个迭代器，begin和end是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。\n当空间不够装下数据时，会自动申请另一片更大的空间（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的内存空间，而当释放或者删除vector里面的数据时（v.clear()），其存储空间不释放，仅仅是清空了里面的数据。\n reserve和resize的区别  reserve： 是直接扩充到已经确定的大小，可以减少开辟、释放空间的问题，提高效率。\nresize： 可以改变有效空间的大小，因此capacity的大小也会随之改变。\n size和capacity的区别  size表示当前vector中有多少个元素，而capacity函数表示它已经分配的内存中可以容纳多少元素。\n vector元素是否可以是引用  vector的底层实现要求连续的 对象排列 ， 引用并非对象 ，没有实际地址，因此元素不能是引用。\n（2）、list  底层原理  list底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间，不支持随机存取，适合需要大量的插入和删除操作的数据结构。\n一些函数操作：\nlist.unique() // 移除数值相同的连续元素 list.sort() // 对list进行排序，通常可以和上面的函数连用 （3）、deque  底层原理  deque是一个双向开口的连续性空间（双端队列），在头尾两端插入都有理想的时间复杂度。但是整个空间并不是连续的，而是一段一段的，为了维护其整体连续的假象，并提供随机存取的接口。设计了一个中控器，用来记录deque内部每一段连续空间的地址。类似于数据结构中的map。对象的key值为地址，而value则是对应的连续的地址空间。是一个动态数组，一旦需要扩容，就是在首尾配置一段定量连续空间。\n（4）、set、map、multiset、multimap  底层原理  这些容器的底层实现都是红黑树。由于采用红黑树实现，因此在插入和删除时，都需要寻找结点，因此会损失一定的效率。\n关于红黑树：\n1、每个结点是红色或者是黑色\n2、根结点是黑色的\n3、每个叶结点是黑的\n4、如果一个结点是红的，那么它的两个孩子结点都是黑色\n5、每个结点到其子孙结点的所有路径上包含相同数目的黑色结点\n 容器特点  set与multiset容器会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset中元素允许重复。\nmap与multimap容器则是以key和value组成的pair作为元素，根据key的排序准则，自动将元素排序，在map中key值不允许重复，而multimap中key值可以重复。\n（5）、unordered_map、unordered_set  底层原理  底层是一个防冗余的哈希表（采用除留余数法）。能够尽可能的降低数据的存储和查找的时间，若产生哈希冲突，一般采用拉链法来解决冲突\n 与map、set相比  查找速度比map、set快，通常为常数级别，但会消耗较多的内存，且构造速度较慢。\n9、C++内存分区 在C++中分为五大内存分区，分别是 堆 、 栈 、 自由存储区 、 全局/静态存储区 和 常量存储区\n  栈： 由编译器在 需要时分配，在 不需要时自动清除 的变量存储区。里面的变量通常是局部变量，函数参数等。\n  堆： 操作系统层面的术语，为malloc等分配的内存块，用free结束自己的生命周期。\n  自由存储区： C++层面上的术语，为new分配的内存块，它们的释放编译器不进行管理，而是由应用程序控制，一般new后需要delete，如果没有释放，操作系统会在程序结束之后回收\n因为 new 的申请是调用 malloc 的，自由存储区就和堆类似，但不等价\n  全局/静态存储区： 全局变量和静态变量被分配到同一块内存中。\n初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束之后由系统释放。\n  常量存储区： 一块特殊的存储区，存放 常量 ，这些常量不允许被修改，程序结束后由系统释放\n  10、智能指针 在C++中，动态内存管理是用一对运算符（new和delete）完成的。但是动态管理经常出现两种问题：一是忘记释放内存，会造成内存泄漏；另一是在尚有指针引用内存的情况下就释放了它，会导致产生引用非法内存的指针。因此引入了智能指针的概念。 智能指针负责自动释放所指向的对象，可以更安全的使用动态内存。 C++中存在三种类型的智能指针，分别为shared_ptr、weak_ptr以及unique_ptr。\n在创建智能指针时，必须提供额外的信息即指针可以指向的类型如：\nclass A; shared_ptr\u0026lt;A\u0026gt; ptr; （1）shared_ptr 其实就是对资源做引用计数——当引用计数为0时自动释放资源。可以使用ptr.use_count()来获取当前的引用数。也可以实现对数组的引用，如下：\nshared_ptr\u0026lt;int[]\u0026gt; ptr(new int[13]); // 引用计数为1 shared_ptr\u0026lt;int[]\u0026gt; prt1 = ptr; // 引用计数为2，ptr1和ptr共享资源 shared_ptr\u0026lt;int\u0026gt; ptr3 = make_shared\u0026lt;int\u0026gt;(10); // 这种做法较为高效。 for (int i = 0; i \u0026lt; 10; ++i) { ptr[i] = i; } 智能指针在初始化时还可以指定删除器，如下：\nvoid DeleteIntPtr(int* p) { delete p; p = nullptr; } std::shared_ptr\u0026lt;int\u0026gt; p(new int(10), DeleteIntPtr); 实现原理：\n一个shared_ptr对象的内存开销要比裸指针和无自定义deleter的unique_ptr对象略大。\nshared_ptr需要 维护的信息 有两部分：\n 指向共享资源的指针 引用计数等共享资源的控制信息——实际上是维护一个指向控制信息的指针  当我们实现一个shared_ptr时，其实现一般如下：\nclass T; std::shared_ptr\u0026lt;T\u0026gt; ptr(new T);  \n在使用shared_ptr时，要注意的时要避免 循环引用 ，循环引用会导致内存泄漏，经典的循环引用如下：\nclass A; class B; class A { std::shared_ptr\u0026lt;B\u0026gt; bptr; ~A() { cout \u0026lt;\u0026lt; \u0026#34;A is deleted\u0026#34; \u0026lt;\u0026lt; endl; } } class B { std::shared_ptr\u0026lt;A\u0026gt; aptr; ~B() { cout \u0026lt;\u0026lt; \u0026#34;B is deleted\u0026#34; \u0026lt;\u0026lt; endl; } } void TestPtr { std::shared_ptr\u0026lt;A\u0026gt; ap(new A); std::shared_ptr\u0026lt;B\u0026gt; bp(new B); ap-\u0026gt;bptr = bp; bp-\u0026gt;aptr = ap; } 这样两个指针最后都不会被删除，循环引用导致ap和bp的引用计数为2，在离开作用域之后两者的引用计数都为1，因此两个指针都不会被析构。\n（2）weak_ptr 弱引用指针weak_ptr是用来监视shared_ptr的，不会使引用计数加1，因此可以通过weak_ptr来解决循环引用的问题。（如可以B类的shared_ptr成员改为weak_ptr成员）它不管理shared_ptr内部的指针，主要使为了监视shared_ptr的生命周期，不能操作资源。使用方法如下：\nshared_ptr\u0026lt;int\u0026gt; sp(new int(10)); weak_ptr\u0026lt;int\u0026gt; wp(sp); 同时weak_ptr还有一些特殊的方法：\nshared_ptr\u0026lt;int\u0026gt; sp(new int(20)); weak_ptr\u0026lt;int\u0026gt; wp(sp); wp.expired() // 判断所观测的资源是否已经被释放 auto spt = wp.lock() // 获取所监视的shared_ptr 当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。如图：\n \n（3）unique_ptr unique_ptr是一个独占型的智能指针，它不允许其它的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。但是可以通过函数返回给其它的unique_ptr，这样它本身就不再拥有原来指针的所有权了。如下：\nunique_ptr\u0026lt;T\u0026gt; ptr(new T); unique_ptr\u0026lt;T\u0026gt; Otherptr = std::move(ptr); 11、函数指针和指针函数 （1）指针函数 简单来说，就是一个返回指针的函数，本质是一个函数。声明格式为*类型标识符 函数名(参数)\nclass A; A* fun(params...); （2）函数指针 本质是一个指针变量，该指针指向这个函数。声明格式为类型标识符 (*函数名)()\nclass A; A (*fun)(params...); 函数指针需要把一个函数的地址赋值给它，具体示例如下：\nint add(int x, int y) { return x + y; } int (*fun)(int x, int y); fun = add; fun = \u0026amp;add; // 两种写法都行 可以不用取址符是因为函数名就代表函数的地址\n12、操作系统专题 12.1 操作系统特性  并发： 同一段时间内多个程序执行 共享： 系统中的资源可以被内存中多个并发执行的线程共同使用 虚拟： 通过时分复用以及空分复用（如虚拟内存），把一个物理实体虚拟为多个 异步： 系统中的进程以走走停停的方式执行的，且以一种不可预知的速度推进  12.2 动态链接库与静态链接库  静态链接库一般为.lib文件，在项目界面直接加入工程，程序编译时，将文件中的代码加入到程序中，不能手动移除此文件的代码。 动态链接库一般为.dll文件，是程序运行时动态装入内存模块，程序运行时可以随意加载和移除。  12.3 协程 协程是一种比 线程更加轻量级 的存在，正如一个进程可以拥有多个线程一样， 一个线程也可以拥有多个协程 。协程 不被操作系统内核管理 ，完全由程序所控制，运行在 用户态 。协程不是进程也不是线程，而 是一个特殊的函数 ，这个函数可以在某个地方挂起，并且可以重新在挂起处外运行。\n13、常见的设计模式 13.1 工厂模式 （1）简单工厂 简单工厂包含以下角色\n Factory：工厂角色，负责实现创建所有实例的内部逻辑 Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色，是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。  如图：\n \n（2）工厂方法 工厂方法模式包含以下结构\n Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂  如图：\n \n13.2 单例模式 只对外提供getInstance方法，不提供任何构造函数 ，适用于 全局统一 如图：\n \n用C++实现单例模式如下\nclass Singleton { private: static Singleton* singleton; Singleton() {} Singleton(const Singleton\u0026amp; tmp) {} Singleton\u0026amp; operator=(const Singleton\u0026amp; tmp) {} public: static Singleton* getInstance() { if (singleton == nullptr) { singleton = new Singleton(); } else { return singleton; } } }; Singleton* Singleton::singleton = nullptr; 13.3 装饰模式 适合需要（通过配置，如：diamond）来动态增减对象功能的场景 。装饰模式包含以下角色：\n Component：抽象构件 ConcreteComponent：具体构件 Decorator：抽象装饰类 ConcreteDecorator：具体装饰类  如图：\n \n注意\n 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。  13.4 策略模式 适用于一个系统需要动态地在几种可替换算法中选择一种。不希望使用者关心算法细节，将具体算法封装进策略类中。包含以下几个角色：\n Context：环境类 Strategy：抽象策略类 ConcreteStrategy：具体策略类  如图：\n \n13.5 代理模式 包括远程代理，虚拟代理等多种代理。\n 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。   \n13.6 观察者模式 适用于一对多的的业务场景，一个对象发生变更，会触发N个对象做相应处理的场景。例如：订单调度通知，任务状态变化等。包含以下角色：\n Subject：目标 ConcreteSubject：具体目标 Observer：观察者 ConcreteObserver：具体观察者   \n14、C++必用初始化列表的情况 C++中类成员的初始化于初始化列表中完成，先于构造函数体执行，即成员真正的初始化发生在初始化列表中，而不是构造函数体中。所以有以下几种情况必须使用初始化列表。\n 如果类中有一个成员是引用，由于引用必须赋有初始值，因此，引用必须使用初始化列表 const修饰也需要赋有初始值，因此const成员也需要初始化列表 继承类中调用基类初始化构造函数，实际上就是先构造基类对象，必须使用初始化列表。  ","date":"2022-02-02T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"春招 | 知识点留档"},{"content":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n \n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点\n \n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n解题想法 题目给出的是一棵二叉搜索树，而要我们整理成一个升序的双向链表，可以很自然的想到二叉搜索树的中序遍历即为升序序列。面对双向链表，我们还需要建立相邻结点之间的关系，因此需要设置前驱结点pre和当前结点cur两个指针来组织结点之间的关系。（具体即为pre-\u0026gt;right = cur和cur-\u0026gt;left = pre），最后则是连接头结点和尾结点。\n中序遍历流程 令recur为中序遍历函数\n1、终止条件：当cur结点为空时，直接返回，说明此时已经越过了叶节点\n2、递归左子树，recur（cur-\u0026gt;left）\n3、构建相邻结点之间的关系\n（a）、如果pre指针为空，说明当前访问的结点为中序遍历的第一个结点，也就是双向链表的头结点，此时将当前结点cur赋值给head指针。\n（b）、如果pre指针非空，需要建立两个结点之间的关系，即pre-\u0026gt;right = cur和cur-\u0026gt;left = pre\n（c）、更新前驱结点pre，即pre = cur\n4、递归右子树，recur（cur-\u0026gt;right）\n最后在执行函数中，需要利用head和pre指针建立双向链表的头尾关系，即head-\u0026gt;left = pre，pre-\u0026gt;right = head，因为当递归完二叉搜索树时，pre会指向中序的最后一个元素。\n代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private: Node *head, *pre; void recur(Node *root) { if (root == NULL) return; recur(root-\u0026gt;left); // 如果pre为空，说明当前访问的是头结点  if (pre) pre-\u0026gt;right = root; else head = root; root-\u0026gt;left = pre; // 修改当前的结点为前驱结点  pre = root; recur(root-\u0026gt;right); } public: Node* treeToDoublyList(Node* root) { if (root == NULL) return NULL; recur(root); head-\u0026gt;left = pre; pre-\u0026gt;right = head; return head; } }; ","date":"2022-01-31T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"LeetCode 二叉搜索树与双向链表"},{"content":"题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n \n示例：\n输入：board = [[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;E\u0026quot;],[\u0026quot;S\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;S\u0026quot;],[\u0026quot;A\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;E\u0026quot;]], word = \u0026quot;ABCCED\u0026quot;\r输出：true\r输入：board = [[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;],[\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;]], word = \u0026quot;abcd\u0026quot;\r输出：false\r解题想法 这道题一开始想到的是使用BFS，但是细想发现BFS好像很难处理回溯的问题，应该采用DFS。然后，就是递归的痛了，也借这道题学习一下DFS的写法吧。\n**DFS：**即是暴力遍历矩阵的所有元素，来搜索一条可行的路径，通过递归，可以在一条路径中搜索到底，最后回溯到之前已经匹配的节点。\n**剪枝：**在DFS过程中如果当前的矩阵字符与字符串字符不等，可以直接回溯。或者路径已经访问过，可以直接跳过。\nDFS解析 1、递归终止条件：\n（a）、返回true，当匹配到字符串的最后一个字符时，可以直接返回true（至于为什么可以这样返回，参看代码注释）\n（b）、返回false，如果矩阵的索引越界，当前矩阵的字符和字符串的字符不匹配，当前元素已经访问过了直接返回false\n2、递归过程\n（a）、选定当前元素，将当前元素标记为空字符，表明当前元素已经访问过，防止走回头路。\n（b）、搜索下一个元素，向四个方向分别匹配字符，如果有一个方向可以匹配就继续递归这个方向的DFS算法，并返回true，否则返回false\n（c）、还原当前元素，需要在DFS算法退出之前，将空字符还原为原来的字符，用于回溯时重新寻找路径，否则回溯将找不到正确路径。\n代码 class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { rows = board.size(); cols = board[0].size(); for (int i = 0; i \u0026lt; rows; ++i) { for (int j = 0; j \u0026lt; cols; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; } private: int rows, cols; // k为单词索引  bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string word, int i, int j, int k) { // 如果越界或者字符不相等，就停止递归  if (i \u0026gt;= rows || i \u0026lt; 0 || j \u0026gt;= cols || j \u0026lt; 0 || board[i][j] != word[k]) return false; // 当进入这个判断条件时，会先判断是否相等，因此只要走到最后一个字符就可以返回true  if (k == word.size() - 1) return true; // 将访问过的字符设为一个特殊字符，防止走回头路  board[i][j] = \u0026#39;\\0\u0026#39;; array\u0026lt;int, 4\u0026gt; dx{0, 1, 0, -1}; array\u0026lt;int, 4\u0026gt; dy{1, 0, -1, 0}; for (int idx = 0; idx \u0026lt; 4; ++idx) { if (dfs(board, word, i + dx[idx], j + dy[idx], k + 1)) { return true; } } // 在退出dfs之前要恢复board，否则回溯将无法找到正确路径  board[i][j] = word[k]; return false; } }; ","date":"2022-01-29T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"LeetCode 矩阵中的路径"},{"content":"题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n示例\n输入: \u0026quot;abcabcbb\u0026quot;\r输出: 3 解释: 因为无重复字符的最长子串是 \u0026quot;abc\u0026quot;，所以其长度为 3。\r输入: \u0026quot;bbbbb\u0026quot;\r输出: 1\r解释: 因为无重复字符的最长子串是 \u0026quot;b\u0026quot;，所以其长度为 1。\r输入: \u0026quot;pwwkew\u0026quot;\r输出: 3\r解释: 因为无重复字符的最长子串是 \u0026quot;wke\u0026quot;，所以其长度为 3。\r请注意，你的答案必须是 子串 的长度，\u0026quot;pwke\u0026quot; 是一个子序列，不是子串。\r解题想法 这道题想通了发现也是一道比较常规的动态规划题，但是开始时没有考虑好的细节确实是折磨了我一阵。以及没有想到用哈希表处理属实比较蠢。\n动态规划 1、状态的定义，本题依旧需要一个一维的动态规划数组，dp[i]则表示以第i个字符为结尾的子字符串可以得到的最长的含不重复字符的子字符串长度。\n2、状态转移方程，首先我们需要固定右边界i，也就是遍历时的索引，设与s[i]相同且距离最近的字符为s[pos]（pos初始化为-1。此时不重复字符子串长度应该是i - pos，但是题目所求为最长，因此根据动态规划的思想就有以下的情况\n（a）、当$pos\u0026lt;0$时，说明在s[i]的左侧没有与s[i]相同的字符，那么dp[i] = dp[i - 1] + 1（即最长长度等于遍历到前一字符的长度 + 1）\n（b）、当$dp[i - 1]\u0026lt;i - pos$时，说明重复的字符应该在当前最长非重复字符子串的区间外，即在这个子串的左边，此时dp[i] = dp[i - 1] + 1，也就是之前的子串再加上当前的字符。\n（c）、当$dp[i - 1]\u0026gt;=i-pos$​时，说明此时重复的字符应该在当前最长的非重复字符子串的区间内，因此dp[i] = i - pos，也就是在之前的子串中截取出非重复的部分。\n3、需要一个哈希表用来记录曾经出现过的字符的相对应的索引，每当遍历到一个重复字符时，便要将哈希表中的相应表项更新为当前的索引。\n由以上的分析可以看出，dp[i]只由dp[i - 1]决定，所以可以省略动态规划的数组，采用一个变量进行迭代即可，并求取此变量在这个过程中的最大值。\n双指针法（滑动窗口） 由于滑动窗口的代码写得比较少，当看到题解有滑动窗口时，便又学习了一下。\n首先要初始化left = -1以及right = 0两个指针，利用right指针进行遍历，并根据是否有重复的字符，以及是否为最长的子字符串来更改left指针的位置。这种做法依旧需要一个哈希表来存储字符对应的索引。这样就会有以下两种情况。\n（a）、当right指针对应的字符在哈希表中不存在时，可以直接增加right指针的值，且子字符串长度为right - left\n（b）、若right指针对应的字符在哈希表中存在，那么需要将left更改为当前的left指针与哈希表中对应索引的最大值（这里很重要，如果没有取两者之间的最大值那么虽然可以避免在左右两个端点处重复，但可能会导致在字符串内存在重复字符）。\n在每次更新最长字符串的值之前都要更新哈希表中的相应表项。\n代码 /*动态规划*/ class Solution { public: int lengthOfLongestSubstring(string s) { if (!s.size()) return 0; if (s.size() == 1) return 1; // 优先判断两种特殊情况  int res = 1, len = s.size(); unordered_map\u0026lt;char, int\u0026gt; um; // 用于存储字符的索引位置  int temp = 0; // temp用来存储上一次的dp值  for (int i = 0; i \u0026lt; len; ++i) { int pos; // 用来获取是否有当前字符的索引  if (um.count(s[i])) pos = um[s[i]]; else pos = -1; um[s[i]] = i; // 更新哈希表的索引  temp = (i - pos) \u0026gt; temp ? temp + 1 : (i - pos); res = max(res, temp); } return res; } }; /*滑动窗口*/ class Solution { public: int lengthOfLongestSubstring(string s) { if (!s.size()) return 0; if (s.size() == 1) return 1; // 优先判断两种特殊情况  unordered_map\u0026lt;char, int\u0026gt; um; int left = -1, len = s.size(); int res = 1; for (int right = 0; right \u0026lt; len; ++right) { if (um.count(s[right])) { // 表明这时候已经出现的重复的字符  // 这时候需要移动左指针  left = max(left, um[s[right]]); // 如果不取两者最大，那么会可能会导致字符串内重复  } um[s[right]] = right; // 更新索引  res = max(res, right - left); } return res; } }; ","date":"2022-01-24T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"LeetCode 最长不含重复字符的子字符串"},{"content":"题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n示例：\n输入: [7,1,5,3,6,4]\r输出: 5\r解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\r注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\r输入: [7,6,4,3,1]\r输出: 0\r解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\r解题想法 这道题首先可以采用暴力的求解方法，只要计算在某一天中，其后的每一天卖出的价钱所得的利润最大，依次遍历每一天，最终就可以求得最大利润，这样可以得到的时间复杂度为$$(n-1)+(n-2)+\u0026hellip;+2+1=n(n-1)/2$$也就是$O(n^2)$，不出所料，在这种解法中，你需要将一些冗余的操作去除，才能通过力扣的判题机。于是就有了下面的解法，也就是动态规划。\n动态规划思路 1、状态的定义，首先需要声明一个动态规划数组dp，其中dp[i]表示以第i天为最后一天的子数组所能获得的最大利润。\n2、状态转移方程，由于股票只能买卖一次，因此dp[i]（也就是前i天的最大利润），应该是前i-1天的最大利润与第i天卖出股票的利润的最大值，于是就有了$前i天最大利润=max（前i-1天最大利润，第i天价格-前i天最低价格）$即为dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i]))，最终返回dp[n-1]为所求。\n优化 我们还可以进行空间和时间上的优化，时间上，可以借助一个变量cost来维护最小值，这样每次进行状态转移时只需要dp[i] = max(dp[i - 1], prices[i] - min(cost, prices[i]))，空间上，由于本道题的状态转移只需要前一次的状态，因此可以采用一个变量maxprofit来代替整个动态规划列表，这样状态转移就简化为了maxprofit = max(maxprofit, prices[i] - min(cost, prices[i]))\n代码 /*未优化*/ class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.empty()) { return 0; } array\u0026lt;int, 100004\u0026gt; dp {}; int cost = prices[0]; dp[0] = 0; for (int i = 1; i \u0026lt; prices.size(); ++i) { if (prices[i] \u0026lt; cost) { cost = prices[i]; } dp[i] = max(dp[i - 1], prices[i] - cost); } return dp[prices.size() - 1]; } }; /*优化后*/ class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if (prices.empty()) return 0; int cost = prices[0], maxprofit = 0; for (int i = 1; i \u0026lt; prices.size(); ++i) { if (prices[i] \u0026lt; cost) { cost = prices[i]; } maxprofit = max(maxprofit, prices[i] - cost); } return maxprofit; } }; ","date":"2022-01-22T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","title":"LeetCode 股票的最大利润"},{"content":"题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如: 给定的树 A:\n 3\r/ \\\r4 5\r/ \\\r1 2\r给定的树 B：\n 4\r/\r1\r返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n解题想法 树的题目是真的让人头疼。在经过几次暴力解的尝试之后我还是放弃了，最后几组数据总是通过不了。还是去翻了题解，发现又是我最烦的递归（永远的痛）\n1、首先子结构要么是其本身要么在树的左子树或者右子树里，因此在isSubStructure函数中需要判断是本身匹配还是左子树或者是右子树匹配，这是最外层递归。最外层递归中，如果B树（也就是子结构树）为空，那么直接返回false，同理如果A树（要从这棵树中寻找子结构）为空也可以直接返回false\n2、对于子结构是否匹配的判断也需要通过递归实现（也就是isContain函数），但具有以下几种情况，其中包含退出递归的条件\n（a）、如果当前的B树为空，且At树（也就是从A树种截取出的子树）非空或者空，此时表明B树是A树的一个子结构，因为可以将B树匹配完。\n（b）、如果当前的B树非空，但At树为空，说明此时已经遍历过了A树的叶节点，那么B树一定与At树不匹配，可以直接返回false\n（c）、如果此时At树和B树都不为空，且当前匹配中的结点的值不相等，那么B树一定与At树不匹配，可以直接返回false\n（d）、如果At树和B树都不为空，且当前匹配中的结点的值相等，那么就继续匹配两棵树当前结点的左结点和右结点（也就是内层的递归）\n代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isContain(TreeNode *A, TreeNode *B) { // 递归判断是否包含  // 如果此时B为空树，说明已经递归完了B树，因此是包含的  if (B == NULL) return true; // 如果大树为空，匹配树不是空，那么说明不包含  if (A == NULL) return false; // 如果当前匹配的结点值不相等，那么也是不包含  if (A-\u0026gt;val != B-\u0026gt;val) return false; // 如果以上条件都不满足就继续判断子树  return isContain(A-\u0026gt;left, B-\u0026gt;left) \u0026amp;\u0026amp; isContain(A-\u0026gt;right, B-\u0026gt;right); } bool isSubStructure(TreeNode* A, TreeNode* B) { // B树为空，则为false  if (B == NULL) return false; // A树为空，也为false  if (A == NULL) return false; return isContain(A, B) || isSubStructure(A-\u0026gt;left, B) || isSubStructure(A-\u0026gt;right, B); } }; ","date":"2022-01-21T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","title":"LeetCode 树的子结构"},{"content":"题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如: 给定二叉树: [3,9,20,null,null,15,7],\n 3\r/ \\\r9 20\r/ \\\r15 7\r返回其层次遍历结果：\n[\r[3],\r[9,20],\r[15,7]\r]\r解题想法  这道题本身并不是什么难题，也很明显可以看出是一个层序遍历的变种，解决问题的关键就在于如何区分当前层和下一层，最开始是打算使用pair将每个结点与其相应的层序号对应起来。但在实际写代码时发现有点困难，最后还是去翻了题解，发现了利用空指针作为层与层之间分隔的方法。具体做法就是在第一次入队时再入队一个空指针，之后利用队头元素不为空指针作为内循环的判断，如果队头为空，则表明了已经循环完了一层。而由于二叉树的特点，在使用层序遍历时，遍历完一层也即代表着下一层的非空结点已经完全入队，这时便可以再入队一个空指针作为下一个分隔结点。利用这样的循环就能做到以层为序来打印层序遍历。\n代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; if (root == NULL) { return res; } queue\u0026lt;TreeNode*\u0026gt; que; // 用于层序遍历  que.push(root); que.push(NULL); // 利用空指针作为每层之间的分隔  while (que.size()) { vector\u0026lt;int\u0026gt; vtemp; // 队列不为空时，就申请空间存储本层数据  while (que.front()) { // 用这个条件判断是否属于同一层数据  TreeNode *temp = que.front(); vtemp.push_back(temp-\u0026gt;val); que.pop(); if (temp-\u0026gt;left) que.push(temp-\u0026gt;left); if (temp-\u0026gt;right) que.push(temp-\u0026gt;right); } // 退出上面的循环表示已经到了层与层之间的界线  que.pop(); if (que.size()) { // 如果此时队列非空，则表明不是最后一层  // 遍历过一层即表示队列中已经保存了下一层，因此需要加入空指针分割  que.push(NULL); } res.push_back(vtemp); } return res; } }; ","date":"2022-01-20T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","title":"LeetCode 从上到下打印链表"},{"content":" 如题的这两部动漫都是我认为接近于国漫巅峰的动漫，当然我并没有看过多少国漫，因此这一判断也是相当主观的。但确实的是其在我内心中是“前无古人”的。这两部动漫也是将我这一早已不看动漫的人又带回了国创动漫。\n动漫情节叙述  由于两部动漫都只做到了第一季，虽能体现一定的设定及世界观，但是很多剧情依旧是在迷雾之中的。这里也就只能讲讲已有的剧情。\n 《灵笼》的设定之前也是有过，但是灵笼剧情的饱满程度让末日题材的这种设定能够更好的展现出来。开篇便是猎荒者（即在末日中探索旧世界的可利用的东西，为幸存下来的人服务）在探索一篇废墟，并遭遇了噬极兽（因为这种怪兽因而认为地上是无法生存的）。当猎荒者凯旋归来时，之后便迎来了另一个比较重要的情节，也就是城主的更替。当然这里要先说说这个城主的问题，现在的人们生活在一个叫做“灯塔”的建筑上，而现任成主的儿子则是在灯塔上成立了一个类似于教会的“光影会”。这里就权且称这位会长为“黄毛”。城主更希望由猎荒者队长马克来接任下一任城主，但是心胸狭隘的黄毛却利用一些手段导致马克成为了噬极兽并因此被流放。（这里其实省略了很多的情节，但我觉得第一季的主要目的应该就是仅仅为了引出世界观以及《灵笼》整个庞大故事的开端）。最后第一季也是在马克与在地面上的人类相遇而结束。（这么讲其实还是草率了，如果有时间我还是希望能够去看《灵笼》的剧情）。\n 反观《时光代理人》却是以一个较为新颖的角度作为设定，也即时间。（具体便是主角团能够以自己的特殊能力进入照片，而在照片里的一言一行都有可能对未来造成影响）。时光照相馆是主角团的“基地”，也是通过这个照相馆接取委托人的任务从而帮助委托人实现一些过去或希望从过去得到线索的事情。由于这部动漫是通过一个个的小故事，因此在这里也不好叙述，依旧是推荐能够去观看动漫本身。\n谈动漫本身  很明显两部动漫都具有自己的特点，但是我却依旧将他们放在一起谈，是因为它们给我带来足够的震撼，纵使在这之前亦有《百妖谱》等，却没能给我带来那种共鸣与一种仿佛自己置身于其中希望改变世界的情感。\n 先谈《灵笼》，灵笼首先在建模方面就足够优秀，虽然采用了我不是很喜欢的建模方式，但是却依旧能够吸引我（对于我这种比较叼的人来说，这个方面就已经足够碾压国产大部分动漫了）不仅如此，人物的表情以及动作都十分逼真，其实到这里就已经可以体现制作者的用心了。当然这只是建模这个我比较关注的方面。接下来应该是剧情方面，《灵笼》的设定是动漫中比较不常见的，本以为这样的题材并不能够很好的把握，但事实是艺画开天以一种更为庞大的世界观来描述这个末日世界，这是在之前的各种影视剧中没有出现的。不仅如此，涉及的领域也十分广泛，大部分动漫可能在主题上会展现的只会是比较重要的一部分，例如青春或者爱情、友情等等。但《灵笼》光第一季就像是想要把自己的所有元素都展现出来，其中的光影会代表着类似教会一般的人，没有什么实质性的作用却控制着一部分人的思想，而会长也借助这些力量来实现自己的目标，甚至几乎摧毁了猎荒者这一强大的对抗力量。这如果影射到现实，便是思想、武装与权力之间的关系。除了这个，人性的描述也十分到位，通过对尘民4068的刻画，既展现了末日阶级统治的一种希望成为更高阶级的渴望，也让观众因为这位尘民的所作所为更加拥有共鸣。最终也会更投入到作品本身。\n 当然，一部好的的作品我觉得感情线应该是必不可少的。在《灵笼》中，并没有婚恋的自由，甚至拥有“三大法则”制约每一个人的情感。所谓的“爱情”更像是统治阶级给予的枷锁，而作为猎荒者队长的马克，本应遵守这些规则，却仍然在第一季的最后体会到了什么是爱，并为自己所爱的人大闹灯塔。虽然并没有成功的将灯塔上的人的思想扭转过来，但也为作品之后奠定了一个基调。第一季的最后则是利用地上的生存的人来表明这仅仅是《灵笼》这个庞大世界观的开始。还有一个吸引我的点是，在第一季末的一个全季最精彩的打斗场面中，背景音乐采用了纯唢呐，这种打破常规的做法也是取得了一个意想不到的效果，导致了各种二创都不及原版。\n 再看《时光代理人》，这动漫则是一开始便就从一个故事入手，直入主题，直接为观众呈现了这部作品在之后的表现方式。最开始我以为这只会是一种加强版的泡面番，通过一个个的故事来组成一部动漫，但渐渐的我发现我错了，在短短十几集的动漫中，却在最后的几集给你中给你串连起之前的故事。瞬间让你觉得这不是一个个故事那么简单。这也反应了作品中一直在重复的一句话“无论过去，不问将来”。故事也不是那种偏离现实的故事，而是充满人情味，让你觉得这都是可能发生在你身边的故事。其中的一个描述汶川地震的故事，借用了亲情和爱情令人动容。每个故事又都在恰到好处的地方停了下来。（因此我建议如果要看，就干脆一次性看完）\n 通过这整个主角团在第一季遭遇的整个故事，很精确的展现了主角团三人的性格特点，沉稳缜密的陆光，正义但却有点冲动的程小时，以及开朗能够带动气氛的乔苓。让人多多少少有点羡慕这样的三人组。第一季的最后程小时为了挽救自己之前在照片里所做过的一些错事，却发现最后仍旧没能改变，这也引出了这部动漫的反派（不止有人能够像他们那样穿越时空回到过去）。也因为这个反派最终主角团三人全部都遭到了不同程度的不幸。第一季也是在这样的一种紧张的气氛中结束了。\n给我的感受  看完这两部动漫已经很久了，但是仍然给我一种意犹未尽的感觉，最为明显的情感就是让我觉得在中国，在动漫的国创领域，仍然有这一批热爱动漫，能够写出好故事，能够通过讲好故事带给我们不一样的感受，带给我们动漫魅力的这样一群人。国创的在建模和画风上也在寻求创新以及更适合年轻人观感的改变。故事也具有较为厚重的情感，不像以前的日漫虽有情感，却给我一种较为单薄站不住脚的感觉（当然也不能否认有情感浓重的日漫）。《灵笼》带来的是宏大的世界观和巨大的创作空间。《时光代理人》带来的则是新颖的设定和令人出乎意料的编剧创作。两部动漫都以自己独特的一部分吸引着观众，也引起了在B站的极大热度。当然期待越高，不可避免的便是可能会带来失望。高开低走的动漫已经不少，我只希望拥有这么好的创作背景和创作团队，这两部动漫能够好好的珍惜，能够用尽心思来为观众呈现国漫的另一番风景，至少不要让观众对这两部动漫的呼声成为空喊，也不要让推荐这两部动漫的人最后感到太大的失望。\n 在最后还是希望国创能够走出一条更加新奇的道路，也希望这两部动漫都能够继续自己第一季的辉煌。\n 我喜欢的《时光代理人》画风 \n","date":"2022-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/","title":"观《时光代理人》、《灵笼》所感"},{"content":"本来是不想用这篇博文作为新博客的第一篇的，但无奈修改这个主题以便让我能够看得舒服确实花费了我很多精力，因此想写下这一篇博文来记录这一历程，当然这次的修改也只是建博客时对于我来说最难以忍受的痛点，如果在使用的时候觉得还有值得修改的地方，那说不定就有第二站。不废话，直接开冲！\n自定义的项目 TO-DO · 修改文章的字体为思源宋体（其实我喜欢行楷，但苦于还没有找到解决方法。。）\n· 修改站点图标\n· 修改站点名称并使其居中，同时具有一定的间隔。\n· 修改选中的样式\n· 站点头像居中（虽然本来应该就是居中了。。）\n· 添加主页按钮点击不会高亮的问题\n· 主页样式的修改\n· 修改左边栏头像大小\n· 返回顶部功能的添加\n· 修改Toc的样式\n· 修改分类的标签样式\n· 修改滚动条样式\n· 使文章支持数学公式编辑\n具体修改 修改全站的字体 其实修改字体的方案主题的原作者已经给出，有需要的可以参考修改字体，作为一个中国人，好康的中文永远比好康的英文重要。 具体做法是在站点根目录中的layouts/partials/head/custom.html中添加如下代码：\n\u0026lt;style\u0026gt; :root { --article-font-family: \u0026#34;Noto Serif SC\u0026#34;, var(--base-font-family); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // 正文自重300，标题字重700 \t(function () { const customFont = document.createElement(\u0026#39;link\u0026#39;); customFont.href = \u0026#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700\u0026amp;display=swap\u0026#34;; customFont.type = \u0026#34;text/css\u0026#34;; customFont.rel = \u0026#34;stylesheet\u0026#34;; document.head.appendChild(customFont); }()); \u0026lt;/script\u0026gt; 以上是作者给出的，我只是在字重上做了修改。除此之外我还修改了hugo-theme-stack/assets/scss/variable.scss文件，具体就是调整了--zh-font-family和--base-font-family的顺序，代码如下：\n--zh-font-family: \u0026#34;Noto Serif SC\u0026#34;, \u0026#34;Hiragino Sans GB\u0026#34;, \u0026#34;Droid Sans Fallback\u0026#34;, \u0026#34;Microsoft YaHei\u0026#34;; --base-font-family: \u0026#34;Noto Serif SC\u0026#34;, var(--sys-font-family), var(--zh-font-family), sans-serif; 修改站点的图标 这个问题起先困扰了我很久（虽然期间可能已经修改好了，但因为网站cookie的原因导致修改没有及时显示），具体做法如下，先将你需要的图片转换为.ico文件（其它类型的图片文件应该也行），如需转换可以借助这个网站。之后将转换后的文件保存在网站根目录的static文件夹中。之后修改主题的配置文件config.yaml。\nparams: mainSections: - post featuredImageField: image rssFullContent: true favicon: favicon.ico 修改站点名称 站点名称对大家来说应该不是什么难事，这里就说说居中以及间隔。这里需要修改主题根目录的assets/scss/partials/siderbar.scss文件。如下：\n.site-name { color: var(--accent-color); margin: 0; font-size: 1.8rem; text-align: center; // 站点名称文本居中  @includerespond(2xl) { font-size: 2rem; } } .site-description { color: var(--body-text-color); font-weight: normal; margin: 10px 0; font-size: 1.2rem; text-align: center; // 站点描述居中  @includerespond(2xl) { font-size: 1.6rem; } } 当然如果站点名称之间具有一定的间隔的话，应该是会更美观一点的。方法是在layouts/partials/head/custom.html文件上加入以下代码\n\u0026lt;style\u0026gt; h1 { letter-spacing: 6px; } \u0026lt;/style\u0026gt; 这个代码将会对全站的h1标题进行修改，因此业也会导致其它h1标签也发生改变，但目前只注意到进入一个分类页面时，分类的字距变大了，因此我们需要在custom.scss文件中追加如下修改：\n.section-term { font-size: 1.8rem; letter-spacing:1px; } 修改选中的样式 原来作者的选中样式和当前的大多数网站是一样的，给我一种十年前互联网的感觉，于是喜欢深色系的我修改了选中样式。需要在assets/scss/custom.scss文件中加入如下代码：\n::selection { color: #fff; background: #557697; } 站点头像居中 这个可能只是心理作用。。 同样是在assets/scss/partials/siderbar.scss文件中加入修改以下代码\n.site-avatar { position: relative; margin-left: auto; // 站点头像居中  margin-right: auto; // 站点头像居中  width: var(--sidebar-avatar-size); height: var(--sidebar-avatar-size); margin-bottom: var(--sidebar-element-separation); } 主页按钮高亮问题 这个虽然不算是什么大问题吧，但是主页不高亮我就觉得很难受。。于是就找到了layouts/partials/sidebar/left.html这个文件。我们可以看到一下代码：\n{{ $currentPage := . }} {{ range .Site.Menus.main }} {{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent \u0026#34;main\u0026#34; .)($currentPage.IsMenuCurrent \u0026#34;main\u0026#34; .)) }} 这段代码大概的逻辑就是如果当前的页面是菜单中的页面之一就设定为激活状态，而如果要让主页高亮的话需要加入以下代码：\n{{ $siteTitle := .Site.Title }} {{ $active := or ($active) (and (eq $currentPage.Title $siteTitle) (eq .Identifier \u0026#34;home\u0026#34;)) }} 这样就会使若当前的网站的标题等于网站名称就会令其为激活状态，而之后的Identifier则是为了区分主页页面，否则就会出现点击主页所有页面都是高亮的情况。\n主页样式的修改 第一次看到这个主题时就对它的主页布局感到不舒服，尤其是在笔记本电脑上挤满了整个屏幕令人难受，于是希望左右两边能够有一定的留白，这样可以美观一些。\n从开发者工具中我们可以得知主页的class是container，经过查找可以知道其样式是在assets/scss/grid.css中定义的。于是可以发现如下这段代码\n.container { margin-left: auto; margin-right: auto; .left-sidebar { max-width: var(--left-sidebar-max-width); margin-right: 1%; } .right-sidebar { max-width: var(--right-sidebar-max-width); /// Display right sidebar when min-width: lg  @includerespond(lg) { display: block; } } \u0026amp;.extended { @includerespond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } @includerespond(lg) { max-width: 1280px; --left-sidebar-max-width: 20%; --right-sidebar-max-width: 30%; } @includerespond(xl) { max-width: 1536px; --left-sidebar-max-width: 15%; --right-sidebar-max-width: 25%; } } } 这段代码对左边栏和右边栏进行了最大宽度的限制，这也就是我们要修改的地方。但是这其中的各个@include函数又代表什么呢？我们可以观察asset/scss/breakpoints.scss这个文件，如下：\n$breakpoints: ( sm: 640px, md: 768px, lg: 1024px, xl: 1280px, 2xl: 1536px, ); @mixinrespond($breakpoint) { @if not map-has-key($breakpoints, $breakpoint) { @warn \u0026#34;\u0026#39;#{$breakpoint}\u0026#39; is not a valid breakpoint\u0026#34;; } @else { @media (min-width: map-get($breakpoints, $breakpoint)) { @content; } } } 没有学过css的我也就只能大致看出这是封装了各种屏幕尺寸类似于map，而在笔记本电脑上，屏幕宽度是1024px以上的，因此我们只需要修改@include respond(lg)函数下的样式就可以了。在asset/scss/custom.scss下添加如下代码：\n.container { margin-left: auto; margin-right: auto; \u0026amp;.extended { /* range: 768-1024 */ @includerespond(md) { max-width: 1024px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 30%; } /* range: 1024-1280 */ @includerespond(lg) { // 修改主页的三个组件的显示比例  max-width: 1280px; --left-sidebar-max-width: 25%; --right-sidebar-max-width: 22%; } } \u0026amp;.compact { @includerespond(md) { --left-sidebar-max-width: 25%; max-width: 768px; } @includerespond(lg) { max-width: 1024px; --left-sidebar-max-width: 20%; } @includerespond(xl) { max-width: 1280px; } } } 至此，主页的修改也告一段落了。以上都是从这位大佬那里学来。\n修改左侧边栏头像的大小 左侧边栏的元素太多，显得实在有点挤，于是索性修改了一下博客的头像大小。需要在主题根目录下的assets/scss/partials/sidebar.scss文件。\n@includerespond(2xl) { --sidebar-avatar-size: 125px; // 修改头像大小的代码 --sidebar-element-separation: 10px; } 返回顶部按钮的添加 在参考过其它使用这个主题的博主之后发现，如果一篇文章太长，没有返回顶部这个按钮可能会在某些情况下造成体验的不舒适，于是决定加上这个功能。最开始是希望能够在一个页面的右下角添加这个按钮，但是无法解决页面缩放时显示位置与主页面之间的关系的问题，因此决定借助目录放置于目录的下方。\n首先是按钮的函数，参考了slim主题，具体是在layouts/partials/head/script.html中加入如下代码：\n\u0026lt;script src=\u0026#34;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // Check to see if the window is top if not then display button  $(window).scroll(function() { if ($(this).scrollTop()) { $(\u0026#39;#back-to-top\u0026#39;).fadeIn(); } else { $(\u0026#39;#back-to-top\u0026#39;).fadeOut(); } }); // Click event to scroll to top  $(\u0026#39;#back-to-top\u0026#39;).click(function() { $(\u0026#39;html, body\u0026#39;).animate({scrollTop: 0}, 1000); return false; }); \u0026lt;/script\u0026gt; 这段代码可以监听窗口抖动，从而控制按钮的显示和隐藏。\n然后是添加返回顶部的按钮，由于这个按钮需要和文章目录保持一个相对固定的位置，因此需要修改layouts/_default/single.html，在aside标签下加入如下代码：\n{{ $topImg := resources.Get (\u0026#34;img/top.png\u0026#34;) }} {{ $topImg := $topImg.Resize \u0026#34;40x\u0026#34; }} \u0026lt;a id=\u0026#34;back-to-top\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $topImg.RelPermalink }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; 利用一张图片作为返回顶部的链接。最后我们需要通过css来为这个按钮添加样式。首先我们需要找到之前提过的custom.scss文件，在文件中加入如下代码：\n#go-top { bottom: -15px; right: 2px; display: none; position: absolute; border: 0; \u0026amp;:hover { filter: opacity(60%); // 悬停淡化  } 其中bottom值是我觉得可以避免当目录过长时会几乎占满整个屏幕，导致按钮没有地方放的问题。\n修改Toc样式 由于Toc每个标题之间的行间距有点大，于是就缩了缩，在custom.scss文件中又追加了如下的修改：\n.widget--toc { background-color: var(--card-background); border-radius: var(--card-border-radius); display: flex; flex-direction: column; color: var(--card-text-color-main); overflow: hidden; // display:inline-block;  font-size: 16px; #TableOfContents { overflow-x: auto; ol, ul { margin: 10; padding: 0; } ol { list-style-type: none; counter-reset: item; li:before { counter-increment: item; content: counters(item, \u0026#34;.\u0026#34;) \u0026#34;. \u0026#34;; font-weight: bold; margin-right: 0px; } } \u0026amp; \u0026gt; ul { padding: 0 1em; } li { margin: 5px 20px; padding: 6px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 6px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 追加了一些修改，在使用了一段时间后发现，每个目录项前面的小点在一定程度上占了空间，挤压了目录字，导致每个目录项容易换行，以及在margin和padding上还可以有缩减的空间，于是在custom.scss文件上做了以下修改（删了一些无用代码，注释了小点，并修改了一些间距）\n.widget--toc { // display:inline-block;  font-size: 16px; #TableOfContents { overflow-x: auto; max-height: 70vh; ol, ul { list-style-type: none; margin: 0; padding: 0; } // \u0026amp; \u0026gt; ul {  // padding: 0 1em;  // }  li { margin: 5px 10px; padding: 6px; \u0026amp; \u0026gt; ol, \u0026amp; \u0026gt; ul { margin-top: 10px; padding-left: 8px; margin-bottom: -5px; \u0026amp; \u0026gt; li:last-child { margin-bottom: 0; } } } } } 修改分类标签样式 这个stack主题属实是有点迷，一样的主题推送到GitHub居然能产生不同的效果，无奈的我只能又去修改原先又大又丑的分类标签，根据我个人的喜好，将标签修改为小巧一点，放弃了原来的图片修饰，相关的代码写于custom.scss文件中：\n.subsection-list { margin-bottom: var(--section-separation); overflow-x: auto; .article-list--tile { display: flex; padding-bottom: 15px; article { width: 200px; // 修改分类的标签大小  height: 50px; margin-right: 5px; flex-shrink: 0; // box-shadow: var(--shadow-l2);  .article-title { margin: 0; font-size: 1.5rem; text-align: center; // 保证字居中美观一点  } .article-details { padding: 20px; justify-content: center; } } } } 修改相关文章图标 样式 在第一次推送到GitHub之后发现，相关文章的推荐标签有点与当前屏幕不相符，于是决定将相关文章的标签的大小调整到与分类的大小差不多大，于是我们依旧在custom.scss文件中追加修改样式的代码：\n.related-contents--wrapper { .related-contents { article { width: 200px; height: 85px; .article-title { font-size: 1.6rem; } } } } 修改滚动条样式 当文章的目录太长时便会产生滚动条，而默认的滚动条实在是丑得不想形容。由于不是很想再调试了，于是再次参考大佬的操作，而且既然想改滚动条了，索性一步到位直接全改，我们需要在custom.scss文件中添加如下代码：\nhtml { ::-webkit-scrollbar { width: 20px; } ::-webkit-scrollbar-track { background-color: transparent; } ::-webkit-scrollbar-thumb { background-color: #d6dee1; border-radius: 20px; border: 6px solid transparent; background-clip: content-box; } ::-webkit-scrollbar-thumb:hover { background-color: #a8bbbf; } } 支持数学公式编辑 在一次使用了markdown内联的$LaTeX$公式发现部署上去之后没有反应时，便一直想使文章能够支持数学公式的编辑。于是在时隔多日之后终于有了解决办法。\n我们需要在主题根目录的/layouts/partials创建math.html文件，之后在这个文件中加入如下代码\n{{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body);\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 这段代码能够自动渲染数学公式，当然这样还是不够的，我们还需要在每篇文章的markdown的header加上math=\u0026quot;true\u0026quot;的选择字段。\n","date":"2022-01-15T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/","title":"Hugo博客 | stack主题修改第一站"},{"content":"题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n示例  \n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\r输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\r解题 题目的意思很简单，就是返回一个一模一样的链表头结点。由于随机指针的存在，链表的复制不能够像正常链表那样直接遍历，也因此没想明白要怎么做，最后翻了题解，才发现又是我最烦的递归。\n这道题采用的递归解法其实本质就是遇到问题再解决问题，在还没有开始复制之前，所有的复制结点都是虚无的，要让这些结点和已知的结点一一对应起来就需要一个map数据结构。用来对应新旧两个链表的结点。这样从第一个结点入手，当这个结点不在map中时，就立刻创建这个结点并于原链表中的相应结点建立对应关系。之后的每一个结点都可以根据这样的逻辑进行创建，而因为有map这个数据结构的存在，这样每个结点都不是虚空存在的，而是可以在map中找到与之对应的结点。可以解决随机结点创建的问题。具体代码如下：\nclass Solution { public: unordered_map\u0026lt;Node*, Node*\u0026gt; um; // 用来存储两个链表，结点之间一一对应  Node* copyRandomList(Node* head) { if (head == NULL) { // 如果链表本就为空，那么直接返回空  return NULL; } // 遵循边遍历边创建的原则  if (!um.count(head)) { // 如果此时哈希表中没有这个结点，就直接创建  Node* headNew = new Node(head-\u0026gt;val); // 初始化一个相同的结点  um.insert(make_pair(head, headNew)); // 将这两个位置一样的结点对应起来  headNew-\u0026gt;next = copyRandomList(head-\u0026gt;next); // 同理下一个结点也应该这样拷贝，依旧遵循上面的原则  headNew-\u0026gt;random = copyRandomList(head-\u0026gt;random); } // 如果这个结点已经在哈希表中存在，那么就直接返回  return um[head]; } }; ","date":"2022-01-10T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","title":"LeetCode 复杂链表的复制"},{"content":"题目描述 给定一个链表，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n示例  在这里插入图片描述 \n输入：head = [3,2,0,-4], pos = 1\r输出：true\r解释：链表中有一个环，其尾部连接到第二个节点。\r 在这里插入图片描述 \n输入：head = [1,2], pos = 0\r输出：true\r解释：链表中有一个环，其尾部连接到第一个节点。\r 在这里插入图片描述 \n输入：head = [1], pos = -1\r输出：false\r解释：链表中没有环。\r提示 链表中节点的数目范围是 [0, 104]\r-105 \u0026lt;= Node.val \u0026lt;= 105\rpos 为 -1 或者链表中的一个 有效索引 。\r解题想法 这道题在leetcode上属于简单题，但由于第一次遇见这种解法（也由于第一次想错了，根本不是正解）所以就想记录一下。 很明显题目要判断链表中是否有环，于是可以想到如果在链表中有两个指针分别向前跑，当两个指针指向的结点相同的时候便证明链表中有环存在。这个时候就需要一个循环来判断两个指针是否相等。此时条件应该是first != second因此如果我们初始化两个指针在同一个位置，那么将无法进入循环，因此需要将两个指针分别初始化在头结点以及头结点的下一个结点，还要注意的是，first指针的速度应该要快于second指针的速度，这样，当链表中有环时，first指针会先进入环中，并一直在环中循环，而当second指针进入环时，由于first指针速度快，将会在某个循环时刻追上second指针，这样当两个指针重合后就能够判断出链表存在环，下面附上C++代码\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { if (head == nullptr || head-\u0026gt;next == nullptr) { return false; } ListNode *first = head-\u0026gt;next; ListNode *second = head; while (first != second) { if (first == nullptr || first-\u0026gt;next == nullptr) { return false; } second = second-\u0026gt;next; first = first-\u0026gt;next-\u0026gt;next; } return true; } }; ","date":"2021-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","title":"LeetCode 141 环形链表"},{"content":"题目描述 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。\n如果没有和至少为 K 的非空子数组，返回 -1\n示例 输入：A = [1], K = 1\r输出：1\r输入：A = [1,2], K = 4\r输出：-1\r输入：A = [2,-1,2], K = 3\r输出：3\r提示 1. 1 \u0026lt;= A.length \u0026lt;= 50000\r2. -10 ^ 5 \u0026lt;= A[i] \u0026lt;= 10 ^ 5\r3. 1 \u0026lt;= K \u0026lt;= 10 ^ 9\r首先对于我这样一个不怎么有基础的人来说，这道题着实是令我作呕。。解题也是通过了其它题解的启发。下面就开始吧。\n解题想法 由于题目中已经明确表示了数组的长度为50000，因此如果要使用暴力接法，势必造成O(n^2)的时间复杂度。因此就要想办法让i， j两个循环变量只跑一遍。而对于这道题因为绕不开要求取数组中的区间和。所以可以采用的一个方法是前缀和思想。大致的意思就是sum[i] = array[0] + array[1] + \u0026hellip; + array[i - 1]利用这个前缀和数组就可以较为方便的得到一个数组的区间和，例如要知道区间[1, 3]的和，我们可以利用前缀和数组得到sum[4] - sum[1]（这里需要注意的是，为了便于计算前缀和数组的第零个元素默认为零）\n解决了前缀和之后就要解决更加关键的问题，如何能够得到最短长度的和最小序列。首先我们不妨先这么想，如果我们当前的索引为i， 此时若区间[0, i]的和比区间[0, i - 1]的和要小，那么就不需要再考虑i - 1这个位置的索引了（因为这个时候有sum[A.length] - sum[i] \u0026gt; sum[A.length] - sum[i - 1] 且前者的区间长度要小于后者）而这个时候就要原先的存储的i - 1这个索引弹出，再将更优的i索引加入。这个时候可以利用队列这样的数据结构来保存。有了这个存删的机制就可以保证每次能够得到的长度都是最短且和最大的。之后就是获得长度的问题了。如果这个队列中还有元素的话，就从当前遍历到的索引i的前缀和减去队列头部保存的索引，即（sum[i] - sum[queue.front()]）这个条件需要满足题目中给出的K。由此可以看出这个队列需要两端都能出，因此我们需要维护一个单调递增的双端队列。下面附上C++代码\nclass Solution { public: int shortestSubarray(vector\u0026lt;int\u0026gt;\u0026amp; vec, int threshold) { int len = vec.size(); int minLength = 5e4 + 11; deque\u0026lt;int\u0026gt; dque; vector\u0026lt;int\u0026gt; sum(len + 1, 0); // 初始化前缀和数组  for (int i = 1; i \u0026lt;= len; ++i) { sum[i] = sum[i - 1] + vec[i - 1]; } for (int i = 0; i \u0026lt; len + 1; ++i) { if (i != 0) { // 满足性质就将队列尾部的索引给删除不再考虑  while (dque.size() \u0026amp;\u0026amp; sum[dque.back()] \u0026gt;= sum[i]) { dque.pop_back(); } // 从队列头部开始寻找满足条件的最短区间  // 如果不满足条件就要将队列头部元素删除  while (dque.size() \u0026amp;\u0026amp; sum[i] - sum[dque.front()] \u0026gt;= threshold) { minLength = min(minLength, i - dque.front()); dque.pop_front(); } } dque.push_back(i); } return minLength == 5e4 + 11 ? -1 : minLength; } }; ","date":"2021-01-18T00:00:00Z","permalink":"https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"LeetCode 862 和至少为K的最短子数组"}]