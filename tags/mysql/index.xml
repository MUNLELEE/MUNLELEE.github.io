<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on 墨纹</title>
    <link>https://MUNLELEE.github.io/tags/mysql/</link>
    <description>Recent content in MySQL on 墨纹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 04 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://MUNLELEE.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL学习（五）| 锁</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%94-%E9%94%81/</link>
      <pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%94-%E9%94%81/</guid>
      <description>前言 数据库锁的设计初衷是处理并发问题。根据加锁的范围，MySQL里的锁大致可以分为 全局锁、 表级锁 和 行级锁 三类。&#xA;全局锁 全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 全局锁的典型使用场景是，做全库逻辑备份。&#xA;如果使用全局锁对整个库进行备份（期间整个库都处于只读状态），会有以下的问题：&#xA;如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。 如果在备份时不加锁，容易出现并发问题。这里用网站给出的例子稍微解释：&#xA;假设要维护用户账户余额和课程表，现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，流程示意图如下：&#xA;从图中可以看出，用户余额没有扣减，但是却多出了一门课，也就是用户赚了。同样，如果先备份用户课程表再备份用户账户表，就会发现用户亏了。&#xA;官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。也就是在可重复读的隔离级别下开启一个事务。但是这种方法只适用于所有表使用事务引擎的库。&#xA;这里还有一个问题，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？，不使用这个方法的原因有两点：&#xA;在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 表级锁 MySQL里的表级锁有两种： 表锁 和 元数据锁（meta data lock，MDL）&#xA;表锁 **表锁的语法是 lock tables [table_name] read/write ** 。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。 需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</description>
    </item>
    <item>
      <title>MySQL学习（四）| 索引</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E7%B4%A2%E5%BC%95/</guid>
      <description>前言 索引是数据库中重要的概念，简单来说，索引就像是书的目录一样，其目的就是为了提高数据查询效率。&#xA;索引的常见模型 索引的出现是为了提高查找效率，但是实现索引的方式有很多种，这里介绍三种常见的索引结构。&#xA;哈希表 哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。&#xA;和Java类似，当链表过长时会影响查询效率，Java中的HashMap首先是会进行数组的扩容，在一定阈值后将拉链表转换为红黑树。&#xA;假设现在维护一个身份证信息和姓名的表，使用哈希索引的示意图如下：&#xA;假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。&#xA;所以，哈希表这种结构适用于只有等值查询的场景，而有序数组在等值查询和范围查询的性能都较好。&#xA;有序数组 依旧使用上面的例子，如果使用有序数组作为索引结构，示意图如下：&#xA;这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。这种索引结构同样支持范围查询，如果要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。&#xA;如果单纯看查询效率，有序数组是一个不错的存储结构，但当更新数据时，需要移动插入位置后的所有元素，成本较大。因此，有序数据索引结构只适合静态存储引擎&#xA;二叉搜搜索树 二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&amp;gt; UserC -&amp;gt; UserF -&amp;gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。&#xA;为了维持O(log(N))的查询复杂度，需要保持搜索树为平衡二叉树，因此更新元素的时间复杂度也为O(log(N))。&#xA;更多情况下并不使用二叉搜索树作为索引。数据库索引不仅存在内存中，还要存储到磁盘里，不可避免的会涉及到读盘操作。二叉搜索树随着节点的增多，树高将不断增长，进行一次查询需要读取的数据块较多，就会导致查询效率降低。&#xA;InnoDB的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在InnoDB里面对应一棵B+树。</description>
    </item>
    <item>
      <title>MySQL学习（三）| 事务</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%89-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 01 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%89-%E4%BA%8B%E5%8A%A1/</guid>
      <description>前言 在和数据库打交道，事务总是绕不开的。简单说，事务就是要保证一组数据库操作要么全部成功，要么全部失败。 在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。&#xA;隔离性与隔离级别 事务具有四大特性，也就是常说的ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），这里打算说说隔离性。&#xA;当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。&#xA;隔离级别越高，效率就会越低。 SQL的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。&#xA;读未提交，一个事务还没提交时，它做出的变更就能被其他事务看到 读提交，一个事务提交之后，它做出的变更才能被其他事务看到 可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在这个级别下，未提交的变更对其他事务也是不可见的。 串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 下面对这几种隔离级别进行简单解释。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行的两个事务的行为。&#xA;在不同的隔离级别下，图中V1、V2、V3会得到不同的值&#xA;若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。 在实际实现上，数据库会创建一个视图，访问得到的就是视图的逻辑结果。在“可重复读”这个隔离级别下，视图是在事务启动时创建的，整个事务存在期间都是用这个视图；在“读提交”，视图是在每个SQL语句开始执行之后创建的；在“读未提交”这个隔离级别下，没有视图的概念，直接返回记录的最新值；在“串行化”隔离级别下，则是直接使用加锁的方式来避免并行访问</description>
    </item>
    <item>
      <title>MySQL学习（二）| 日志系统</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>前言 在了解了查询语句之后，再来了解一下更新语句的执行流程。&#xA;对于如下这个表，有一个主键ID和整型字段c：&#xA;create table T(ID int primary key, c int); 如果要将ID=2的行的字段 c 加一，那么SQL语句就会这么写&#xA;update T set c = c + 1 where ID = 2; 在之前讲述过MySQL的整体架构，准确来说，查询语句经历的流程更新语句也会走一遍。首先执行前需要先连接数据库，又因为这是对表进行更新的语句，因此会将查询缓存清空，接下来分析器进行词法分析和语法分析确定这是一条更新语句。优化器决定使用ID这个索引，最后交由执行器执行。&#xA;与查询流程不一样的是，更新流程涉及两个重要的日志模块，redo log（重做日志）和binlog（归档日志）。&#xA;redo log 对于不断到来的修改记录，数据库自然需要对应的存储方式。如果记录不多，可以将记录存储在缓存中，当数据量大的后，日志系统不可避免的要存储到磁盘中。此时有两种存储方式&#xA;一种是直接对对应的记录进行增减。 另一种直接记录当前的操作记录，待之后空闲再进行所有记录的核算。 在高并发的情况下，第二种方式无疑是较为合理的，避免了先在所有数据中找到对应的记录之后才能添加修改日志。&#xA;MySQL就是是这样，如果每次更新都需要写入磁盘，磁盘也需要找到对应的那条记录再进行更新，整个过程的IO成本和查找成本都很高。&#xA;具体说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，也就是WAL技术，全称是Write-Ahead-Logging，关键就是先写日志再写磁盘。&#xA;InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么内存就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。如下图所示&#xA;write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。&#xA;write pos 和 checkpoint 之间的是还可以使用的内存大小，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示内存满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。&#xA;有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe 。</description>
    </item>
    <item>
      <title>MySQL学习（一）| 基础架构</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 27 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</guid>
      <description>已经许久没有更新过博客了，曾经的热情似乎早已不再。在经历过一些人和事之后，觉得还是有必要重启这个博客，回归打算就从MySQL开始吧，经好友推荐了解到了《MySQL45讲》，之前的数据库基础实在是有点薄弱，打算趁此机会正式学习一下这个数据库。&#xA;MySQL基础架构 MySQL逻辑架构 如图所示，是MySQL的基础架构，大体可以分为server层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现。存储引擎层负责数据的存储和提取。其架构模式是插件式的，最常用的存储引擎是InnoDB，也是MySQL的默认存储引擎。当然，我们也可以在建表时使用 engine=MyISAM 来更改存储引擎。&#xA;值得一提是，MySQL8.0取消了查询缓存这个模块，原因自然是查询缓存存在弊端和局限性。同时由于现代缓存redis发展的成熟，将缓存置于客户端也有更多的好处。这些内容有机会再另开一篇博客稍作解释吧。&#xA;连接器 第一步，在连接到数据库之后，首先通过的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：&#xA;mysql -h$ip -P$port -u$user -p$password 在经过 TCP握手 之后，连接器就会开始认证你的身份。&#xA;如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。&#xA;如果连接断开之后（如果客户端长期处于空闲，MySQL也会将连接中断，由参数 wait_timeout 控制），客户端再次发送请求，就会发生错误，此时需要进行重连。这里区分了 长连接 和 短连接 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。&#xA;建立连接的过程较为复杂，实际使用中要减少建立连接的动作，因此尽量使用长连接。&#xA;但是全部使用长连接后，MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。&#xA;如何解决这种问题？&#xA;定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 因为新版的MySQL已经舍弃了这一部分，所以不作过多介绍。只需要知道MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以键值对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。&#xA;但是查询缓存的失效十分频繁，只要有针对表的更新，那么关于这个表的查询缓存就会被清空。&#xA;分析器 分析器首先会进行“词法分析”，识别出里面的字符串分别是什么，代表什么。之后进行“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。&#xA;如果查询的字段在表中不存在，那么在分析器阶段就会报错&#xA;优化器 经过分析器，MySQL就知道要做什么了，在执行之前还需要经过优化器处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：&#xA;mysql&amp;gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 此时优化器要决定先取出t1表的数据还是t2表的数据再进行关联。虽然是一样的逻辑，但可能有不一样的执行效率。&#xA;执行器 到了执行器之后就开始正式执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。对于如下的这个语句，若ID字段没有索引，那么执行流程如下&#xA;select * from T where ID = 10; 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 参考 MySQL45讲——01 基础架构：一条SQL查询语句是如何执行的？ </description>
    </item>
  </channel>
</rss>
