<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on 墨纹</title>
    <link>https://MUNLELEE.github.io/tags/redis/</link>
    <description>Recent content in redis on 墨纹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 30 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://MUNLELEE.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis二三事（一）</title>
      <link>https://MUNLELEE.github.io/post/redis%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B8%80/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/redis%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B8%80/</guid>
      <description>想来既然决定了走Java这条路，那么一定是绕不开redis了，redis的使用以及其原理也算是一门艺术了，希望通过博文把一些常见的redis问题和操作记录下来。&#xA;前言 在当前的数据库体系中有两大类型的数据库，一类是关系型数据库，另一类为非关系型数据库。关系型数据库典型的数据结构是表，是由二维表及其之间的联系所组成的数据组。非关系型数据库严格上来说不是一种数据库，而是一种 数据结构化存储方法的集合，可以是文档或者键值对等。 两者的优缺点如下&#xA;关系型数据库 优点 缺点 使用方便，SQL语言较为通用，可以用于复杂查询 高并发读写性能较差，在海量数据的读写场景中性能较差，硬盘的IO是一个无法避免的瓶颈 易于维护，都是使用表结构，格式一致 灵活度较低，表结构固定，DDL修改对业务影响较大 复杂操作，可用于一个表以及多个表之间的复杂查询 支持事务控制 非关系型数据库 优点 缺点 读写速度快，可以存储在内存中，不依赖于硬盘 不支持join等复杂连接操作 数据格式灵活，可以是键值对，文档、图片等，扩展性强 事务处理能力弱 缺乏数据完整性约束 不提供SQL支持 redis简介 Redis（Remote Dictionary Server），即远程字典服务，是一个用C语言编写可基于内存亦可以持久化的日志型，Key-Value数据库。是非关系型数据库的一种解决方案，也是目前业界主流的缓存解决方案组件。&#xA;why redis redis性能优秀，能够支持每秒大量的读写操作，还支持集群，分布式、主从同步等配置。同时支持一定的事务能力，保证了高并发场景下的数据的安全和一致性。还有一点，redis的社区十分活跃。其优点如下：&#xA;redis优点 通常情况下，redis作为MySQL等数据库的缓存层使用。为什么要有缓存？如果在这样一个场景，当大量的数据请求访问MySQL，过多的请求可能会导致MySQL服务器压力过大，甚至会因为过量的请求将数据库击穿，数据服务也会因此中断。此时如果有缓存，那么数据访问请求将会先通过缓存再到达数据库，一旦请求在缓存中得到响应，将不会再查询数据库，这会很大的减少数据库的压力。简单描述如下图：&#xA;什么数据可以放在redis 这个问题其实一直萦绕在脑海里很久，在网上翻阅了一段时间也没有找到描述得较为详细的，更多的是应用的具体场景，但在我看来都不够抽象。看来这个问题也只有不断的在实践中去寻找答案了。这里就稍微简单描述一下&#xA;不需要实时更新但是又极其消耗数据库的数据。例如网上的商品销售排行榜，这种数据只需要每隔一段时间统计即可，其实时性关注度并不高。 更新频率不高，但是访问比较频繁的数据。这类数据如果放置于缓存能够一定程度上减少数据库的访问压力。如用户个人资料，设置完成后并不会频繁更新，但是为了个性化服务可能会频繁访问。 需要实时更新，但是更新频率不高的数据。比如一个用户的订单列表，用户的订单显然是需要实时呈现的，但是频繁下单的情况又比较少。 在某个时刻访问量极大而且更新也很频繁的数据。种数据有一个很典型的例子就是秒杀，在秒杀那一刻，可能有N倍于平时的流量进来，系统压力会很大。但是这种数据使用的缓存不能和普通缓存一样，这种缓存必须保证不丢失，否则会出现一致性等问题。 redis缓存问题 缓存雪崩 定义 大量或全部缓存数据突然失效或消失，导致所有请求都直接打到数据库上，数据库在巨大的压力下响应缓慢或宕机，应用性能急剧下降，就像雪崩一样。&#xA;触发原因 同步过期。如果你将大量缓存设置为在同一时间过期。突然间，所有数据都需要重新加载到缓存中，这时候所有的请求都会转到数据库上，导致瞬间流量激增。 系统重启。有时系统维护或意外的服务重启会导致所有缓存失效。当服务再次上线，所有的请求都会涌向空无一物的缓存，然后转向数据库。 Redis服务宕机。硬件故障、网络问题或配置错误都可能导致Redis服务不可用。此时所有的请求都会打向数据库。 热点key消失。在某些情况下，特定的热点key（被大量频繁访问的key）如果失效或被删除，也会导致相应的大量请求直接落到数据库上，造成局部的雪崩效应。 解决方案 过期策略改进 随机过期时间。给缓存项设置随机的过期时间可以防止它们同时失效。例如，希望缓存大约在1小时后过期，可以设置过期时间为60±10分钟。 细粒度过期。对于一些热点数据，可以使用更细粒度的过期时间。如使用不同的过期时间策略针对不同类型或频率访问。 预防措施 合理设置缓存失效时间。根据应用的具体情况合理设置缓存的失效时间，避免大量缓存同时过期。对于不同的数据和业务场景，失效时间应该有所不同。 持久化策略。利用Redis的RDB或AOF持久化机制，确保在系统重启后缓存可以被恢复，减少对数据库的压力。 备份机制。确保有备份和灾难恢复计划，当缓存服务器出现问题时，可以快速恢复或切换到备份系统。 热点数据处理 识别热点数据。监控和识别访问频率特别高的数据。这些数据是潜在的热点，需要特别关注。 分布式锁。对于热点key的更新操作，可以使用分布式锁来确保同一时间只有一个请求去构建新的缓存，避免大量请求同时击中数据库。 使用队列。对于高频更新的热点数据，可以使用消息队列来缓冲和序列化处理请求。 降级和限流 服务降级。在缓存雪崩或其他系统异常时，可以暂时关闭一些非核心功能，保证核心功能的正常运作。 请求限流。通过算法（如令牌桶、漏桶等）限制访问频率，确保系统在承受范围内。 缓存穿透 定义 当请求查询的数据在缓存中不存在时（也不存在于数据库中），请求便会“穿透”缓存层直接查询数据库。在正常情况下，缓存系统会减轻对数据库的访问压力，但在缓存穿透的情况下，大量的无效请求会直接落在数据库上，导致数据库负载激增，甚至可能导致服务瘫痪。&#xA;触发原因 恶意攻击&#xA;攻击者可能会故意请求缓存中不存在的数据。这种攻击通常旨在使应用程序变慢或崩溃，从而达到拒绝服务的效果。&#xA;系统缺陷&#xA;设计缺陷。如果系统没有妥善处理不存在的数据请求，例如未设置合理的默认行为或缓存策略，那么即使是正常的用户行为也可能导致缓存穿透。 数据不一致。在有些情况下，缓存和数据库之间的数据不同步也可能导致缓存穿透。 错误的用户输入</description>
    </item>
  </channel>
</rss>
