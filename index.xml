<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>墨纹</title>
        <link>https://MUNLELEE.github.io/</link>
        <description>Recent content on 墨纹</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 28 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://MUNLELEE.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Linux下的socket网络通信</title>
        <link>https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/socket%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;p&gt;想来虽然学了计网，但却没有真正的用程序来实现一下计网的理论，于是就学习了一下socket的通信，并进行复现。至于为什么是Linux，是发现网上好像没有太多系统的关于Windows的网络编程，索性就直接放弃了。&lt;/p&gt;
&lt;h2 id=&#34;socket&#34;&gt;socket&lt;/h2&gt;
&lt;p&gt;socket即为套接字，是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。提供了应用进程利用网络协议交换数据的机制，上联应用程序，下联网络协议栈。既是应用协议通过网络协议进行通信的接口，也是应用程序与网络协议栈进行交互的接口。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621c69da2ab3f51d912afc07.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621c69da2ab3f51d912afc07.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因此socket将复杂的网络协议族（也就是TCP/IP），隐藏起来，使其对应用程序透明，利用socket可以实现两个程序之间的通信。&lt;/p&gt;
&lt;p&gt;对于网络层的两大协议TCP和UDP，socket也分为了流和数据报的两种通信形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流：基于TCP协议，因此有序，可靠。可以实现可靠传输。&lt;/li&gt;
&lt;li&gt;数据报：基于UDP，不需要建立和维持连接，不可靠，但是通信速度较快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cs模式&#34;&gt;C/S模式&lt;/h2&gt;
&lt;p&gt;在计算机网络中，两个程序的通信模式是，客户/服务器模式，双方借助socket建立连接后便能实现通信。&lt;/p&gt;
&lt;h3 id=&#34;服务器工作流程&#34;&gt;服务器工作流程&lt;/h3&gt;
&lt;h4 id=&#34;1创建服务器socket&#34;&gt;1、创建服务器socket&lt;/h4&gt;
&lt;p&gt;在这个阶段我们可以使用&lt;code&gt;socket&lt;/code&gt;函数来创建一个服务器的套接字。需要注意的是在socket编程中只能指定协议族为&lt;code&gt;AF_INET&lt;/code&gt;，即表示利用IPv4进行通信。这个函数的返回值为 &lt;strong&gt;文件描述符&lt;/strong&gt; （类型为整型），当失败时则会返回&lt;code&gt;-1&lt;/code&gt;如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; listenfd;
listenfd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2将服务器用于通信的地址和端口绑定到socket上&#34;&gt;2、将服务器用于通信的地址和端口绑定到socket上&lt;/h4&gt;
&lt;p&gt;在Linux中，地址信息被封装在了结构体&lt;code&gt;sockaddr&lt;/code&gt;中，如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt; {  
	sa_family_t sin_family;  &lt;span style=&#34;color:#75715e&#34;&gt;//地址族
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; sa_data[&lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;];  &lt;span style=&#34;color:#75715e&#34;&gt;//14字节，包含套接字中的目标地址和端口信息               
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;想必可以很明显的看到，在这个结构体中目标地址和端口信息是存放在一个数组中的，因此不便于区分，所以我们使用另外一个结构体&lt;code&gt;sockaddr_in&lt;/code&gt;，这个结构体如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; {
	sa_family_t sin_family;  
	&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16_t&lt;/span&gt; sin_port;  &lt;span style=&#34;color:#75715e&#34;&gt;// 端口号
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;in_addr&lt;/span&gt; sin_addr;  &lt;span style=&#34;color:#75715e&#34;&gt;// IP地址
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; sin_zero;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但如果你进入到Linux的底层代码会发现，&lt;code&gt;sockaddr_in&lt;/code&gt;还有一个参数为&lt;code&gt;sockaddr&lt;/code&gt;的构造函数。因此使用这个结构体可以让操作更简单，如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; servaddr;
memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr));
servaddr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
servaddr.sin_addr.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htonl(INADDR_ANY);  &lt;span style=&#34;color:#75715e&#34;&gt;// 指定为任意IP地址
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;servaddr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(atoi(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]));  &lt;span style=&#34;color:#75715e&#34;&gt;// 将主机字节顺序转换为网络字节顺序
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后将端口绑定。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;bind(listenfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3将socket设置为监听模式&#34;&gt;3、将socket设置为监听模式&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;listen(listenfd, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 5表示准备接受5个连接
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;4等待并接受客户端连接&#34;&gt;4、等待并接受客户端连接&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;accept&lt;/code&gt;函数来连接客户端&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; clientfd;
clientfd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; accept(listenfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;clientaddr, (socklen_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;socklen);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;这里需要解释的是，服务器端其实建立了两个socket，第一个socket为被动的socket用来监听，当经过监听阶段后，Linux内核拥有accept函数借助监听的socket创建出连接客户端的socket&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;5与客户端通信接受客户端发送的信息并返回响应&#34;&gt;5、与客户端通信，接受客户端发送的信息，并返回响应&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;recv&lt;/code&gt;和&lt;code&gt;send&lt;/code&gt;函数进行通信&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (true) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; iret;
    memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recv(clientfd, buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iret = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; iret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    	&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
    }
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;receive &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    strcpy(buffer, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ACCEPT&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; send(clientfd, buffer, strlen(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    	perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send&amp;#34;&lt;/span&gt;);
    	&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
    }
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SEND: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;6重复5中操作直到客户端断开连接&#34;&gt;6、重复（5）中操作，直到客户端断开连接&lt;/h4&gt;
&lt;h4 id=&#34;7释放socket连接&#34;&gt;7、释放socket连接&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;close(listenfd);
close(clientfd);  &lt;span style=&#34;color:#75715e&#34;&gt;// 释放监听socket和连接socket
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;netdb.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Using server port&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Example: ./server 5005&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; listenfd;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((listenfd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;socket&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; servaddr;
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr));
    servaddr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
    servaddr.sin_addr.s_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htonl(INADDR_ANY);
    &lt;span style=&#34;color:#75715e&#34;&gt;//servaddr.sin_addr.s_addr = inet_addr(&amp;#34;192.168.190.134&amp;#34;);  // 手动指定IP地址
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    servaddr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(atoi(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]));
    &lt;span style=&#34;color:#75715e&#34;&gt;// 3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bind(listenfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bind&amp;#34;&lt;/span&gt;);
        close(listenfd);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (listen(listenfd, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listen&amp;#34;&lt;/span&gt;);
        close(listenfd);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; clientfd;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; socklen &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; clientaddr;
    clientfd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; accept(listenfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;clientaddr, (socklen_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;socklen);
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;clinet has connected&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;IP is: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; inet_ntoa(clientaddr.sin_addr) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 5
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (true) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; iret;
        memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
        &lt;span style=&#34;color:#75715e&#34;&gt;// 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recv(clientfd, buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iret = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; iret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;receive &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        strcpy(buffer, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ACCEPT&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; send(clientfd, buffer, strlen(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send&amp;#34;&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SEND: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    }
    close(listenfd);
    close(clientfd);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;客户端工作流程&#34;&gt;客户端工作流程&lt;/h3&gt;
&lt;h4 id=&#34;1创建客户端socket&#34;&gt;1、创建客户端socket&lt;/h4&gt;
&lt;p&gt;同样采用&lt;code&gt;socket&lt;/code&gt;函数创建套接字，用来主动连接，与服务器的创建方式一样。&lt;/p&gt;
&lt;h4 id=&#34;2向服务器发起连接请求&#34;&gt;2、向服务器发起连接请求&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;gethostbyname&lt;/code&gt;函数将IP地址转换为&lt;code&gt;hostent&lt;/code&gt;结构体所表示的格式。&lt;code&gt;hostent&lt;/code&gt;结构体如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hostent&lt;/span&gt;  {  
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;h_name;         &lt;span style=&#34;color:#75715e&#34;&gt;//正式主机名  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;h_aliases;     &lt;span style=&#34;color:#75715e&#34;&gt;//主机别名  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; h_addrtype;       &lt;span style=&#34;color:#75715e&#34;&gt;//主机IP地址类型：IPV4-AF_INET  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; h_length;         &lt;span style=&#34;color:#75715e&#34;&gt;//主机IP地址字节长度，对于IPv4是四字节，即32位  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;h_addr_list;   &lt;span style=&#34;color:#75715e&#34;&gt;//主机的IP地址列表  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;建立连接的过程如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sockfd;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; servaddr;
memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr));
servaddr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;  &lt;span style=&#34;color:#75715e&#34;&gt;// 手动指定相关参数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;servaddr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(atoi(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]));
memcpy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr.sin_addr, hostcon&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr, hostcon&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_length);
connect(sockfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr)  &lt;span style=&#34;color:#75715e&#34;&gt;// 连接
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3与服务器通信将消息通过socket发送给服务器每发送一个消息等待回复&#34;&gt;3、与服务器通信，将消息通过socket发送给服务器，每发送一个消息等待回复&lt;/h4&gt;
&lt;p&gt;同样使用&lt;code&gt;recv&lt;/code&gt;和&lt;code&gt;send&lt;/code&gt;函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; iret;
    memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
    sprintf(buffer, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this is %d data&amp;#34;&lt;/span&gt;, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; send(sockfd, buffer, strlen(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
    }
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recv(sockfd, buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iret = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; iret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
    }
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;receive &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;4重复操作3直至数据发送完毕&#34;&gt;4、重复操作（3），直至数据发送完毕&lt;/h4&gt;
&lt;h4 id=&#34;5释放socket&#34;&gt;5、释放socket&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;close(sockfd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;代码-1&#34;&gt;代码&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;netdb.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;argv[]) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (argc &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) {
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Using client port&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Example: ./client 127.0.0.1 5005&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; sockfd;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((sockfd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket(AF_INET, SOCK_STREAM, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;socket&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hostent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; hostcon;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((hostcon &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gethostbyname(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;gethostbyname failed&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        close(sockfd);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr_in&lt;/span&gt; servaddr;
    memset(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr));
    servaddr.sin_family &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AF_INET;
    servaddr.sin_port &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; htons(atoi(argv[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]));
    memcpy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr.sin_addr, hostcon&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_addr, hostcon&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;h_length);
    &lt;span style=&#34;color:#75715e&#34;&gt;// 3    
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (connect(sockfd, (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sockaddr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;servaddr, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(servaddr)) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;connect&amp;#34;&lt;/span&gt;);
        close(sockfd);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; iret;
        memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
        sprintf(buffer, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;this is %d data&amp;#34;&lt;/span&gt;, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; send(sockfd, buffer, strlen(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            perror(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send&amp;#34;&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;send: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
        memset(buffer, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((iret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; recv(sockfd, buffer, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(buffer), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
            cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iret = &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; iret &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
        }
        cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;receive &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; buffer &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// 5
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    close(sockfd);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;运行结果&#34;&gt;运行结果&lt;/h2&gt;
&lt;p&gt;在工程目录中打开两个终端，在编译后通过命令&lt;code&gt;./server 5005&lt;/code&gt;启动服务器，之后在另一个终端通过命令&lt;code&gt;./client 127.0.0.1 5005&lt;/code&gt;运行客户端，最终结果呈现如下。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621cca3c2ab3f51d91db196d.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621cca3c2ab3f51d91db196d.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;[1] &lt;a class=&#34;link&#34; href=&#34;https://www.freecplus.net/0047ac4059b14d52bcc1d4df6ae8bb83.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;网络通信基础socket&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/dosthing/article/details/80383817&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hostent实例讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/will130/article/details/53326740&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sockaddr和sockaddr_in详解&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>应用层协议——HTTP</title>
        <link>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</link>
        <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</guid>
        <description>&lt;h2 id=&#34;http协议概述&#34;&gt;HTTP协议概述&lt;/h2&gt;
&lt;h3 id=&#34;概况&#34;&gt;概况&lt;/h3&gt;
&lt;p&gt;Web的应用层协议是超文本传输协议（HTTP）。HTTP协议由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话。&lt;/p&gt;
&lt;p&gt;HTTP定义了Web页面的方式，以及服务器向客户传送Web页面的方式。并 &lt;strong&gt;使用TCP作为它的支撑运输协议&lt;/strong&gt; 。HTTP客户首先发起一个与服务器的TCP链接。连接建立，彼此之间就可以通过 &lt;strong&gt;套接字接口&lt;/strong&gt; 访问TCP。从而利用套接字接口接受和发送HTTP报文。通信过程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/620cf0272ab3f51d91719a50.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/620cf0272ab3f51d91719a50.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于TCP为HTTP提供可靠数据传输服务，因此每个报文都能完整地到达服务器或客户，HTTP协议不关心TCP从网络种如何处理报文的各种问题，也不用担心数据丢失。但又由于服务器只为客户服务，并不存储任何关于客户的状态信息，因此HTTP协议是一个 &lt;strong&gt;无状态协议&lt;/strong&gt; ，如果需要保存客户的登录信息，则 &lt;em&gt;需要引入相关技术来记录状态，如Cookie&lt;/em&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;持续和非持续连接&#34;&gt;持续和非持续连接&lt;/h3&gt;
&lt;p&gt;在实际情况中，客户可能会发出一系列请求并且服务器会对每个请求进行响应。而这种客户-服务器的交互是经过TCP进行的，因此这些请求是经过单独的TCP连接还是经过相同的TCP连接就是这种交互方式的关键问题。也因此诞生了持续和非持续的HTTP连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非持续连接：&lt;/strong&gt; 使用非持续连接，每个TCP连接在服务器 &lt;strong&gt;发送一个对象后就关闭&lt;/strong&gt; （对象即HTML文件以及网页图像等），每个TCP连接只传输一个请求报文和一个响应报文。&lt;/p&gt;
&lt;p&gt;非持续连接有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须为每个请求的对象建立和维护一个全新的连接。对于这样的连接要分配TCP缓冲区和保持TCP变量。造成服务器负担。&lt;/li&gt;
&lt;li&gt;每个对象经受两倍的RTT交付时间，即一个RTT用于创建，一个RTT用于请求和接受.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;持续连接：&lt;/strong&gt; 服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送，而如果一条连接经过一定时间间隔（配置好的超时间隔）仍未被使用，HTTP服务器就应该关闭这个连接。&lt;/p&gt;
&lt;h3 id=&#34;http连接流程&#34;&gt;HTTP连接流程&lt;/h3&gt;
&lt;p&gt;（1）、 &lt;strong&gt;客户端连接到Web服务器。&lt;/strong&gt; 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80端口），建立一个TCP套接字连接。&lt;/p&gt;
&lt;p&gt;（2）、 &lt;strong&gt;发送HTTP请求。&lt;/strong&gt; 通过TCP套接字，客户端向HTTP服务器发送一个文本的请求报文。&lt;/p&gt;
&lt;p&gt;（3）、 &lt;strong&gt;服务器接受请求并返回HTTP响应。&lt;/strong&gt; Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。&lt;/p&gt;
&lt;p&gt;（4）、 &lt;strong&gt;释放TCP连接。&lt;/strong&gt; 若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭TCP连接并释放。反之若为keepalive，则TCP连接会保持一段时间，在这段时间内可以继续接受请求和响应。&lt;/p&gt;
&lt;p&gt;（5）、 &lt;strong&gt;客户端浏览器解析HTML内容。&lt;/strong&gt; 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取相应的HTML，根据HTML语法对其进行格式化，并在浏览器窗口显示。&lt;/p&gt;
&lt;h2 id=&#34;http报文&#34;&gt;HTTP报文&lt;/h2&gt;
&lt;h3 id=&#34;http请求报文&#34;&gt;HTTP请求报文&lt;/h3&gt;
&lt;p&gt;请求报文格式如下图。其中第一行称为 &lt;strong&gt;请求行&lt;/strong&gt; ，其后继的行称为 &lt;strong&gt;首部行&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以区包括GET、POST、HEAD、PUT和DELETE。这些请求方法将会在下文讲述。&lt;/p&gt;
&lt;p&gt;首部行则会包含Host字段，Connection字段以及User-agent字段等。分别指明了对象所在的主机、是否使用持续连接以及用户代理（发送请求的浏览器类型）。其中Host首部行则是Web代理高速缓存所要求的。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/620cfc842ab3f51d91860c6e.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/620cfc842ab3f51d91860c6e.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;http响应报文&#34;&gt;HTTP响应报文&lt;/h3&gt;
&lt;p&gt;响应报文的格式如下图。分为 &lt;strong&gt;状态行&lt;/strong&gt; ， &lt;strong&gt;首部行&lt;/strong&gt; 以及 &lt;strong&gt;实体体&lt;/strong&gt; 三个部分。实体体为报文的主要部分，为所请求的对象本身。同样在首部行会包含一些字段。例如：Date：指示发送该报文的日期和时间；Server：指示发送的服务器；Last-Modified：最后修改的日期和时间等。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/620cfbbc2ab3f51d9184bfb8.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/620cfbbc2ab3f51d9184bfb8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;http状态码&#34;&gt;HTTP状态码&lt;/h2&gt;
&lt;p&gt;由上述HTTP响应报文可以得出，在状态行中包含状态码字段，这个字段将指示请求的结果。可以将状态码分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1xx： &lt;strong&gt;指示信息&lt;/strong&gt; ，表示请求已接收，继续处理&lt;/li&gt;
&lt;li&gt;2xx： &lt;strong&gt;成功&lt;/strong&gt; ，表示请求已被成功接收、理解、接受&lt;/li&gt;
&lt;li&gt;3xx： &lt;strong&gt;重定向&lt;/strong&gt; ，要完成请求必须进行进一步的操作&lt;/li&gt;
&lt;li&gt;4xx： &lt;strong&gt;客户端错误&lt;/strong&gt; ，请求有语法错误或请求无法实现&lt;/li&gt;
&lt;li&gt;5xx： &lt;strong&gt;服务器端错误&lt;/strong&gt; ，服务器未能实现合法请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的状态码如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 OK：请求成功，信息在返回的响应报文中。&lt;/li&gt;
&lt;li&gt;301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL&lt;/li&gt;
&lt;li&gt;400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。&lt;/li&gt;
&lt;li&gt;404 Not Found：被请求的文档不在服务器上。&lt;/li&gt;
&lt;li&gt;505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的状态码及其对应短语可以参考&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/http/http-status-codes.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;此网址&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;http请求方法&#34;&gt;HTTP请求方法&lt;/h2&gt;
&lt;p&gt;HTTP1.0定义了三种请求方法：GET、POST和HEAD。&lt;/p&gt;
&lt;p&gt;HTTP1.1新增了五种请求方法：OPTIONS、PUT、DELETE、TRACE和CONNECT方法&lt;/p&gt;
&lt;p&gt;每种方法的特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET。&lt;/strong&gt;  请求指定的页面信息，并返回实体主体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HEAD。&lt;/strong&gt; 类似于GET请求，只不过返回的响应中没有主体内容，用于获取报头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST。&lt;/strong&gt; 向指定资源提交提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT。&lt;/strong&gt; 从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE。&lt;/strong&gt; 请求服务器删除指定的页面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CONNECT。&lt;/strong&gt; HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OPTIONS。&lt;/strong&gt; 允许客户端查看服务器的性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TRACE。&lt;/strong&gt; 回显服务器收到的请求，主要用于测试或诊断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get和post请求的区别&#34;&gt;GET和POST请求的区别&lt;/h3&gt;
&lt;p&gt;（1）、 &lt;strong&gt;GET提交：&lt;/strong&gt; 请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以&lt;code&gt;?&lt;/code&gt;分割URL和传输数据，多个参数用&lt;code&gt;&amp;amp;&lt;/code&gt;连接；例如：&lt;code&gt;login.action?name=hyddd&amp;amp;password=idontknow&amp;amp;verify=%E4%BD%A0%E5%A5%BD&lt;/code&gt;。如果数据是英文字母/数字，原样发送，如果是空格，转换为&lt;code&gt;+&lt;/code&gt;，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 &lt;strong&gt;POST提交：&lt;/strong&gt; 把提交的数据放置在是HTTP包的包体中。&lt;/p&gt;
&lt;p&gt;也即 &lt;strong&gt;GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）、传输数据的大小：首先 &lt;strong&gt;HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;而在实际的开发中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET：&lt;/strong&gt; 特定浏览器和服务器对URL长度有限制，例如：IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POST：&lt;/strong&gt; 由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对POST提交数据大小进行限制，Apache、IIS6都有各自的配置。&lt;/p&gt;
&lt;p&gt;（3）、安全性&lt;/p&gt;
&lt;p&gt;POST的安全性要比GET的安全性高。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存；其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击&lt;/p&gt;
&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;
&lt;h3 id=&#34;http的不足&#34;&gt;HTTP的不足&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，因此有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性，所以有可能已遭篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;https介绍&#34;&gt;HTTPS介绍&lt;/h3&gt;
&lt;p&gt;HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer， &lt;strong&gt;安全套接层&lt;/strong&gt; ）或TLS（Transport Layer Security， &lt;strong&gt;安全传输协议&lt;/strong&gt; ）的组合使用，加密HTTP通信内容。属于通信加密，即在整个通信线路中加密。如图&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/620da6e52ab3f51d916d0424.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/620da6e52ab3f51d916d0424.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;HTTPS采用 &lt;strong&gt;共享密钥加密（对称）&lt;/strong&gt; 和 &lt;strong&gt;公开密钥加密（非对称）&lt;/strong&gt; 两者并用的混合加密机制，若密钥能够实现安全交换，那么有可能仅考虑使用公开密钥来加密通信。但是公开密钥加密相对于共享密钥加密处理速度较慢。因此可以在交换密钥阶段使用 &lt;strong&gt;公开密钥&lt;/strong&gt; 加密方式，之后建立通信交换报文阶段则使用 &lt;strong&gt;共享密钥&lt;/strong&gt; 加密方式。&lt;/p&gt;
&lt;p&gt;HTTPS握手流程简单描述如下：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/620dabdc2ab3f51d917398df.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/620dabdc2ab3f51d917398df.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（1）、浏览器将自己支持的一套加密规则发送给网站 &lt;em&gt;（服务器获得浏览器公钥）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（2）、网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥等信息 &lt;em&gt;（浏览器获得服务器公钥）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（3）、获得网站证书后浏览器需要进行以下操作&lt;/p&gt;
&lt;p&gt;（a）、验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。&lt;/p&gt;
&lt;p&gt;（b）、如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。&lt;/p&gt;
&lt;p&gt;（c）、使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。&lt;/p&gt;
&lt;p&gt;（4）、网站接受浏览器发来的数据之后要做以下的操作：&lt;/p&gt;
&lt;p&gt;（a）、使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。&lt;/p&gt;
&lt;p&gt;（b）、使用密码加密一段握手消息，发送给浏览器。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>春招 | 知识点留档</title>
        <link>https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
        <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/%E6%98%A5%E6%8B%9B-%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
        <description>&lt;p&gt;春节已然过去了，处于人生的又一个十字路口且充满后顾之忧的我决定开始准备春招，时间看着是比较紧的，我也不知道自己最后能够准备到什么程度。&lt;/p&gt;
&lt;h2 id=&#34;1重载隐藏重写覆盖三者的区别&#34;&gt;1、重载、隐藏、重写（覆盖）三者的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;重载：&lt;strong&gt;是指同一可访问区内被声明的几个具有&lt;/strong&gt;不同参数列&lt;/strong&gt;（参数的类型、个数、顺序不同）的同名函数，根据参数列表确定调用哪个函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏：&lt;strong&gt;指的是派生类类型的对象、指针引用访问基类和派生类&lt;/strong&gt;都有&lt;/strong&gt;的同名函数时 &lt;em&gt;（只要求同名，不管参数列表是否相同）&lt;/em&gt;，访问的是派生类的函数，即隐藏了基类的同名函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重写（覆盖）：&lt;strong&gt;是&lt;/strong&gt;指派生类&lt;/strong&gt;中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。&lt;/p&gt;
&lt;p&gt;此外，重载的参数不同，函数体不同；隐藏的参数可以不同，函数体不同；重写或覆盖仅仅函数体不同。&lt;/p&gt;
&lt;h3 id=&#34;三者更为深入的一些问题&#34;&gt;三者更为深入的一些问题&lt;/h3&gt;
&lt;h4 id=&#34;11-重载为什么改变参数就可以实现调用不同函数&#34;&gt;1.1 重载为什么改变参数就可以实现调用不同函数？&lt;/h4&gt;
&lt;p&gt;因为C++在编译的时候会对函数进行重命名，保证函数命名的唯一性，而函数的参数列表不同便会导致函数被命名为不同的函数。&lt;/p&gt;
&lt;h4 id=&#34;12-构造函数可以被重载吗析构函数呢&#34;&gt;1.2 构造函数可以被重载吗？析构函数呢？&lt;/h4&gt;
&lt;p&gt;构造函数可以被重载，因为可以存在有参和无参的构造函数；析构函数不能被重载，因为析构函数只能有一个并且不带参数。&lt;/p&gt;
&lt;h2 id=&#34;2new和malloc的区别&#34;&gt;2、new和malloc的区别&lt;/h2&gt;
&lt;p&gt;据说是C++的经典问题，在综合了网络上的一些博文后，得出以下几点不同。&lt;/p&gt;
&lt;p&gt;（1）、&lt;strong&gt;申请内存所在区域。&lt;/strong&gt;&lt;code&gt;new&lt;/code&gt;操作符从自由存储区 &lt;em&gt;（不仅可以是堆还可以是静态存储区）&lt;/em&gt; 上为对象动态分配内存，而&lt;code&gt;malloc&lt;/code&gt;从堆上分配内存，这块区域是操作系统维护的一块特殊内存，用于程序动态分配。&lt;/p&gt;
&lt;p&gt;（2）、&lt;strong&gt;返回类型。&lt;/strong&gt;&lt;code&gt;new&lt;/code&gt;操作符返回的是对象类型指针，不需要进行强制转换；&lt;code&gt;malloc&lt;/code&gt;内存分配成功则是返回&lt;code&gt;void*&lt;/code&gt;，需要通过强制类型转换成指定类型。&lt;/p&gt;
&lt;p&gt;（3）、&lt;strong&gt;内存分配失败时的返回值。&lt;/strong&gt;&lt;code&gt;new&lt;/code&gt;内存分配失败时，会抛出&lt;code&gt;bad_alloc&lt;/code&gt;异常，不会返回&lt;code&gt;NULL&lt;/code&gt;，&lt;code&gt;malloc&lt;/code&gt;分配内存失败时返回&lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（4）、&lt;strong&gt;是否需要指定内存大小。&lt;/strong&gt; 使用&lt;code&gt;new&lt;/code&gt;操作符时进行内存分配时无需指定内存块的大小，使用&lt;code&gt;malloc&lt;/code&gt;需要显式的指定内存的大小。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {...}
A &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; A;
A &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (A&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)malloc(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(A));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（5）、&lt;strong&gt;是否调用构造函数。&lt;/strong&gt; 使用&lt;code&gt;new&lt;/code&gt;操作符分配对象内存时经历如下的几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;·调用&lt;code&gt;operator new&lt;/code&gt;函数（数组是&lt;code&gt;operator new[]&lt;/code&gt;）来分配内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;·编译器运行相应的构造函数创建对象，并赋初值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;·返回指向这个对象的指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;delete&lt;/code&gt;操作符释放内存空间时会经历如下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;·调用对象的析构函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;·编译器调用&lt;code&gt;operator delete&lt;/code&gt;（&lt;code&gt;operator delete[]&lt;/code&gt;）释放内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;malloc&lt;/code&gt;分配内存则不会调用构造函数&lt;/p&gt;
&lt;p&gt;（6）、&lt;strong&gt;对数组的处理。&lt;/strong&gt; C++提供了&lt;code&gt;new []&lt;/code&gt;和&lt;code&gt;delete []&lt;/code&gt;来专门处理数组类型，而malloc需要自己指定数组的大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)malloc(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;// 分配一个十个int大小的数组
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（7）、&lt;strong&gt;是否能够重新分配内存。&lt;/strong&gt; 使用&lt;code&gt;malloc&lt;/code&gt;分配内存后，如果在使用过程中发现内存不足，可以使用&lt;code&gt;realloc&lt;/code&gt;函数进行内存的重新分配内存（先判断当前指针所指内存是否有足够的的连续空间，如果有，原地扩大可分配的地址，并且返回原来的指针；如果空间不够，先按照指定大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存）。&lt;code&gt;new&lt;/code&gt;没有扩充内存的配套操作&lt;/p&gt;
&lt;p&gt;（8）、&lt;strong&gt;客户处理内存分配不足。&lt;/strong&gt;&lt;code&gt;new&lt;/code&gt;会有异常机制，而&lt;code&gt;malloc&lt;/code&gt;只能返回&lt;code&gt;NULL&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;3虚函数&#34;&gt;3、虚函数&lt;/h2&gt;
&lt;p&gt;虚函数一般在继承下发挥作用，基类声明一个虚函数，子类重载这一函数，这样当使用基类指针指向子类，并希望调用这个函数时，得到的就是子类重载过的函数。（在多态中还会有关于虚函数的讲解），通过使用虚函数来完成&lt;strong&gt;运行时决议&lt;/strong&gt;，与传统的编译时决定有本质区别。&lt;/p&gt;
&lt;p&gt;虚函数的实现是由两个部分组成的，虚函数指针和虚函数表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;31虚函数指针&#34;&gt;3.1、虚函数指针&lt;/h3&gt;
&lt;p&gt;本质上就是一个指向函数的指针，指向用户定义的虚函数。在一个被实例化的对象中，它总是被存放在该对象的地址首位。 &lt;strong&gt;只有拥有虚函数的类才会拥有虚函数指针&lt;/strong&gt; ，每个虚函数也都会对应一个虚函数指针。&lt;/p&gt;
&lt;h3 id=&#34;32ab两个类类中有虚函数c继承ab有几张虚函数表&#34;&gt;3.2、A、B两个类，类中有虚函数。C继承AB，有几张虚函数表？&lt;/h3&gt;
&lt;p&gt;两张，多继承就会有多个虚函数表，因为每个父类的虚函数是不同的，指针也是不同的。如果公用一张虚函数表，就分不清子类到底实例化的哪个基类函数。&lt;/p&gt;
&lt;h3 id=&#34;33析构函数可以是虚函数吗&#34;&gt;3.3、析构函数可以是虚函数吗？&lt;/h3&gt;
&lt;p&gt;析构函数必须是虚函数。因为如果不是虚函数，&lt;strong&gt;当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4什么是多态机制&#34;&gt;4、什么是多态机制&lt;/h2&gt;
&lt;p&gt;面向对象的三大特征：封装，继承，多态。&lt;/p&gt;
&lt;p&gt;多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。&lt;strong&gt;运行时的多态则和虚函数、继承有关。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;深入&#34;&gt;深入&lt;/h3&gt;
&lt;h4 id=&#34;31多态底层的实现机制&#34;&gt;3.1、多态底层的实现机制&lt;/h4&gt;
&lt;p&gt;利用虚函数表，先构建一个基类，然后在&lt;strong&gt;基类的构造函数中会建立虚函数表&lt;/strong&gt;，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。&lt;/p&gt;
&lt;p&gt;虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在&lt;code&gt;.rdata&lt;/code&gt;只读数据段。&lt;/p&gt;
&lt;h4 id=&#34;32父类构造函数中是否可以调用虚函数&#34;&gt;3.2、父类构造函数中是否可以调用虚函数&lt;/h4&gt;
&lt;p&gt;可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。这是因为在定义子类对象的时候，会先调用父类的构造函数，&lt;strong&gt;而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存&lt;/strong&gt;，C++标准规范中规定了在这种情况下，**即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。**所以使用的是静态绑定，调用了父类的函数。&lt;/p&gt;
&lt;h4 id=&#34;33构造函数可以是虚函数吗&#34;&gt;3.3、构造函数可以是虚函数吗？&lt;/h4&gt;
&lt;p&gt;不可以，因为虚函数存在的 &lt;strong&gt;唯一目的就是为了多态。&lt;/strong&gt; 而子类并不继承父类的构造函数，所以没有使父类构造函数变成虚函数的必要。另一方面，构造函数为类对象初始化了内存空间，里面保存了指向虚函数的指针，如果构造函数是虚函数，导致没有实例化对象，也就没有内存空间，更不会有虚函数。&lt;/p&gt;
&lt;h4 id=&#34;34静态函数可以是虚函数吗&#34;&gt;3.4、静态函数可以是虚函数吗？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt;成员不属于任何类对象或实例，所以即使给&lt;code&gt;static&lt;/code&gt;函数加上&lt;code&gt;virtual&lt;/code&gt;也是没有任何意义的。&lt;/li&gt;
&lt;li&gt;静态与非静态成员函数之间有一个主要区别。那就是静态成员函数&lt;strong&gt;没有&lt;code&gt;this&lt;/code&gt;指针&lt;/strong&gt;，所以无法访问&lt;code&gt;vptr&lt;/code&gt;，进而不能访问虚函数表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5指针和引用的区别&#34;&gt;5、指针和引用的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指针：&lt;/strong&gt; 指针是一个变量，用于保存另一个变量的地址，指针需要用&lt;code&gt;*&lt;/code&gt;来进行解引用，以获取它指向的内存地址上的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用：&lt;/strong&gt; 引用是一个已经存在的变量的别名，但引用也是通过存储变量的地址来实现对变量的修改的&lt;/p&gt;
&lt;p&gt;两者的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用必须&lt;strong&gt;定义时初始化&lt;/strong&gt;，不能像指针一样，指针可以定义后视情况初始化&lt;/li&gt;
&lt;li&gt;引用本身、就不能改变指向因此不存在引用常量（&lt;code&gt;int &amp;amp;const r = a&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;指针可以有多级，但是引用只能有一级&lt;/li&gt;
&lt;li&gt;指针的&lt;code&gt;++&lt;/code&gt;、&lt;code&gt;--&lt;/code&gt;代表下一个数据，而引用的&lt;code&gt;++&lt;/code&gt;、&lt;code&gt;--&lt;/code&gt;则代表数据本身的修改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof(引用)&lt;/code&gt;得到的是所指向的变量（对象）的大小，而&lt;code&gt;sizeof(指针)&lt;/code&gt;得到的是指针本身的大小&lt;/li&gt;
&lt;li&gt;当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会产生一个临时变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6static关键字&#34;&gt;6、static关键字&lt;/h2&gt;
&lt;h3 id=&#34;面向过程的static&#34;&gt;面向过程的static&lt;/h3&gt;
&lt;p&gt;（1）、&lt;strong&gt;函数中的静态变量。&lt;strong&gt;当变量声明为&lt;code&gt;static&lt;/code&gt;时，其空间在程序的生命周期内分配，被存放在&lt;/strong&gt;全局数据区&lt;/strong&gt;。即使多次调用此函数，静态变量的空间也只&lt;strong&gt;分配一次&lt;/strong&gt;，前一次调用的变量值通过下一次调用传递。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;静态变量和全局变量的存储区域是一起的，一旦静态区的内存被分配，静态区的内存直到程序全部结束之后才会被释放。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;面向对象的static&#34;&gt;面向对象的static&lt;/h3&gt;
&lt;p&gt;（1）、&lt;strong&gt;类中的静态变量。&lt;strong&gt;声明为&lt;code&gt;static&lt;/code&gt;的变量只能被初始化一次，而且&lt;/strong&gt;必须初始化&lt;/strong&gt;，且类中的静态变量由&lt;strong&gt;对象共享&lt;/strong&gt;，类中的静态成员变量必须在类内声明，在类外定义（&lt;code&gt;const&lt;/code&gt;修饰可以直接定义）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num;  &lt;span style=&#34;color:#75715e&#34;&gt;// 类内声明
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; num_2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// const可以在声明时就初始化
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 类外初始化
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
    A a;
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a.num; &lt;span style=&#34;color:#75715e&#34;&gt;// 输出10
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;num; &lt;span style=&#34;color:#75715e&#34;&gt;// 输出10
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;（2）、&lt;strong&gt;类中的静态成员函数。&lt;/strong&gt; 静态成员函数不依赖于类的对象。允许使用&lt;code&gt;.&lt;/code&gt;和类名来调用静态成员函数。&lt;strong&gt;静态成员函数只能访问静态成员变量或其它静态成员函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外还有以下特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static成员变量不占用对象的内存，而是在所有对象之外开辟内存&lt;/li&gt;
&lt;li&gt;static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在&lt;strong&gt;类外初始化时分配&lt;/strong&gt;，即没有在类外初始化的静态成员变量不能使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7const关键字&#34;&gt;7、const关键字&lt;/h2&gt;
&lt;p&gt;作用：被其修饰的值不能改变，是只读变量。必须在定义时就赋初值。&lt;/p&gt;
&lt;p&gt;const关键字还可以用来修饰指针，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p; &lt;span style=&#34;color:#75715e&#34;&gt;// 常量指针
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; p; &lt;span style=&#34;color:#75715e&#34;&gt;// 指针常量 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;常量指针&#34;&gt;常量指针&lt;/h3&gt;
&lt;p&gt;底层const，指针指向的值被指针限定住，不能通过指针改变指向的值。但此时可以修改指针的指向。&lt;/p&gt;
&lt;h3 id=&#34;指针常量&#34;&gt;指针常量&lt;/h3&gt;
&lt;p&gt;顶层const，指针指向的地址不能修改，并且&lt;strong&gt;声明时必须初始化&lt;/strong&gt;，但是指针指向的地址的内容可以通过指针修改。&lt;/p&gt;
&lt;h2 id=&#34;8stl专题&#34;&gt;8、STL专题&lt;/h2&gt;
&lt;h3 id=&#34;1vector&#34;&gt;（1）、vector&lt;/h3&gt;
&lt;p&gt;可变大小的数组， &lt;strong&gt;支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;底层为动态数组，包括三个迭代器，&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;是已经被使用的空间范围，&lt;code&gt;end_of_storage&lt;/code&gt;是整块连续空间包括备用空间的尾部。&lt;/p&gt;
&lt;p&gt;当空间不够装下数据时，会&lt;strong&gt;自动申请另一片更大的空间&lt;/strong&gt;（1.5倍或者2倍），然后把原来的数据拷贝到新的内存空间，接着释放原来的内存空间，而当释放或者删除vector里面的数据时（&lt;code&gt;v.clear()&lt;/code&gt;），其存储空间不释放，仅仅是清空了里面的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;reserve和resize的区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;reserve：&lt;/strong&gt; 是直接扩充到已经确定的大小，可以减少开辟、释放空间的问题，提高效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resize：&lt;/strong&gt; 可以改变有效空间的大小，因此&lt;code&gt;capacity&lt;/code&gt;的大小也会随之改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;size和capacity的区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;size表示当前vector中有多少个元素，而capacity函数表示它已经分配的内存中可以容纳多少元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vector元素是否可以是引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vector的底层实现要求连续的 &lt;strong&gt;对象排列&lt;/strong&gt; ， &lt;strong&gt;引用并非对象&lt;/strong&gt; ，没有实际地址，因此元素不能是引用。&lt;/p&gt;
&lt;h3 id=&#34;2list&#34;&gt;（2）、list&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;list底层是一个&lt;strong&gt;双向链表&lt;/strong&gt;，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间，&lt;strong&gt;不支持随机存取&lt;/strong&gt;，适合需要大量的插入和删除操作的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一些函数操作：&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;list.unique()  &lt;span style=&#34;color:#75715e&#34;&gt;// 移除数值相同的连续元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;list.sort()  &lt;span style=&#34;color:#75715e&#34;&gt;// 对list进行排序，通常可以和上面的函数连用
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3deque&#34;&gt;（3）、deque&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;deque是一个双向开口的连续性空间（双端队列），在头尾两端插入都有理想的时间复杂度。但是&lt;strong&gt;整个空间并不是连续的，而是一段一段的&lt;/strong&gt;，为了维护其整体连续的假象，并提供随机存取的接口。设计了一个中控器，用来记录deque内部每一段连续空间的地址。类似于数据结构中的map。对象的&lt;code&gt;key&lt;/code&gt;值为地址，而&lt;code&gt;value&lt;/code&gt;则是对应的连续的地址空间。是一个动态数组，一旦需要扩容，就是在&lt;strong&gt;首尾配置一段定量连续空间。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4setmapmultisetmultimap&#34;&gt;（4）、set、map、multiset、multimap&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些容器的底层实现都是&lt;strong&gt;红黑树&lt;/strong&gt;。由于采用红黑树实现，因此在插入和删除时，都需要&lt;strong&gt;寻找结点&lt;/strong&gt;，因此会损失一定的效率。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于红黑树：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1、每个结点是红色或者是黑色&lt;/p&gt;
&lt;p&gt;2、根结点是黑色的&lt;/p&gt;
&lt;p&gt;3、每个叶结点是黑的&lt;/p&gt;
&lt;p&gt;4、如果一个结点是红的，那么它的两个孩子结点都是黑色&lt;/p&gt;
&lt;p&gt;5、每个结点到其子孙结点的所有路径上包含相同数目的黑色结点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器特点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;set与multiset容器会根据特定的排序准则&lt;strong&gt;自动将元素排序&lt;/strong&gt;，set中元素&lt;strong&gt;不允许重复&lt;/strong&gt;，multiset中&lt;strong&gt;元素允许重复&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;map与multimap容器则是以&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;组成的&lt;code&gt;pair&lt;/code&gt;作为元素，根据key的排序准则，自动将元素排序，在map中&lt;code&gt;key&lt;/code&gt;值&lt;strong&gt;不允许重复&lt;/strong&gt;，而multimap中key值&lt;strong&gt;可以重复&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;5unordered_mapunordered_set&#34;&gt;（5）、unordered_map、unordered_set&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;底层是一个&lt;strong&gt;防冗余&lt;/strong&gt;的哈希表（采用除留余数法）。能够尽可能的降低数据的存储和查找的时间，若产生哈希冲突，一般采用&lt;strong&gt;拉链法&lt;/strong&gt;来解决冲突&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;与map、set相比&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找速度比map、set快，通常为常数级别，但会&lt;strong&gt;消耗较多的内存&lt;/strong&gt;，且构造速度较慢。&lt;/p&gt;
&lt;h2 id=&#34;9c内存分区&#34;&gt;9、C++内存分区&lt;/h2&gt;
&lt;p&gt;在C++中分为五大内存分区，分别是 &lt;strong&gt;堆&lt;/strong&gt; 、 &lt;strong&gt;栈&lt;/strong&gt;  、 &lt;strong&gt;自由存储区&lt;/strong&gt; 、 &lt;strong&gt;全局/静态存储区&lt;/strong&gt; 和 &lt;strong&gt;常量存储区&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;栈：&lt;/strong&gt; 由编译器在 &lt;strong&gt;需要时分配&lt;/strong&gt;，在 &lt;strong&gt;不需要时自动清除&lt;/strong&gt; 的变量存储区。里面的变量通常是局部变量，函数参数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;堆：&lt;/strong&gt; 操作系统层面的术语，为&lt;code&gt;malloc&lt;/code&gt;等分配的内存块，用&lt;code&gt;free&lt;/code&gt;结束自己的生命周期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自由存储区：&lt;/strong&gt; C++层面上的术语，为&lt;code&gt;new&lt;/code&gt;分配的内存块，它们的释放编译器不进行管理，而是由应用程序控制，一般&lt;code&gt;new&lt;/code&gt;后需要&lt;code&gt;delete&lt;/code&gt;，如果没有释放，操作系统会在程序结束之后回收&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为 &lt;code&gt;new&lt;/code&gt; 的申请是调用 &lt;code&gt;malloc&lt;/code&gt; 的，自由存储区就和堆类似，但不等价&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局/静态存储区：&lt;/strong&gt; 全局变量和静态变量被分配到同一块内存中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束之后由系统释放。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常量存储区：&lt;/strong&gt; 一块特殊的存储区，存放 &lt;strong&gt;常量&lt;/strong&gt; ，这些常量不允许被修改，程序结束后由系统释放&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;10智能指针&#34;&gt;10、智能指针&lt;/h2&gt;
&lt;p&gt;在C++中，动态内存管理是用一对运算符（&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;）完成的。但是动态管理经常出现两种问题：一是忘记释放内存，会造成内存泄漏；另一是在尚有指针引用内存的情况下就释放了它，会导致产生引用非法内存的指针。因此引入了智能指针的概念。 &lt;strong&gt;智能指针负责自动释放所指向的对象，可以更安全的使用动态内存。&lt;/strong&gt; C++中存在三种类型的智能指针，分别为&lt;code&gt;shared_ptr&lt;/code&gt;、&lt;code&gt;weak_ptr&lt;/code&gt;以及&lt;code&gt;unique_ptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在创建智能指针时，必须提供额外的信息即指针可以指向的类型如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;;
shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;1shared_ptr&#34;&gt;（1）&lt;strong&gt;shared_ptr&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;其实就是对资源做引用计数——当引用计数为0时自动释放资源。可以使用&lt;code&gt;ptr.use_count()&lt;/code&gt;来获取当前的引用数。也可以实现对数组的引用，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;]);  &lt;span style=&#34;color:#75715e&#34;&gt;// 引用计数为1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; prt1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ptr;  &lt;span style=&#34;color:#75715e&#34;&gt;// 引用计数为2，ptr1和ptr共享资源
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; make_shared&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 这种做法较为高效。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
	ptr[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;智能指针在初始化时还可以指定删除器，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DeleteIntPtr&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; p;
	p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;
}
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; p(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;), DeleteIntPtr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;shared_ptr&lt;/code&gt;对象的内存开销要比裸指针和无自定义&lt;code&gt;deleter&lt;/code&gt;的&lt;code&gt;unique_ptr&lt;/code&gt;对象略大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;需要 &lt;strong&gt;维护的信息&lt;/strong&gt; 有两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向共享资源的指针&lt;/li&gt;
&lt;li&gt;引用计数等共享资源的控制信息——实际上是维护一个指向控制信息的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们实现一个shared_ptr时，其实现一般如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;;
std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; T);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/62106cd42ab3f51d9128008b.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/62106cd42ab3f51d9128008b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;shared_ptr&lt;/code&gt;时，要注意的时要避免 &lt;strong&gt;循环引用&lt;/strong&gt; ，循环引用会导致内存泄漏，经典的循环引用如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {
	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; bptr;
	&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;A() {
		cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A is deleted&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
	}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; {
	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; aptr;
	&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;B() {
		cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;B is deleted&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
	}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; TestPtr {
	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ap(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; A);
	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;B&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; bp(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; B);
	ap&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;bptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bp;
	bp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;aptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ap;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样两个指针最后都不会被删除，循环引用导致&lt;code&gt;ap&lt;/code&gt;和&lt;code&gt;bp&lt;/code&gt;的引用计数为2，在离开作用域之后两者的引用计数都为1，因此两个指针都不会被析构。&lt;/p&gt;
&lt;h3 id=&#34;2weak_ptr&#34;&gt;（2）weak_ptr&lt;/h3&gt;
&lt;p&gt;弱引用指针&lt;code&gt;weak_ptr&lt;/code&gt;是用来监视&lt;code&gt;shared_ptr&lt;/code&gt;的，不会使引用计数加1，因此可以通过&lt;code&gt;weak_ptr&lt;/code&gt;来解决循环引用的问题。（如可以B类的&lt;code&gt;shared_ptr&lt;/code&gt;成员改为&lt;code&gt;weak_ptr&lt;/code&gt;成员）它不管理shared_ptr内部的指针，主要使为了监视&lt;code&gt;shared_ptr&lt;/code&gt;的生命周期，不能操作资源。使用方法如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sp(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;));
weak_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; wp(sp);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同时weak_ptr还有一些特殊的方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;shared_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sp(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;));
weak_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; wp(sp);

wp.expired()  &lt;span style=&#34;color:#75715e&#34;&gt;// 判断所观测的资源是否已经被释放
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; spt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; wp.lock()  &lt;span style=&#34;color:#75715e&#34;&gt;// 获取所监视的shared_ptr
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/62109c352ab3f51d915791d8.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/62109c352ab3f51d915791d8.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;3unique_ptr&#34;&gt;（3）unique_ptr&lt;/h3&gt;
&lt;p&gt;unique_ptr是一个独占型的智能指针，它不允许其它的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。但是可以通过函数返回给其它的unique_ptr，这样它本身就不再拥有原来指针的所有权了。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ptr(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; T);
unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Otherptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;11函数指针和指针函数&#34;&gt;11、函数指针和指针函数&lt;/h2&gt;
&lt;h3 id=&#34;1指针函数&#34;&gt;（1）指针函数&lt;/h3&gt;
&lt;p&gt;简单来说，就是一个返回指针的函数，本质是一个函数。声明格式为&lt;code&gt;*类型标识符 函数名(参数)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;;
A&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fun&lt;/span&gt;(params...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2函数指针&#34;&gt;（2）函数指针&lt;/h3&gt;
&lt;p&gt;本质是一个指针变量，该指针指向这个函数。声明格式为&lt;code&gt;类型标识符 (*函数名)()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;;
A (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fun)(params...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数指针需要把一个函数的地址赋值给它，具体示例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; y;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;fun)(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y);
fun &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; add;
fun &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;add;  &lt;span style=&#34;color:#75715e&#34;&gt;// 两种写法都行
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;可以不用取址符是因为函数名就代表函数的地址&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;12操作系统专题&#34;&gt;12、操作系统专题&lt;/h2&gt;
&lt;h3 id=&#34;121-操作系统特性&#34;&gt;12.1 操作系统特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;并发：&lt;/strong&gt; 同一段时间内多个程序执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享：&lt;/strong&gt; 系统中的资源可以被内存中多个并发执行的线程共同使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟：&lt;/strong&gt; 通过时分复用以及空分复用（如虚拟内存），把一个物理实体虚拟为多个&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步：&lt;/strong&gt; 系统中的进程以走走停停的方式执行的，且以一种不可预知的速度推进&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;122-动态链接库与静态链接库&#34;&gt;12.2 动态链接库与静态链接库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态链接库一般为&lt;code&gt;.lib&lt;/code&gt;文件，在项目界面直接加入工程，程序编译时，将文件中的代码加入到程序中，不能手动移除此文件的代码。&lt;/li&gt;
&lt;li&gt;动态链接库一般为&lt;code&gt;.dll&lt;/code&gt;文件，是程序运行时动态装入内存模块，程序运行时可以随意加载和移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;123-协程&#34;&gt;12.3 协程&lt;/h3&gt;
&lt;p&gt;协程是一种比 &lt;strong&gt;线程更加轻量级&lt;/strong&gt; 的存在，正如一个进程可以拥有多个线程一样， &lt;strong&gt;一个线程也可以拥有多个协程&lt;/strong&gt; 。协程 &lt;strong&gt;不被操作系统内核管理&lt;/strong&gt; ，完全由程序所控制，运行在 &lt;strong&gt;用户态&lt;/strong&gt; 。协程不是进程也不是线程，而 &lt;strong&gt;是一个特殊的函数&lt;/strong&gt; ，这个函数可以在某个地方挂起，并且可以重新在挂起处外运行。&lt;/p&gt;
&lt;h2 id=&#34;13常见的设计模式&#34;&gt;13、常见的设计模式&lt;/h2&gt;
&lt;h3 id=&#34;131-工厂模式&#34;&gt;13.1 工厂模式&lt;/h3&gt;
&lt;h4 id=&#34;1简单工厂&#34;&gt;（1）简单工厂&lt;/h4&gt;
&lt;p&gt;简单工厂包含以下角色&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Factory：工厂角色，负责实现创建所有实例的内部逻辑&lt;/li&gt;
&lt;li&gt;Product：抽象产品角色，是所创建的所有对象的父类，负责描述所有实例所共有的公共接口&lt;/li&gt;
&lt;li&gt;ConcreteProduct：具体产品角色，是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e04a02ab3f51d91973b30.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e04a02ab3f51d91973b30.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;2工厂方法&#34;&gt;（2）工厂方法&lt;/h4&gt;
&lt;p&gt;工厂方法模式包含以下结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Product：抽象产品&lt;/li&gt;
&lt;li&gt;ConcreteProduct：具体产品&lt;/li&gt;
&lt;li&gt;Factory：抽象工厂&lt;/li&gt;
&lt;li&gt;ConcreteFactory：具体工厂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e06822ab3f51d919abd2b.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e06822ab3f51d919abd2b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;132-单例模式&#34;&gt;13.2 单例模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;只对外提供&lt;code&gt;getInstance&lt;/code&gt;方法，不提供任何构造函数&lt;/strong&gt; ，适用于 &lt;strong&gt;全局统一&lt;/strong&gt; 如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e06c42ab3f51d919b3ce2.png&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e06c42ab3f51d919b3ce2.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;133-装饰模式&#34;&gt;13.3 装饰模式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适合需要（通过配置，如：diamond）来动态增减对象功能的场景&lt;/strong&gt; 。装饰模式包含以下角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Component：抽象构件&lt;/li&gt;
&lt;li&gt;ConcreteComponent：具体构件&lt;/li&gt;
&lt;li&gt;Decorator：抽象装饰类&lt;/li&gt;
&lt;li&gt;ConcreteDecorator：具体装饰类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e082f2ab3f51d919de278.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e082f2ab3f51d919de278.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待。&lt;/li&gt;
&lt;li&gt;尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中，可以通过装饰类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;134-策略模式&#34;&gt;13.4 策略模式&lt;/h3&gt;
&lt;p&gt;适用于一个系统需要动态地在几种可替换算法中选择一种。不希望使用者关心算法细节，将具体算法封装进策略类中。包含以下几个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Context：环境类&lt;/li&gt;
&lt;li&gt;Strategy：抽象策略类&lt;/li&gt;
&lt;li&gt;ConcreteStrategy：具体策略类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e0a372ab3f51d91a19da2.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e0a372ab3f51d91a19da2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;135-代理模式&#34;&gt;13.5 代理模式&lt;/h3&gt;
&lt;p&gt;包括远程代理，虚拟代理等多种代理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e19ae2ab3f51d91b9855c.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e19ae2ab3f51d91b9855c.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;136-观察者模式&#34;&gt;13.6 观察者模式&lt;/h3&gt;
&lt;p&gt;适用于一对多的的业务场景，一个对象发生变更，会触发N个对象做相应处理的场景。例如：订单调度通知，任务状态变化等。包含以下角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Subject：目标&lt;/li&gt;
&lt;li&gt;ConcreteSubject：具体目标&lt;/li&gt;
&lt;li&gt;Observer：观察者&lt;/li&gt;
&lt;li&gt;ConcreteObserver：具体观察者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/621e1a2f2ab3f51d91b9f6a0.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/621e1a2f2ab3f51d91b9f6a0.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>LeetCode 二叉搜索树与双向链表</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
        <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&lt;/p&gt;
&lt;p&gt;为了让您更好地理解问题，以下面的二叉搜索树为例：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png&#34; &gt;
		&lt;img src=&#34;https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。&lt;/p&gt;
&lt;p&gt;下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png&#34; &gt;
		&lt;img src=&#34;https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。&lt;/p&gt;
&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;题目给出的是一棵二叉搜索树，而要我们整理成一个升序的双向链表，可以很自然的想到二叉搜索树的中序遍历即为升序序列。面对双向链表，我们还需要建立相邻结点之间的关系，因此需要设置前驱结点&lt;code&gt;pre&lt;/code&gt;和当前结点&lt;code&gt;cur&lt;/code&gt;两个指针来组织结点之间的关系。（具体即为&lt;code&gt;pre-&amp;gt;right = cur&lt;/code&gt;和&lt;code&gt;cur-&amp;gt;left = pre&lt;/code&gt;），最后则是连接头结点和尾结点。&lt;/p&gt;
&lt;h3 id=&#34;中序遍历流程&#34;&gt;中序遍历流程&lt;/h3&gt;
&lt;p&gt;令&lt;code&gt;recur&lt;/code&gt;为中序遍历函数&lt;/p&gt;
&lt;p&gt;1、终止条件：当&lt;code&gt;cur&lt;/code&gt;结点为空时，直接返回，说明此时已经越过了叶节点&lt;/p&gt;
&lt;p&gt;2、递归左子树，&lt;code&gt;recur（cur-&amp;gt;left）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、构建相邻结点之间的关系&lt;/p&gt;
&lt;p&gt;（a）、如果&lt;code&gt;pre&lt;/code&gt;指针为空，说明当前访问的结点为中序遍历的第一个结点，也就是双向链表的头结点，此时将当前结点&lt;code&gt;cur&lt;/code&gt;赋值给&lt;code&gt;head&lt;/code&gt;指针。&lt;/p&gt;
&lt;p&gt;（b）、如果&lt;code&gt;pre&lt;/code&gt;指针非空，需要建立两个结点之间的关系，即&lt;code&gt;pre-&amp;gt;right = cur&lt;/code&gt;和&lt;code&gt;cur-&amp;gt;left = pre&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（c）、更新前驱结点&lt;code&gt;pre&lt;/code&gt;，即&lt;code&gt;pre = cur&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4、递归右子树，&lt;code&gt;recur（cur-&amp;gt;right）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后在执行函数中，需要利用&lt;code&gt;head&lt;/code&gt;和&lt;code&gt;pre&lt;/code&gt;指针建立双向链表的头尾关系，即&lt;code&gt;head-&amp;gt;left = pre&lt;/code&gt;，&lt;code&gt;pre-&amp;gt;right = head&lt;/code&gt;，因为当递归完二叉搜索树时，&lt;code&gt;pre&lt;/code&gt;会指向中序的最后一个元素。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Definition for a Node.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;class Node {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;public:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    int val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    Node* left;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    Node* right;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    Node() {}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    Node(int _val) {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        val = _val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        left = NULL;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        right = NULL;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    }
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    Node(int _val, Node* _left, Node* _right) {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        val = _val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        left = _left;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;        right = _right;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;    }
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;};
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    Node &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;head, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pre;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;recur&lt;/span&gt;(Node &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;root) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        recur(root&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left);
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果pre为空，说明当前访问的是头结点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (pre) pre&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; root;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; head &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; root;
        root&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 修改当前的结点为前驱结点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        pre &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; root;
        recur(root&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right);
    }
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; treeToDoublyList(Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; root) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
        recur(root);
        head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre;
        pre&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; head;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 矩阵中的路径</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
        <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 二维字符网格 &lt;code&gt;board&lt;/code&gt; 和一个字符串单词 &lt;code&gt;word&lt;/code&gt; 。如果 &lt;code&gt;word&lt;/code&gt; 存在于网格中，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&lt;/p&gt;
&lt;p&gt;例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://assets.leetcode.com/uploads/2020/11/04/word2.jpg&#34; &gt;
		&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/11/04/word2.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：board = [[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]], word = &amp;quot;ABCCED&amp;quot;
输出：true
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：board = [[&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;],[&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;]], word = &amp;quot;abcd&amp;quot;
输出：false
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;这道题一开始想到的是使用BFS，但是细想发现BFS好像很难处理回溯的问题，应该采用DFS。然后，就是递归的痛了，也借这道题学习一下DFS的写法吧。&lt;/p&gt;
&lt;p&gt;**DFS：**即是暴力遍历矩阵的所有元素，来搜索一条可行的路径，通过递归，可以在一条路径中搜索到底，最后回溯到之前已经匹配的节点。&lt;/p&gt;
&lt;p&gt;**剪枝：**在DFS过程中如果当前的矩阵字符与字符串字符不等，可以直接回溯。或者路径已经访问过，可以直接跳过。&lt;/p&gt;
&lt;h3 id=&#34;dfs解析&#34;&gt;DFS解析&lt;/h3&gt;
&lt;p&gt;1、递归终止条件：&lt;/p&gt;
&lt;p&gt;（a）、返回true，当匹配到字符串的最后一个字符时，可以直接返回true（至于为什么可以这样返回，参看代码注释）&lt;/p&gt;
&lt;p&gt;（b）、返回false，如果矩阵的索引越界，当前矩阵的字符和字符串的字符不匹配，当前元素已经访问过了直接返回false&lt;/p&gt;
&lt;p&gt;2、递归过程&lt;/p&gt;
&lt;p&gt;（a）、选定当前元素，将当前元素标记为&lt;strong&gt;空字符&lt;/strong&gt;，表明当前元素已经访问过，防止走回头路。&lt;/p&gt;
&lt;p&gt;（b）、搜索下一个元素，向四个方向分别匹配字符，如果有一个方向可以匹配就继续递归这个方向的DFS算法，并返回true，否则返回false&lt;/p&gt;
&lt;p&gt;（c）、还原当前元素，需要在DFS算法退出之前，将&lt;strong&gt;空字符&lt;/strong&gt;还原为原来的字符，用于回溯时重新寻找路径，否则回溯将找不到正确路径。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; exist(vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; board, string word) {
        rows &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board.size();
        cols &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; board[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].size();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; rows; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cols; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;j) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dfs(board, word, i, j, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rows, cols;
    &lt;span style=&#34;color:#75715e&#34;&gt;// k为单词索引
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;board, string word, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果越界或者字符不相等，就停止递归
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; rows &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; cols &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; board[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; word[k]) 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 当进入这个判断条件时，会先判断是否相等，因此只要走到最后一个字符就可以返回true
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (k &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; word.size() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 将访问过的字符设为一个特殊字符，防止走回头路
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        board[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;;
        array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dx{&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;};
        array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dy{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; idx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;idx) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dfs(board, word, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dx[idx], j &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dy[idx], k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
            }
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 在退出dfs之前要恢复board，否则回溯将无法找到正确路径
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        board[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; word[k]; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 最长不含重复字符的子字符串</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
        <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;quot;abcabcbb&amp;quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;quot;bbbbb&amp;quot;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;这道题想通了发现也是一道比较常规的动态规划题，但是开始时没有考虑好的细节确实是折磨了我一阵。以及没有想到用哈希表处理属实比较蠢。&lt;/p&gt;
&lt;h3 id=&#34;动态规划&#34;&gt;动态规划&lt;/h3&gt;
&lt;p&gt;1、状态的定义，本题依旧需要一个一维的动态规划数组，&lt;code&gt;dp[i]&lt;/code&gt;则表示以第&lt;code&gt;i&lt;/code&gt;个字符为结尾的子字符串可以得到的最长的含不重复字符的子字符串长度。&lt;/p&gt;
&lt;p&gt;2、状态转移方程，首先我们需要固定右边界&lt;code&gt;i&lt;/code&gt;，也就是遍历时的索引，设与&lt;code&gt;s[i]&lt;/code&gt;相同且距离最近的字符为&lt;code&gt;s[pos]&lt;/code&gt;（&lt;code&gt;pos&lt;/code&gt;初始化为&lt;code&gt;-1&lt;/code&gt;。此时不重复字符子串长度应该是&lt;code&gt;i - pos&lt;/code&gt;，但是题目所求为最长，因此根据动态规划的思想就有以下的情况&lt;/p&gt;
&lt;p&gt;（a）、当$pos&amp;lt;0$时，说明在&lt;code&gt;s[i]&lt;/code&gt;的左侧没有与&lt;code&gt;s[i]&lt;/code&gt;相同的字符，那么&lt;code&gt;dp[i] = dp[i - 1] + 1&lt;/code&gt;（即最长长度等于遍历到前一字符的长度 + 1）&lt;/p&gt;
&lt;p&gt;（b）、当$dp[i - 1]&amp;lt;i - pos$时，说明重复的字符应该在当前最长非重复字符子串的区间外，即在这个子串的左边，此时&lt;code&gt;dp[i] = dp[i - 1] + 1&lt;/code&gt;，也就是之前的子串再加上当前的字符。&lt;/p&gt;
&lt;p&gt;（c）、当$dp[i - 1]&amp;gt;=i-pos$​时，说明此时重复的字符应该在当前最长的非重复字符子串的区间内，因此&lt;code&gt;dp[i] = i - pos&lt;/code&gt;，也就是在之前的子串中截取出非重复的部分。&lt;/p&gt;
&lt;p&gt;3、需要一个哈希表用来记录曾经出现过的字符的相对应的索引，每当遍历到一个重复字符时，便要将哈希表中的相应表项更新为当前的索引。&lt;/p&gt;
&lt;p&gt;由以上的分析可以看出，&lt;code&gt;dp[i]&lt;/code&gt;只由&lt;code&gt;dp[i - 1]&lt;/code&gt;决定，所以可以省略动态规划的数组，采用一个变量进行迭代即可，并求取此变量在这个过程中的最大值。&lt;/p&gt;
&lt;h3 id=&#34;双指针法滑动窗口&#34;&gt;双指针法（滑动窗口）&lt;/h3&gt;
&lt;p&gt;由于滑动窗口的代码写得比较少，当看到题解有滑动窗口时，便又学习了一下。&lt;/p&gt;
&lt;p&gt;首先要初始化&lt;code&gt;left = -1&lt;/code&gt;以及&lt;code&gt;right = 0&lt;/code&gt;两个指针，利用right指针进行遍历，并根据是否有重复的字符，以及是否为最长的子字符串来更改&lt;code&gt;left&lt;/code&gt;指针的位置。这种做法依旧需要一个哈希表来存储字符对应的索引。这样就会有以下两种情况。&lt;/p&gt;
&lt;p&gt;（a）、当&lt;code&gt;right&lt;/code&gt;指针对应的字符在哈希表中不存在时，可以直接增加&lt;code&gt;right&lt;/code&gt;指针的值，且子字符串长度为&lt;code&gt;right - left&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（b）、若&lt;code&gt;right&lt;/code&gt;指针对应的字符在哈希表中存在，那么需要将&lt;code&gt;left&lt;/code&gt;更改为当前的&lt;code&gt;left&lt;/code&gt;指针与哈希表中对应索引的最大值（这里很重要，如果没有取两者之间的最大值那么虽然可以避免在左右两个端点处重复，但可能会导致在字符串内存在重复字符）。&lt;/p&gt;
&lt;p&gt;在每次更新最长字符串的值之前都要更新哈希表中的相应表项。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*动态规划*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lengthOfLongestSubstring(string s) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;s.size()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (s.size() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 优先判断两种特殊情况
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.size();
        unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; um;  &lt;span style=&#34;color:#75715e&#34;&gt;// 用于存储字符的索引位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// temp用来存储上一次的dp值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pos;  &lt;span style=&#34;color:#75715e&#34;&gt;// 用来获取是否有当前字符的索引
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (um.count(s[i])) pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; um[s[i]];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            um[s[i]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;  &lt;span style=&#34;color:#75715e&#34;&gt;// 更新哈希表的索引
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pos) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pos);
            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(res, temp);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*滑动窗口*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lengthOfLongestSubstring(string s) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;s.size()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (s.size() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 优先判断两种特殊情况
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; um;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s.size();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;right) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (um.count(s[right])) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 表明这时候已经出现的重复的字符
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 这时候需要移动左指针
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(left, um[s[right]]);  &lt;span style=&#34;color:#75715e&#34;&gt;// 如果不取两者最大，那么会可能会导致字符串内重复
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            }
            um[s[right]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right;  &lt;span style=&#34;color:#75715e&#34;&gt;// 更新索引
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(res, right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; left);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 股票的最大利润</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
        <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;这道题首先可以采用暴力的求解方法，只要计算在某一天中，其后的每一天卖出的价钱所得的利润最大，依次遍历每一天，最终就可以求得最大利润，这样可以得到的时间复杂度为$$(n-1)+(n-2)+&amp;hellip;+2+1=n(n-1)/2$$也就是$O(n^2)$，不出所料，在这种解法中，你需要将一些冗余的操作去除，才能通过力扣的判题机。于是就有了下面的解法，也就是动态规划。&lt;/p&gt;
&lt;h3 id=&#34;动态规划思路&#34;&gt;动态规划思路&lt;/h3&gt;
&lt;p&gt;1、状态的定义，首先需要声明一个动态规划数组&lt;code&gt;dp&lt;/code&gt;，其中&lt;code&gt;dp[i]&lt;/code&gt;表示以第&lt;code&gt;i&lt;/code&gt;天为最后一天的子数组所能获得的最大利润。&lt;/p&gt;
&lt;p&gt;2、状态转移方程，由于股票只能买卖一次，因此&lt;code&gt;dp[i]&lt;/code&gt;（也就是前&lt;code&gt;i&lt;/code&gt;天的最大利润），应该是前&lt;code&gt;i-1&lt;/code&gt;天的最大利润与第&lt;code&gt;i&lt;/code&gt;天卖出股票的利润的最大值，于是就有了$前i天最大利润=max（前i-1天最大利润，第i天价格-前i天最低价格）$即为&lt;code&gt;dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i]))&lt;/code&gt;，最终返回&lt;code&gt;dp[n-1]&lt;/code&gt;为所求。&lt;/p&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;p&gt;我们还可以进行空间和时间上的优化，时间上，可以借助一个变量&lt;code&gt;cost&lt;/code&gt;来维护最小值，这样每次进行状态转移时只需要&lt;code&gt;dp[i] = max(dp[i - 1], prices[i] - min(cost, prices[i]))&lt;/code&gt;，空间上，由于本道题的状态转移只需要前一次的状态，因此可以采用一个变量&lt;code&gt;maxprofit&lt;/code&gt;来代替整个动态规划列表，这样状态转移就简化为了&lt;code&gt;maxprofit = max(maxprofit, prices[i] - min(cost, prices[i]))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*未优化*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxProfit(vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; prices) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (prices.empty()) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100004&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dp {};
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; cost &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
        dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; prices.size(); &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (prices[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cost) {
                cost &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prices[i];
            }
            dp[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], prices[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; cost);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[prices.size() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*优化后*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxProfit(vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; prices) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (prices.empty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; cost &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], maxprofit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; prices.size(); &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (prices[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; cost) {
                cost &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; prices[i];
            }
            maxprofit &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(maxprofit, prices[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; cost);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; maxprofit;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 树的子结构</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
        <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同的结构和节点值。&lt;/p&gt;
&lt;p&gt;例如:
给定的树 A:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;     3
    / \
   4   5
  / \
 1   2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定的树 B：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  4
 /
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。&lt;/p&gt;
&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;树的题目是真的让人头疼。在经过几次暴力解的尝试之后我还是放弃了，最后几组数据总是通过不了。还是去翻了题解，发现又是我最烦的递归（永远的痛）&lt;/p&gt;
&lt;p&gt;1、首先子结构要么是其本身要么在树的左子树或者右子树里，因此在&lt;code&gt;isSubStructure&lt;/code&gt;函数中需要判断是本身匹配还是左子树或者是右子树匹配，这是最外层递归。最外层递归中，如果B树（&lt;em&gt;也就是子结构树&lt;/em&gt;）为空，那么直接返回&lt;code&gt;false&lt;/code&gt;，同理如果A树（&lt;em&gt;要从这棵树中寻找子结构&lt;/em&gt;）为空也可以直接返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、对于子结构是否匹配的判断也需要通过递归实现（也就是&lt;code&gt;isContain&lt;/code&gt;函数），但具有以下几种情况，其中包含退出递归的条件&lt;/p&gt;
&lt;p&gt;（a）、如果当前的B树为空，且At树（&lt;em&gt;也就是从A树种截取出的子树&lt;/em&gt;）非空或者空，此时表明B树是A树的一个子结构，因为可以将B树匹配完。&lt;/p&gt;
&lt;p&gt;（b）、如果当前的B树非空，但At树为空，说明此时已经遍历过了A树的叶节点，那么B树一定与At树不匹配，可以直接返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（c）、如果此时At树和B树都不为空，且当前匹配中的结点的值不相等，那么B树一定与At树不匹配，可以直接返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（d）、如果At树和B树都不为空，且当前匹配中的结点的值相等，那么就继续匹配两棵树当前结点的左结点和右结点（也就是内层的递归）&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Definition for a binary tree node.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * struct TreeNode {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode *left;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode *right;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * };
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; isContain(TreeNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;A, TreeNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;B) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 递归判断是否包含
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果此时B为空树，说明已经递归完了B树，因此是包含的
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (B &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果大树为空，匹配树不是空，那么说明不包含
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果当前匹配的结点值不相等，那么也是不包含
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; B&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果以上条件都不满足就继续判断子树
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isContain&lt;/span&gt;(A&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left, B&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; isContain(A&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right, B&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right);
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isSubStructure&lt;/span&gt;(TreeNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A, TreeNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; B) {
        &lt;span style=&#34;color:#75715e&#34;&gt;// B树为空，则为false
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (B &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        &lt;span style=&#34;color:#75715e&#34;&gt;// A树为空，也为false
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; isContain(A, B) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; isSubStructure(A&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left, B) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; isSubStructure(A&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right, B);
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 从上到下打印链表</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
        <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&lt;/p&gt;
&lt;p&gt;例如:
给定二叉树: &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
  [3],
  [9,20],
  [15,7]
]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;  这道题本身并不是什么难题，也很明显可以看出是一个层序遍历的变种，解决问题的关键就在于如何区分当前层和下一层，最开始是打算使用&lt;code&gt;pair&lt;/code&gt;将每个结点与其相应的层序号对应起来。但在实际写代码时发现有点困难，最后还是去翻了题解，发现了利用空指针作为层与层之间分隔的方法。具体做法就是在第一次入队时再入队一个空指针，之后利用队头元素不为空指针作为内循环的判断，如果队头为空，则表明了已经循环完了一层。而由于二叉树的特点，在使用层序遍历时，遍历完一层也即代表着下一层的非空结点已经完全入队，这时便可以再入队一个空指针作为下一个分隔结点。利用这样的循环就能做到以层为序来打印层序遍历。&lt;/p&gt;
&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Definition for a binary tree node.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * struct TreeNode {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode *left;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode *right;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * };
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; levelOrder(TreeNode&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; root) {
        vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; res;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (root &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
        }
        queue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TreeNode&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; que;  &lt;span style=&#34;color:#75715e&#34;&gt;// 用于层序遍历
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        que.push(root);
        que.push(NULL);  &lt;span style=&#34;color:#75715e&#34;&gt;// 利用空指针作为每层之间的分隔
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (que.size()) {
            vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; vtemp;  &lt;span style=&#34;color:#75715e&#34;&gt;// 队列不为空时，就申请空间存储本层数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (que.front()) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 用这个条件判断是否属于同一层数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                TreeNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; que.front();
                vtemp.push_back(temp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val);
                que.pop();
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left) que.push(temp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;left);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (temp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right) que.push(temp&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;right);
            }
            &lt;span style=&#34;color:#75715e&#34;&gt;// 退出上面的循环表示已经到了层与层之间的界线
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            que.pop();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (que.size()) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 如果此时队列非空，则表明不是最后一层
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历过一层即表示队列中已经保存了下一层，因此需要加入空指针分割
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                que.push(NULL);
            }
            res.push_back(vtemp);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; res;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>观《时光代理人》、《灵笼》所感</title>
        <link>https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/</link>
        <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/%E8%A7%82%E6%97%B6%E5%85%89%E4%BB%A3%E7%90%86%E4%BA%BA%E7%81%B5%E7%AC%BC%E6%89%80%E6%84%9F/</guid>
        <description>&lt;p&gt;  如题的这两部动漫都是我认为接近于国漫巅峰的动漫，当然我并没有看过多少国漫，因此这一判断也是相当主观的。但确实的是其在我内心中是“前无古人”的。这两部动漫也是将我这一早已不看动漫的人又带回了国创动漫。&lt;/p&gt;
&lt;h2 id=&#34;动漫情节叙述&#34;&gt;动漫情节叙述&lt;/h2&gt;
&lt;p&gt;  由于两部动漫都只做到了第一季，虽能体现一定的设定及世界观，但是很多剧情依旧是在迷雾之中的。这里也就只能讲讲已有的剧情。&lt;/p&gt;
&lt;p&gt;  《灵笼》的设定之前也是有过，但是灵笼剧情的饱满程度让末日题材的这种设定能够更好的展现出来。开篇便是猎荒者（即在末日中探索旧世界的可利用的东西，为幸存下来的人服务）在探索一篇废墟，并遭遇了噬极兽（因为这种怪兽因而认为地上是无法生存的）。当猎荒者凯旋归来时，之后便迎来了另一个比较重要的情节，也就是城主的更替。当然这里要先说说这个城主的问题，现在的人们生活在一个叫做“灯塔”的建筑上，而现任成主的儿子则是在灯塔上成立了一个类似于教会的“光影会”。这里就权且称这位会长为“黄毛”。城主更希望由猎荒者队长马克来接任下一任城主，但是心胸狭隘的黄毛却利用一些手段导致马克成为了噬极兽并因此被流放。（这里其实省略了很多的情节，但我觉得第一季的主要目的应该就是仅仅为了引出世界观以及《灵笼》整个庞大故事的开端）。最后第一季也是在马克与在地面上的人类相遇而结束。（这么讲其实还是草率了，如果有时间我还是希望能够去看《灵笼》的剧情）。&lt;/p&gt;
&lt;p&gt;  反观《时光代理人》却是以一个较为新颖的角度作为设定，也即时间。（具体便是主角团能够以自己的特殊能力进入照片，而在照片里的一言一行都有可能对未来造成影响）。时光照相馆是主角团的“基地”，也是通过这个照相馆接取委托人的任务从而帮助委托人实现一些过去或希望从过去得到线索的事情。由于这部动漫是通过一个个的小故事，因此在这里也不好叙述，依旧是推荐能够去观看动漫本身。&lt;/p&gt;
&lt;h2 id=&#34;谈动漫本身&#34;&gt;谈动漫本身&lt;/h2&gt;
&lt;p&gt;  很明显两部动漫都具有自己的特点，但是我却依旧将他们放在一起谈，是因为它们给我带来足够的震撼，纵使在这之前亦有《百妖谱》等，却没能给我带来那种共鸣与一种仿佛自己置身于其中希望改变世界的情感。&lt;/p&gt;
&lt;p&gt;  先谈《灵笼》，灵笼首先在建模方面就足够优秀，虽然采用了我不是很喜欢的建模方式，但是却依旧能够吸引我（对于我这种比较叼的人来说，这个方面就已经足够碾压国产大部分动漫了）不仅如此，人物的表情以及动作都十分逼真，其实到这里就已经可以体现制作者的用心了。当然这只是建模这个我比较关注的方面。接下来应该是剧情方面，《灵笼》的设定是动漫中比较不常见的，本以为这样的题材并不能够很好的把握，但事实是艺画开天以一种更为庞大的世界观来描述这个末日世界，这是在之前的各种影视剧中没有出现的。不仅如此，涉及的领域也十分广泛，大部分动漫可能在主题上会展现的只会是比较重要的一部分，例如青春或者爱情、友情等等。但《灵笼》光第一季就像是想要把自己的所有元素都展现出来，其中的光影会代表着类似教会一般的人，没有什么实质性的作用却控制着一部分人的思想，而会长也借助这些力量来实现自己的目标，甚至几乎摧毁了猎荒者这一强大的对抗力量。这如果影射到现实，便是思想、武装与权力之间的关系。除了这个，人性的描述也十分到位，通过对尘民4068的刻画，既展现了末日阶级统治的一种希望成为更高阶级的渴望，也让观众因为这位尘民的所作所为更加拥有共鸣。最终也会更投入到作品本身。&lt;/p&gt;
&lt;p&gt;  当然，一部好的的作品我觉得感情线应该是必不可少的。在《灵笼》中，并没有婚恋的自由，甚至拥有“三大法则”制约每一个人的情感。所谓的“爱情”更像是统治阶级给予的枷锁，而作为猎荒者队长的马克，本应遵守这些规则，却仍然在第一季的最后体会到了什么是爱，并为自己所爱的人大闹灯塔。虽然并没有成功的将灯塔上的人的思想扭转过来，但也为作品之后奠定了一个基调。第一季的最后则是利用地上的生存的人来表明这仅仅是《灵笼》这个庞大世界观的开始。还有一个吸引我的点是，在第一季末的一个全季最精彩的打斗场面中，背景音乐采用了纯唢呐，这种打破常规的做法也是取得了一个意想不到的效果，导致了各种二创都不及原版。&lt;/p&gt;
&lt;p&gt;  再看《时光代理人》，这动漫则是一开始便就从一个故事入手，直入主题，直接为观众呈现了这部作品在之后的表现方式。最开始我以为这只会是一种加强版的泡面番，通过一个个的故事来组成一部动漫，但渐渐的我发现我错了，在短短十几集的动漫中，却在最后的几集给你中给你串连起之前的故事。瞬间让你觉得这不是一个个故事那么简单。这也反应了作品中一直在重复的一句话“无论过去，不问将来”。故事也不是那种偏离现实的故事，而是充满人情味，让你觉得这都是可能发生在你身边的故事。其中的一个描述汶川地震的故事，借用了亲情和爱情令人动容。每个故事又都在恰到好处的地方停了下来。（因此我建议如果要看，就干脆一次性看完）&lt;/p&gt;
&lt;p&gt;  通过这整个主角团在第一季遭遇的整个故事，很精确的展现了主角团三人的性格特点，沉稳缜密的陆光，正义但却有点冲动的程小时，以及开朗能够带动气氛的乔苓。让人多多少少有点羡慕这样的三人组。第一季的最后程小时为了挽救自己之前在照片里所做过的一些错事，却发现最后仍旧没能改变，这也引出了这部动漫的反派（不止有人能够像他们那样穿越时空回到过去）。也因为这个反派最终主角团三人全部都遭到了不同程度的不幸。第一季也是在这样的一种紧张的气氛中结束了。&lt;/p&gt;
&lt;h2 id=&#34;给我的感受&#34;&gt;给我的感受&lt;/h2&gt;
&lt;p&gt;  看完这两部动漫已经很久了，但是仍然给我一种意犹未尽的感觉，最为明显的情感就是让我觉得在中国，在动漫的国创领域，仍然有这一批热爱动漫，能够写出好故事，能够通过讲好故事带给我们不一样的感受，带给我们动漫魅力的这样一群人。国创的在建模和画风上也在寻求创新以及更适合年轻人观感的改变。故事也具有较为厚重的情感，不像以前的日漫虽有情感，却给我一种较为单薄站不住脚的感觉（当然也不能否认有情感浓重的日漫）。《灵笼》带来的是宏大的世界观和巨大的创作空间。《时光代理人》带来的则是新颖的设定和令人出乎意料的编剧创作。两部动漫都以自己独特的一部分吸引着观众，也引起了在B站的极大热度。当然期待越高，不可避免的便是可能会带来失望。高开低走的动漫已经不少，我只希望拥有这么好的创作背景和创作团队，这两部动漫能够好好的珍惜，能够用尽心思来为观众呈现国漫的另一番风景，至少不要让观众对这两部动漫的呼声成为空喊，也不要让推荐这两部动漫的人最后感到太大的失望。&lt;/p&gt;
&lt;p&gt;  在最后还是希望国创能够走出一条更加新奇的道路，也希望这两部动漫都能够继续自己第一季的辉煌。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://pic.imgdb.cn/item/61e8227b2ab3f51d916ed913.jpg&#34; &gt;
		&lt;img src=&#34;https://pic.imgdb.cn/item/61e8227b2ab3f51d916ed913.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;我喜欢的《时光代理人》画风&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;我喜欢的《时光代理人》画风&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hugo博客 | stack主题修改第一站</title>
        <link>https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/</link>
        <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/hugo%E5%8D%9A%E5%AE%A2-stack%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E7%AC%AC%E4%B8%80%E7%AB%99/</guid>
        <description>&lt;p&gt;本来是不想用这篇博文作为新博客的第一篇的，但无奈修改这个主题以便让我能够看得舒服确实花费了我很多精力，因此想写下这一篇博文来记录这一历程，当然这次的修改也只是建博客时对于我来说最难以忍受的痛点，如果在使用的时候觉得还有值得修改的地方，那说不定就有第二站。不废话，直接开冲！&lt;/p&gt;
&lt;h2 id=&#34;自定义的项目&#34;&gt;自定义的项目&lt;/h2&gt;
&lt;h3 id=&#34;to-do&#34;&gt;TO-DO&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改文章的字体为思源宋体（其实我喜欢行楷，但苦于还没有找到解决方法。。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改站点图标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改站点名称并使其居中，同时具有一定的间隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改选中的样式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 站点头像居中（虽然本来应该就是居中了。。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 添加主页按钮点击不会高亮的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 主页样式的修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改左边栏头像大小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 返回顶部功能的添加&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改Toc的样式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改分类的标签样式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 修改滚动条样式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt; 使文章支持数学公式编辑&lt;/p&gt;
&lt;h2 id=&#34;具体修改&#34;&gt;具体修改&lt;/h2&gt;
&lt;h3 id=&#34;修改全站的字体&#34;&gt;修改全站的字体&lt;/h3&gt;
&lt;p&gt;其实修改字体的方案主题的原作者已经给出，有需要的可以参考&lt;a class=&#34;link&#34; href=&#34;https://docs.stack.jimmycai.com/zh/modify-theme/example-custom-font-family.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;修改字体&lt;/a&gt;，作为一个中国人，好康的中文永远比好康的英文重要。
具体做法是在站点根目录中的&lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt;中添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;style&lt;/span&gt;&amp;gt;
    :&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; {
        --article-font-family: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noto Serif SC&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;base&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;font&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;family);
    }
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;style&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 正文自重300，标题字重700
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
		    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customFont&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;createElement&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;link&amp;#39;&lt;/span&gt;);
		    &lt;span style=&#34;color:#a6e22e&#34;&gt;customFont&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&amp;amp;display=swap&amp;#34;&lt;/span&gt;;
		
		    &lt;span style=&#34;color:#a6e22e&#34;&gt;customFont&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;text/css&amp;#34;&lt;/span&gt;;
		    &lt;span style=&#34;color:#a6e22e&#34;&gt;customFont&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;rel&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stylesheet&amp;#34;&lt;/span&gt;;
		
		    document.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;appendChild&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;customFont&lt;/span&gt;);
		}());
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上是作者给出的，我只是在字重上做了修改。除此之外我还修改了&lt;code&gt;hugo-theme-stack/assets/scss/variable.scss&lt;/code&gt;文件，具体就是调整了&lt;code&gt;--zh-font-family&lt;/code&gt;和&lt;code&gt;--base-font-family&lt;/code&gt;的顺序，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;--zh-font-family&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noto Serif SC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hiragino Sans GB&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Droid Sans Fallback&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Microsoft YaHei&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#a6e22e&#34;&gt;--base-font-family&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Noto Serif SC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;sys-font-family)&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;zh-font-family)&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; sans-serif;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改站点的图标&#34;&gt;修改站点的图标&lt;/h3&gt;
&lt;p&gt;这个问题起先困扰了我很久（虽然期间可能已经修改好了，但因为网站cookie的原因导致修改没有及时显示），具体做法如下，先将你需要的图片转换为&lt;code&gt;.ico&lt;/code&gt;文件（其它类型的图片文件应该也行），如需转换可以借助&lt;a class=&#34;link&#34; href=&#34;https://convertio.co/zh/ico-converter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这个网站&lt;/a&gt;。之后将转换后的文件保存在网站根目录的&lt;code&gt;static&lt;/code&gt;文件夹中。之后修改主题的配置文件&lt;code&gt;config.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;params&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;mainSections&lt;/span&gt;:
        - &lt;span style=&#34;color:#ae81ff&#34;&gt;post&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;featuredImageField&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;image&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;rssFullContent&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;favicon&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;favicon.ico&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改站点名称&#34;&gt;修改站点名称&lt;/h3&gt;
&lt;p&gt;站点名称对大家来说应该不是什么难事，这里就说说居中以及间隔。这里需要修改主题根目录的&lt;code&gt;assets/scss/partials/siderbar.scss&lt;/code&gt;文件。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.site-name&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;accent-color);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.8&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;text-align&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; center;  &lt;span style=&#34;color:#75715e&#34;&gt;// 站点名称文本居中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;xl&lt;/span&gt;) {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;;
    }
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;.site-description&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;body-text-color);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;font-weight&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; normal;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;text-align&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; center;  &lt;span style=&#34;color:#75715e&#34;&gt;// 站点描述居中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;xl&lt;/span&gt;) {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然如果站点名称之间具有一定的间隔的话，应该是会更美观一点的。方法是在&lt;code&gt;layouts/partials/head/custom.html&lt;/code&gt;文件上加入以下代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;style&lt;/span&gt;&amp;gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;h1&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;letter-spacing&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
	}
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;style&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个代码将会对全站的&lt;code&gt;h1&lt;/code&gt;标题进行修改，因此业也会导致其它&lt;code&gt;h1&lt;/code&gt;标签也发生改变，但目前只注意到进入一个分类页面时，分类的字距变大了，因此我们需要在&lt;code&gt;custom.scss&lt;/code&gt;文件中追加如下修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.section-term&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.8&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;; 
    &lt;span style=&#34;color:#a6e22e&#34;&gt;letter-spacing&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改选中的样式&#34;&gt;修改选中的样式&lt;/h3&gt;
&lt;p&gt;原来作者的选中样式和当前的大多数网站是一样的，给我一种十年前互联网的感觉，于是喜欢深色系的我修改了选中样式。需要在&lt;code&gt;assets/scss/custom.scss&lt;/code&gt;文件中加入如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;::selection&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;#fff&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;background&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;#557697&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;站点头像居中&#34;&gt;站点头像居中&lt;/h3&gt;
&lt;p&gt;这个可能只是心理作用。。
同样是在&lt;code&gt;assets/scss/partials/siderbar.scss&lt;/code&gt;文件中加入修改以下代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.site-avatar&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;position&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; relative;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-left&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;  &lt;span style=&#34;color:#75715e&#34;&gt;// 站点头像居中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;  &lt;span style=&#34;color:#75715e&#34;&gt;// 站点头像居中
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;sidebar-avatar-size);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;sidebar-avatar-size);

    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;sidebar-element-separation);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;主页按钮高亮问题&#34;&gt;主页按钮高亮问题&lt;/h3&gt;
&lt;p&gt;这个虽然不算是什么大问题吧，但是主页不高亮我就觉得很难受。。于是就找到了&lt;code&gt;layouts/partials/sidebar/left.html&lt;/code&gt;这个文件。我们可以看到一下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;{{ $currentPage := . }}
{{ range .Site.Menus.main }}
{{ $active := or (eq $currentPage.Title .Name) (or ($currentPage.HasMenuCurrent &amp;#34;main&amp;#34; .)($currentPage.IsMenuCurrent &amp;#34;main&amp;#34; .)) }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码大概的逻辑就是如果当前的页面是菜单中的页面之一就设定为激活状态，而如果要让主页高亮的话需要加入以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;{{ $siteTitle := .Site.Title }}
{{ $active := or ($active) (and (eq $currentPage.Title $siteTitle) (eq .Identifier &amp;#34;home&amp;#34;)) }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样就会使若当前的网站的标题等于网站名称就会令其为激活状态，而之后的&lt;code&gt;Identifier&lt;/code&gt;则是为了区分主页页面，否则就会出现点击主页所有页面都是高亮的情况。&lt;/p&gt;
&lt;h3 id=&#34;主页样式的修改&#34;&gt;主页样式的修改&lt;/h3&gt;
&lt;p&gt;第一次看到这个主题时就对它的主页布局感到不舒服，尤其是在笔记本电脑上挤满了整个屏幕令人难受，于是希望左右两边能够有一定的留白，这样可以美观一些。&lt;/p&gt;
&lt;p&gt;从开发者工具中我们可以得知主页的&lt;code&gt;class&lt;/code&gt;是&lt;code&gt;container&lt;/code&gt;，经过查找可以知道其样式是在&lt;code&gt;assets/scss/grid.css&lt;/code&gt;中定义的。于是可以发现如下这段代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.container&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-left&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;

    &lt;span style=&#34;color:#a6e22e&#34;&gt;.left-sidebar&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;left&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;sidebar-max-width);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#a6e22e&#34;&gt;.right-sidebar&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;sidebar-max-width);

        &lt;span style=&#34;color:#75715e&#34;&gt;/// Display right sidebar when min-width: lg
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(lg) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;display&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; block;
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.extended&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(md) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--right-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(lg) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1280&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--right-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(xl) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1536&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--right-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码对左边栏和右边栏进行了最大宽度的限制，这也就是我们要修改的地方。但是这其中的各个&lt;code&gt;@include&lt;/code&gt;函数又代表什么呢？我们可以观察&lt;code&gt;asset/scss/breakpoints.scss&lt;/code&gt;这个文件，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;$breakpoints&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; (
    &lt;span style=&#34;color:#a6e22e&#34;&gt;sm&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;640&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;md&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;768&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;lg&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;xl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1280&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;2xl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1536&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
);

&lt;span style=&#34;color:#66d9ef&#34;&gt;@mixin&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;($breakpoint) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;@if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map-has-key&lt;/span&gt;($breakpoints&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; $breakpoint) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@warn&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#{&lt;/span&gt;$breakpoint&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39; is not a valid breakpoint&amp;#34;&lt;/span&gt;;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;@else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@media&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;min-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;map-get&lt;/span&gt;($breakpoints&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; $breakpoint)) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;@content&lt;/span&gt;;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;没有学过&lt;code&gt;css&lt;/code&gt;的我也就只能大致看出这是封装了各种屏幕尺寸类似于&lt;code&gt;map&lt;/code&gt;，而在笔记本电脑上，屏幕宽度是&lt;code&gt;1024px&lt;/code&gt;以上的，因此我们只需要修改&lt;code&gt;@include respond(lg)&lt;/code&gt;函数下的样式就可以了。在&lt;code&gt;asset/scss/custom.scss&lt;/code&gt;下添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.container&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-left&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.extended&lt;/span&gt; {
        &lt;span style=&#34;color:#75715e&#34;&gt;/* range: 768-1024 */&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(md) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--right-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }

        &lt;span style=&#34;color:#75715e&#34;&gt;/* range: 1024-1280 */&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(lg) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 修改主页的三个组件的显示比例
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1280&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--right-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.compact&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(md) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;768&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(lg) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;--left-sidebar-max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(xl) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;max-width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1280&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，主页的修改也告一段落了。以上都是从&lt;a class=&#34;link&#34; href=&#34;https://xrg.fj.cn/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这位大佬那里学来&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;修改左侧边栏头像的大小&#34;&gt;修改左侧边栏头像的大小&lt;/h3&gt;
&lt;p&gt;左侧边栏的元素太多，显得实在有点挤，于是索性修改了一下博客的头像大小。需要在主题根目录下的&lt;code&gt;assets/scss/partials/sidebar.scss&lt;/code&gt;文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;@include&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt; respond&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;xl&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;{
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;--sidebar-avatar-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;125&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 修改头像大小的代码  
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;--sidebar-element-separation&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;返回顶部按钮的添加&#34;&gt;返回顶部按钮的添加&lt;/h3&gt;
&lt;p&gt;在参考过其它使用这个主题的博主之后发现，如果一篇文章太长，没有返回顶部这个按钮可能会在某些情况下造成体验的不舒适，于是决定加上这个功能。最开始是希望能够在一个页面的右下角添加这个按钮，但是无法解决页面缩放时显示位置与主页面之间的关系的问题，因此决定借助目录放置于目录的下方。&lt;/p&gt;
&lt;p&gt;首先是按钮的函数，参考了&lt;code&gt;slim&lt;/code&gt;主题，具体是在&lt;code&gt;layouts/partials/head/script.html&lt;/code&gt;中加入如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// Check to see if the window is top if not then display button
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(window).&lt;span style=&#34;color:#a6e22e&#34;&gt;scroll&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;scrollTop&lt;/span&gt;()) {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#back-to-top&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;fadeIn&lt;/span&gt;();
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#back-to-top&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;fadeOut&lt;/span&gt;();
    }
    });

    &lt;span style=&#34;color:#75715e&#34;&gt;// Click event to scroll to top
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;#back-to-top&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;click&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;html, body&amp;#39;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;animate&lt;/span&gt;({&lt;span style=&#34;color:#a6e22e&#34;&gt;scrollTop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;}, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
    });
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码可以监听窗口抖动，从而控制按钮的显示和隐藏。&lt;/p&gt;
&lt;p&gt;然后是添加返回顶部的按钮，由于这个按钮需要和文章目录保持一个相对固定的位置，因此需要修改&lt;code&gt;layouts/_default/single.html&lt;/code&gt;，在&lt;code&gt;aside&lt;/code&gt;标签下加入如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;{{ $topImg := resources.Get (&amp;#34;img/top.png&amp;#34;) }}
{{ $topImg := $topImg.Resize &amp;#34;40x&amp;#34; }}
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;back-to-top&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;img&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{{ $topImg.RelPermalink }}&amp;#34;&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;a&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;利用一张图片作为返回顶部的链接。最后我们需要通过&lt;code&gt;css&lt;/code&gt;来为这个按钮添加样式。首先我们需要找到之前提过的&lt;code&gt;custom.scss&lt;/code&gt;文件，在文件中加入如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;#go-top {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;display&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; none;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;position&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; absolute;  
    &lt;span style=&#34;color:#a6e22e&#34;&gt;border&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;:hover&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;filter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;opacity&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;60&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;%&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 悬停淡化
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中&lt;code&gt;bottom&lt;/code&gt;值是我觉得可以避免当目录过长时会几乎占满整个屏幕，导致按钮没有地方放的问题。&lt;/p&gt;
&lt;h3 id=&#34;修改toc样式&#34;&gt;修改Toc样式&lt;/h3&gt;
&lt;p&gt;由于Toc每个标题之间的行间距有点大，于是就缩了缩，在&lt;code&gt;custom.scss&lt;/code&gt;文件中又追加了如下的修改：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.widget--toc&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;background-color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;card-background);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;border-radius&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;card-border-radius);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;display&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; flex;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;flex-direction&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; column;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;card-text-color-main);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; hidden;
    &lt;span style=&#34;color:#75715e&#34;&gt;// display:inline-block;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;

    #TableOfContents {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow-x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;
        &lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; 
            &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;list-style-type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; none;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;counter-reset&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; item;
            &lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;:before&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;counter-increment&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; item;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;counters&lt;/span&gt;(item&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;. &amp;#34;&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;font-weight&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; bold;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            }
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;em&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;; 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-top&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;padding-left&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;:last-child&lt;/span&gt; {
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;追加了一些修改，在使用了一段时间后发现，每个目录项前面的小点在一定程度上占了空间，挤压了目录字，导致每个目录项容易换行，以及在&lt;code&gt;margin&lt;/code&gt;和&lt;code&gt;padding&lt;/code&gt;上还可以有缩减的空间，于是在&lt;code&gt;custom.scss&lt;/code&gt;文件上做了以下修改（删了一些无用代码，注释了小点，并修改了一些间距）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.widget--toc&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// display:inline-block;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;

    #TableOfContents {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow-x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;max-height&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;70&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;vh&lt;/span&gt;;
        &lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;list-style-type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; none;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; 
            &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;amp; &amp;gt; ul {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//     padding: 0 1em;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// }
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;; 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;ol&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-top&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;padding-left&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;:last-child&lt;/span&gt; {
                    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改分类标签样式&#34;&gt;修改分类标签样式&lt;/h3&gt;
&lt;p&gt;这个stack主题属实是有点迷，一样的主题推送到GitHub居然能产生不同的效果，无奈的我只能又去修改原先又大又丑的分类标签，根据我个人的喜好，将标签修改为小巧一点，放弃了原来的图片修饰，相关的代码写于&lt;code&gt;custom.scss&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.subsection-list&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;section-separation);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow-x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; auto;

    &lt;span style=&#34;color:#a6e22e&#34;&gt;.article-list--tile&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;display&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; flex;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;padding-bottom&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;

        &lt;span style=&#34;color:#f92672&#34;&gt;article&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 修改分类的标签大小
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;; 
            &lt;span style=&#34;color:#a6e22e&#34;&gt;margin-right&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;; 
            &lt;span style=&#34;color:#a6e22e&#34;&gt;flex-shrink&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            &lt;span style=&#34;color:#75715e&#34;&gt;// box-shadow: var(--shadow-l2); 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;.article-title&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;margin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.5&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;; 
                &lt;span style=&#34;color:#a6e22e&#34;&gt;text-align&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; center;  &lt;span style=&#34;color:#75715e&#34;&gt;// 保证字居中美观一点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            }

            &lt;span style=&#34;color:#a6e22e&#34;&gt;.article-details&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;padding&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
                &lt;span style=&#34;color:#a6e22e&#34;&gt;justify-content&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; center; 
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改相关文章图标-样式&#34;&gt;修改相关文章图标 样式&lt;/h3&gt;
&lt;p&gt;在第一次推送到GitHub之后发现，相关文章的推荐标签有点与当前屏幕不相符，于是决定将相关文章的标签的大小调整到与分类的大小差不多大，于是我们依旧在&lt;code&gt;custom.scss&lt;/code&gt;文件中追加修改样式的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;.related-contents--wrapper&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;.related-contents&lt;/span&gt; {
        &lt;span style=&#34;color:#f92672&#34;&gt;article&lt;/span&gt; {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;85&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
            &lt;span style=&#34;color:#a6e22e&#34;&gt;.article-title&lt;/span&gt; {
                &lt;span style=&#34;color:#a6e22e&#34;&gt;font-size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;.6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;rem&lt;/span&gt;;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;修改滚动条样式&#34;&gt;修改滚动条样式&lt;/h3&gt;
&lt;p&gt;当文章的目录太长时便会产生滚动条，而默认的滚动条实在是丑得不想形容。由于不是很想再调试了，于是再次参考&lt;a class=&#34;link&#34; href=&#34;https://xrg.fj.cn/p/hugo-stack%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E5%B0%8F%E8%AE%B0/#%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%BE%8E%E5%8C%96&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;大佬的操作&lt;/a&gt;，而且既然想改滚动条了，索性一步到位直接全改，我们需要在&lt;code&gt;custom.scss&lt;/code&gt;文件中添加如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scss&#34; data-lang=&#34;scss&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;html&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;::-webkit-scrollbar&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
      }
      
      &lt;span style=&#34;color:#a6e22e&#34;&gt;::-webkit-scrollbar-track&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;background-color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; transparent;
      }
      
      &lt;span style=&#34;color:#a6e22e&#34;&gt;::-webkit-scrollbar-thumb&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;background-color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;#d6dee1&lt;/span&gt;;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;border-radius&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt;;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;border&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;px&lt;/span&gt; solid transparent;
        &lt;span style=&#34;color:#a6e22e&#34;&gt;background-clip&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; content-box;
      }
      
      &lt;span style=&#34;color:#a6e22e&#34;&gt;::-webkit-scrollbar-thumb:hover&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;background-color&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;#a8bbbf&lt;/span&gt;;
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;支持数学公式编辑&#34;&gt;支持数学公式编辑&lt;/h3&gt;
&lt;p&gt;在一次使用了markdown内联的$LaTeX$公式发现部署上去之后没有反应时，便一直想使文章能够支持数学公式的编辑。于是在时隔多日之后终于有了解决办法。&lt;/p&gt;
&lt;p&gt;我们需要在主题根目录的&lt;code&gt;/layouts/partials&lt;/code&gt;创建&lt;code&gt;math.html&lt;/code&gt;文件，之后在这个文件中加入如下代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;{{ if or .Params.math .Site.Params.math }}
{{ partial &amp;#34;math.html&amp;#34; . }}
{{ end }}

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;link&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rel&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stylesheet&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;href&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;integrity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;crossorigin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;anonymous&amp;#34;&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;integrity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;crossorigin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;anonymous&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;integrity&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;crossorigin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;anonymous&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;renderMathInElement(document.body);&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;script&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码能够自动渲染数学公式，当然这样还是不够的，我们还需要在每篇文章的markdown的&lt;strong&gt;header&lt;/strong&gt;加上&lt;code&gt;math=&amp;quot;true&amp;quot;&lt;/code&gt;的选择字段。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>LeetCode 复杂链表的复制</title>
        <link>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
        <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;请实现 &lt;code&gt;copyRandomList&lt;/code&gt; 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 &lt;code&gt;next&lt;/code&gt; 指针指向下一个节点，还有一个 &lt;code&gt;random&lt;/code&gt; 指针指向链表中的任意节点或者 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png&#34; &gt;
		&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题&#34;&gt;解题&lt;/h2&gt;
&lt;p&gt;题目的意思很简单，就是返回一个一模一样的链表头结点。由于随机指针的存在，链表的复制不能够像正常链表那样直接遍历，也因此没想明白要怎么做，最后翻了题解，才发现又是我最烦的递归。&lt;/p&gt;
&lt;p&gt;这道题采用的递归解法其实本质就是遇到问题再解决问题，在还没有开始复制之前，所有的复制结点都是虚无的，要让这些结点和已知的结点一一对应起来就需要一个&lt;code&gt;map&lt;/code&gt;数据结构。用来对应新旧两个链表的结点。这样从第一个结点入手，当这个结点不在&lt;code&gt;map&lt;/code&gt;中时，就立刻创建这个结点并于原链表中的相应结点建立对应关系。之后的每一个结点都可以根据这样的逻辑进行创建，而因为有&lt;code&gt;map&lt;/code&gt;这个数据结构的存在，这样每个结点都不是虚空存在的，而是可以在&lt;code&gt;map&lt;/code&gt;中找到与之对应的结点。可以解决随机结点创建的问题。具体代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;, Node&lt;span style=&#34;color:#f92672&#34;&gt;*&amp;gt;&lt;/span&gt; um;  &lt;span style=&#34;color:#75715e&#34;&gt;// 用来存储两个链表，结点之间一一对应
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;copyRandomList&lt;/span&gt;(Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; head) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (head &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; NULL) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 如果链表本就为空，那么直接返回空
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL;
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 遵循边遍历边创建的原则
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;um.count(head)) {  &lt;span style=&#34;color:#75715e&#34;&gt;// 如果此时哈希表中没有这个结点，就直接创建
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            Node&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; headNew &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;val);  &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化一个相同的结点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            um.insert(make_pair(head, headNew));  &lt;span style=&#34;color:#75715e&#34;&gt;// 将这两个位置一样的结点对应起来
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            headNew&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copyRandomList(head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next);  &lt;span style=&#34;color:#75715e&#34;&gt;// 同理下一个结点也应该这样拷贝，依旧遵循上面的原则
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            headNew&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;random &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copyRandomList(head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;random);
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 如果这个结点已经在哈希表中存在，那么就直接返回
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; um[head];
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 141 环形链表</title>
        <link>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
        <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 &lt;code&gt;next&lt;/code&gt; 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos &lt;/code&gt;来表示链表尾连接到链表中的位置（索引从 &lt;code&gt;0&lt;/code&gt; 开始）。 如果 pos 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。注意：&lt;code&gt;pos&lt;/code&gt; 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;如果链表中存在环，则返回 &lt;code&gt;true&lt;/code&gt; 。 否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://img-blog.csdnimg.cn/img_convert/4a18acda10c1606aa5d1132b9de26d61.png&#34; &gt;
		&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/4a18acda10c1606aa5d1132b9de26d61.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;在这里插入图片描述&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://img-blog.csdnimg.cn/img_convert/1a6fcfc68d7340c39151075f7fa53150.png&#34; &gt;
		&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/1a6fcfc68d7340c39151075f7fa53150.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;在这里插入图片描述&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://img-blog.csdnimg.cn/img_convert/3039274e08a9385ea77b20a81060ed40.png&#34; &gt;
		&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/3039274e08a9385ea77b20a81060ed40.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;在这里插入图片描述&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;提示&#34;&gt;提示&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;链表中节点的数目范围是 [0, 104]
-105 &amp;lt;= Node.val &amp;lt;= 105
pos 为 -1 或者链表中的一个 有效索引 。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;这道题在leetcode上属于简单题，但由于第一次遇见这种解法（也由于第一次想错了，根本不是正解）所以就想记录一下。
很明显题目要判断链表中是否有环，于是可以想到如果在链表中有两个指针分别向前跑，当两个指针指向的结点相同的时候便证明链表中有环存在。这个时候就需要一个循环来判断两个指针是否相等。此时条件应该是&lt;code&gt;first != second&lt;/code&gt;因此如果我们初始化两个指针在同一个位置，那么将无法进入循环，因此需要将两个指针分别初始化在头结点以及头结点的下一个结点，还要注意的是，&lt;code&gt;first&lt;/code&gt;指针的速度应该要快于&lt;code&gt;second&lt;/code&gt;指针的速度，这样，当链表中有环时，&lt;code&gt;first&lt;/code&gt;指针会先进入环中，并一直在环中循环，而当&lt;code&gt;second&lt;/code&gt;指针进入环时，由于&lt;code&gt;first&lt;/code&gt;指针速度快，将会在某个循环时刻追上&lt;code&gt;second&lt;/code&gt;指针，这样当两个指针重合后就能够判断出链表存在环，下面附上C++代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Definition for singly-linked list.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * struct ListNode {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     int val;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     ListNode *next;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *     ListNode(int x) : val(x), next(NULL) {}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * };
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; hasCycle(ListNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;head) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (head &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
        }
        ListNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next;
        ListNode &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; second) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (first &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; first&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; false;
            }
            second &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; second&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next;
            first &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; first&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;next;
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; true;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 862 和至少为K的最短子数组</title>
        <link>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
        <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
        
        <guid>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
        <description>&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;返回 &lt;code&gt;A&lt;/code&gt; 的最短的非空连续子数组的长度，该子数组的和至少为 &lt;code&gt;K&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果没有和至少为 &lt;code&gt;K&lt;/code&gt; 的非空子数组，返回 &lt;code&gt;-1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;输入：A = [1], K = 1
输出：1

输入：A = [1,2], K = 4
输出：-1

输入：A = [2,-1,2], K = 3
输出：3
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;提示&#34;&gt;提示&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 1 &amp;lt;= A.length &amp;lt;= 50000
2. -10 ^ 5 &amp;lt;= A[i] &amp;lt;= 10 ^ 5
3. 1 &amp;lt;= K &amp;lt;= 10 ^ 9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先对于我这样一个不怎么有基础的人来说，这道题着实是令我作呕。。解题也是通过了其它题解的启发。下面就开始吧。&lt;/p&gt;
&lt;h2 id=&#34;解题想法&#34;&gt;解题想法&lt;/h2&gt;
&lt;p&gt;由于题目中已经明确表示了数组的长度为50000，因此如果要使用暴力接法，势必造成O(n^2)的时间复杂度。因此就要想办法让i， j两个循环变量只跑一遍。而对于这道题因为绕不开要求取数组中的区间和。所以可以采用的一个方法是前缀和思想。大致的意思就是sum[i] = array[0] + array[1] + &amp;hellip; + array[i - 1]利用这个前缀和数组就可以较为方便的得到一个数组的区间和，例如要知道区间[1, 3]的和，我们可以利用前缀和数组得到sum[4] - sum[1]（&lt;strong&gt;这里需要注意的是，为了便于计算前缀和数组的第零个元素默认为零&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;解决了前缀和之后就要解决更加关键的问题，如何能够得到最短长度的和最小序列。首先我们不妨先这么想，如果我们当前的索引为i， 此时若区间[0, i]的和比区间[0, i - 1]的和要小，那么就不需要再考虑i - 1这个位置的索引了（&lt;strong&gt;因为这个时候有sum[A.length] - sum[i] &amp;gt; sum[A.length] - sum[i - 1] 且前者的区间长度要小于后者&lt;/strong&gt;）而这个时候就要原先的存储的&lt;code&gt;i - 1&lt;/code&gt;这个索引弹出，再将更优的&lt;code&gt;i&lt;/code&gt;索引加入。这个时候可以利用队列这样的数据结构来保存。有了这个存删的机制就可以保证每次能够得到的长度都是最短且和最大的。之后就是获得长度的问题了。如果这个队列中还有元素的话，就从当前遍历到的索引&lt;code&gt;i&lt;/code&gt;的前缀和减去队列头部保存的索引，即（&lt;strong&gt;&lt;code&gt;sum[i] - sum[queue.front()]&lt;/code&gt;&lt;/strong&gt;）这个条件需要满足题目中给出的K。由此可以看出这个队列需要两端都能出，因此我们需要维护一个单调递增的双端队列。下面附上C++代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; shortestSubarray(vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; vec, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; threshold) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec.size();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; minLength &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5e4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;;
        deque&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; dque;
        vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sum(len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化前缀和数组
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; len; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            sum[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sum[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; vec[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;i) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
                &lt;span style=&#34;color:#75715e&#34;&gt;// 满足性质就将队列尾部的索引给删除不再考虑
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (dque.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sum[dque.back()] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; sum[i]) {
                    dque.pop_back();
                }
                &lt;span style=&#34;color:#75715e&#34;&gt;// 从队列头部开始寻找满足条件的最短区间
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 如果不满足条件就要将队列头部元素删除
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (dque.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sum[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum[dque.front()] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; threshold) {
                    minLength &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(minLength, i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; dque.front());
                    dque.pop_front();
                }
            }
            dque.push_back(i);
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; minLength &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5e4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; minLength;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        
    </channel>
</rss>
