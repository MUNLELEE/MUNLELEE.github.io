<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on 墨纹</title>
    <link>https://MUNLELEE.github.io/categories/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on 墨纹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 07 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://MUNLELEE.github.io/categories/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL学习（六） 索引 第二篇</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%85%AD-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%BA%8C%E7%AF%87/</link>
      <pubDate>Sat, 07 Feb 2026 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%85%AD-%E7%B4%A2%E5%BC%95-%E7%AC%AC%E4%BA%8C%E7%AF%87/</guid>
      <description>前言 在之前的索引篇章中基本上讲述了MySQL中常见的几种索引，在这篇中，打算续上之前的索引的部分，讲述MySQL使用索引过程中的一些隐藏机制。&#xA;为什么MySQL会选错索引 在MySQL中一张表其实是可以支持多个索引的。但是，你写SQL语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由MySQL来确定的。因此就会存在这样一种情况，一条本来可以执行很快的SQL语句因为MySQL选错了索引，导致执行速度变得很慢。&#xA;先来看一个简单的例子，首先我们创建一张表：&#xA;CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`) ) ENGINE=InnoDB; 然后，我们往表t中插入10万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到(100000,100000,100000)。&#xA;然后执行这样一条SQL语句 mysql&amp;gt; select * from t where a between 10000 and 20000;&#xA;使用explain命令查看语句执行情况，得到的结果如下图所示&#xA;从结果上看，语句选择了索引a，也是情理之中。之后，在这张插入10万条数据的表中，再进行如下操作：&#xA;session A 和 session B的执行流程 其中，call idata()是执行一个存储过程，这个存储过程就是之前用来插入10万条数据。&#xA;这时候，session B的查询语句 select * from t where a between 10000 and 20000 就不会再选择索引a了。我们可以通过慢查询日志（slow log）来查看一下具体的执行情况。为了说明优化器选择的结果是否正确，增加了一个对照，即：使用force index(a)来让优化器强制使用索引a，实验过程为以下三条SQL语句</description>
    </item>
    <item>
      <title>如何实现动态配置</title>
      <link>https://MUNLELEE.github.io/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sun, 26 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 在一个项目中，经常会遇到这样一个需求，希望能够在程序运行过程中，直接动态变更某些属性配置。这些动态变更的配置可能包括降级和切量开关等等。&#xA;当然，如果是一个微服务项目，动态配置这一功能实现显然是可以通过注册中心（Nacos）来满足。但实际上，亦可以通过代码本身来实现这个功能。在这篇博客中就使用 Java反射+Redis发布/订阅 的方式来实现。&#xA;实现方法 在真正开始实现前，不妨可以想想技术路线。能够知道的是， Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。 这个能力显然和需求十分匹配。那么如何能够在反射时知道要修改哪些字段以及修改的值是什么呢？前者可以通过自定义注解来实现，在希望进行动态配置的字段上添加相应的注解作为标记，当Spring扫描Bean对象时就可以管理这些类的属性。后者可以通过Redis的发布/订阅来实现（其实也就是消息队列），监听某一个topic获取相应要更改的值。&#xA;经过上面的描述，要自己实现动态配置大概可以分为以下几个步骤：&#xA;添加一个自定义注解，用于Spring扫描Bean对象的时候，可以直接管理这些配置了自定义注解的类的属性。 给服务类的属性添加自定义注解，这里的服务类也就是包含了动态配置属性的对象。 添加一个动态配置管理的工厂，用来自动完成属性信息的填充和动态变更操作 业务的使用，这里会调用步骤2中的属性服务。当配置有变动时，可以把配置信息直接刷新到内存属性上。 实现动态变更接口，当调用相应接口时，触发Redis的发布/订阅，以此来更新类上的属性。 自定义注解的实现和使用 自定义注解 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD}) @Documented public @interface DCCValue { String value() default &amp;#34;&amp;#34;; } 按照常规方式配置一个自定义注解，同时具有一个value属性值，默认值为空字符串即可。&#xA;自定义注解的使用 @Service public class DCCService { // 是否降级 @DCCValue(&amp;#34;downgradeSwitch:0&amp;#34;) private String downgradeSwitch; // 是否切量 @DCCValue(&amp;#34;cutRange:100&amp;#34;) private String cutRange; public boolean isDowngradeSwitchOn() { return &amp;#34;1&amp;#34;.equals(downgradeSwitch); } public boolean isCutRange(String userId) { int hashCode = Math.abs(userId.hashCode()); // 获取最后两位 int lastTwoDigit = hashCode % 100; if (lastTwoDigit &amp;lt;= Integer.</description>
    </item>
    <item>
      <title>链式多分支规则树模型</title>
      <link>https://MUNLELEE.github.io/post/%E9%93%BE%E5%BC%8F%E5%A4%9A%E5%88%86%E6%94%AF%E8%A7%84%E5%88%99%E6%A0%91%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 26 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E9%93%BE%E5%BC%8F%E5%A4%9A%E5%88%86%E6%94%AF%E8%A7%84%E5%88%99%E6%A0%91%E6%A8%A1%E5%9E%8B/</guid>
      <description>前言 最新在学习项目的时候发现了一个很巧妙的设计模式，虽然长期处于MVC架构的桎梏下，遇见这种设计模式难免令人眼前一亮，遂打算记录一下。&#xA;背景 项目背景是在一个拼团活动的场景下。对于这么一个业务，当点击进入商品页面时，如果商品存在优惠信息我们总是能够看到优惠之后的价格，这也就是商品的试算。这时候不妨想想，如果有多种优惠活动，会产生不同的优惠金额，那么要怎么实现这种逻辑呢？在传统的MVC架构下，最常见的可能就是将不同的优惠活动使用不同的Service进行封装，在商品试算的时候使用if else来决定采用哪种优惠策略。但这显然是不够优雅的，如果是在DDD架构下，设计模式能够摆脱MVC的限制，从而更好的融合到项目中，这也就是这篇博客要阐述的内容，即”链式多分支规则树模型“&#xA;碍于笔者的技术所限，MVC架构应当也有一些其他的方式能够避免上述if else的情况，这里权且就不再深究&#xA;链式多分支规则树模型 先整体看一下模型的结构，如下图所示&#xA;链式多分支规则树模型结构 首先，定义抽象的通用的规则树模型结构。涵盖；StrategyMapper - 策略映射器、StrategyHandler - 策略处理器、AbstractStrategyRouter&amp;lt;T, D, R&amp;gt; - 策略路由抽象类。通过泛型设计允许使用方可以自定义出入参和动态上下文，让抽象模板模型具有通用性。 之后，由使用方自定义出工厂、功能抽象类和一个个流程流转的节点。这些节点可以自由组装进行流转，相比于责任链它的实现方式更具有灵活性。 策略处理器 策略处理器的接口代码如下所示：&#xA;public interface StrategyHandler&amp;lt;T, D, R&amp;gt; { /** 默认处理 */ /// 函数式接口，因此DEFAULT等效于一个始终返回null的apply方法的有效实现 StrategyHandler DEFAULT = (T, D) -&amp;gt; null; /** * 处理业务流程 * @param requestParam 入参 * @param dynamicContext 上下文 * @return 返回参数 * @throws Exception */ R apply(T requestParam, D dynamicContext) throws Exception; } 策略处理器用来处理执行的业务流程。在每个业务流程执行时，如果有某些数据是前面的节点到后面的节点都会使用到的，那么就可以将这些数据存放到上下文中。同时，实现一个默认的处理器，对所有的入参都返回空。可以用来停止流程。&#xA;策略映射器 策略映射器的接口代码如下：&#xA;public interface StrategyMapper&amp;lt;T, D, R&amp;gt; { /** * 获取对应的策略处理器 * @param requestParam 入参 * @param dynamicContext 上下文 * @return 返回参数 * @throws Exception */ StrategyHandler&amp;lt;T, D, R&amp;gt; get(T requestParam, D dynamicContext) throws Exception; } 策略映射器提供了 get方法来获取策略处理器，也就相当于获取业务流程的每个节点，这也就避免了将所有逻辑都写到一个类中。</description>
    </item>
    <item>
      <title>如何正确地停止线程</title>
      <link>https://MUNLELEE.github.io/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B/</guid>
      <description>前言 通常情况下，我们不会手动停止一个线程，而是允许线程运行到结束，然后让它自然停止。但是依然会有许多特殊的情况需要我们提前停止线程，比如：用户突然关闭程序，或程序运行出错重启等。在这种情况下，即将停止的线程在很多业务场景下仍然很有价值。尤其是我们想写一个健壮性很好，能够安全应对各种场景的程序时，正确停止线程就显得格外重要。&#xA;为什么不强制停止？ 对于Java来说，最正确的停止线程的方式就是使用 interrupt。但是 interrupt仅仅是起到通知被停止线程的作用。对于被停止的线程来说，它拥有完全的自主权， 既可以选择立即停止，也可以选择过一段时间后再停止，甚至压根不停止。 在Java中，程序通过互相通知、相互协作来管理线程，如果不了解线程的工作贸然停止可能会造成一些安全问题。就比如线程正在写入一个文件，但是收到了终止信号，这时候线程就要根据自身业务情况决定是立即停止还是写完文件再停止，如果选择立即停止可能会造成数据的不完整。&#xA;interrupt 如何使用interrupt终止线程？ 一般来说，被停止线程总是需要不断的判断线程是否收到了终止信号，常见的循环如下：&#xA;while (Thread.currentThread().isInterrupted() &amp;amp;&amp;amp; do sth.) { // do sth. of thread; } 接下来用代码来看看Java是怎么实现停止线程的逻辑的。一旦调用某个线程的interrupt方法之后，这个线程的中断标志位就会被置为true。 每个线程都有这样的标志位，当线程执行时应该定期检查这个标志位，如果标志位被置为true，说明有程序想要终止该线程。 示例代码如下：&#xA;public class StopThread implements Runnable { @Override public void run() { int cnt = 0; while (!Thread.currentThread().isInterrupted() &amp;amp;&amp;amp; cnt &amp;lt;= 1000) { System.out.println(cnt++); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(new StopThread()); thread.start(); Thread.sleep(2); thread.interrupt(); } } 此时会得到如下输出：</description>
    </item>
    <item>
      <title>MySQL学习（五）| 锁</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%94-%E9%94%81/</link>
      <pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%94-%E9%94%81/</guid>
      <description>前言 数据库锁的设计初衷是处理并发问题。根据加锁的范围，MySQL里的锁大致可以分为 全局锁、 表级锁 和 行级锁 三类。&#xA;全局锁 全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。 全局锁的典型使用场景是，做全库逻辑备份。&#xA;如果使用全局锁对整个库进行备份（期间整个库都处于只读状态），会有以下的问题：&#xA;如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆； 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。 如果在备份时不加锁，容易出现并发问题。这里用网站给出的例子稍微解释：&#xA;假设要维护用户账户余额和课程表，现在发起一个逻辑备份。假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。如果时间顺序上是先备份账户余额表 (u_account)，然后用户购买，然后备份用户课程表 (u_course)，流程示意图如下：&#xA;从图中可以看出，用户余额没有扣减，但是却多出了一门课，也就是用户赚了。同样，如果先备份用户课程表再备份用户账户表，就会发现用户亏了。&#xA;官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。也就是在可重复读的隔离级别下开启一个事务。但是这种方法只适用于所有表使用事务引擎的库。&#xA;这里还有一个问题，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？，不使用这个方法的原因有两点：&#xA;在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。 表级锁 MySQL里的表级锁有两种： 表锁 和 元数据锁（meta data lock，MDL）&#xA;表锁 **表锁的语法是 lock tables [table_name] read/write ** 。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。 需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</description>
    </item>
    <item>
      <title>MySQL学习（四）| 索引</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Thu, 03 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E7%B4%A2%E5%BC%95/</guid>
      <description>前言 索引是数据库中重要的概念，简单来说，索引就像是书的目录一样，其目的就是为了提高数据查询效率。&#xA;索引的常见模型 索引的出现是为了提高查找效率，但是实现索引的方式有很多种，这里介绍三种常见的索引结构。&#xA;哈希表 哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。&#xA;和Java类似，当链表过长时会影响查询效率，Java中的HashMap首先是会进行数组的扩容，在一定阈值后将拉链表转换为红黑树。&#xA;假设现在维护一个身份证信息和姓名的表，使用哈希索引的示意图如下：&#xA;假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。 需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。&#xA;所以，哈希表这种结构适用于只有等值查询的场景，而有序数组在等值查询和范围查询的性能都较好。&#xA;有序数组 依旧使用上面的例子，如果使用有序数组作为索引结构，示意图如下：&#xA;这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。这种索引结构同样支持范围查询，如果要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。&#xA;如果单纯看查询效率，有序数组是一个不错的存储结构，但当更新数据时，需要移动插入位置后的所有元素，成本较大。因此，有序数据索引结构只适合静态存储引擎&#xA;二叉搜搜索树 二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&amp;gt; UserC -&amp;gt; UserF -&amp;gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。&#xA;为了维持O(log(N))的查询复杂度，需要保持搜索树为平衡二叉树，因此更新元素的时间复杂度也为O(log(N))。&#xA;更多情况下并不使用二叉搜索树作为索引。数据库索引不仅存在内存中，还要存储到磁盘里，不可避免的会涉及到读盘操作。二叉搜索树随着节点的增多，树高将不断增长，进行一次查询需要读取的数据块较多，就会导致查询效率降低。&#xA;InnoDB的索引模型 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在InnoDB里面对应一棵B+树。</description>
    </item>
    <item>
      <title>MySQL学习（三）| 事务</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%89-%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 01 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%89-%E4%BA%8B%E5%8A%A1/</guid>
      <description>前言 在和数据库打交道，事务总是绕不开的。简单说，事务就是要保证一组数据库操作要么全部成功，要么全部失败。 在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。&#xA;隔离性与隔离级别 事务具有四大特性，也就是常说的ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），这里打算说说隔离性。&#xA;当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。&#xA;隔离级别越高，效率就会越低。 SQL的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。&#xA;读未提交，一个事务还没提交时，它做出的变更就能被其他事务看到 读提交，一个事务提交之后，它做出的变更才能被其他事务看到 可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在这个级别下，未提交的变更对其他事务也是不可见的。 串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 下面对这几种隔离级别进行简单解释。假设数据表T中只有一列，其中一行的值为1，下面是按照时间顺序执行的两个事务的行为。&#xA;在不同的隔离级别下，图中V1、V2、V3会得到不同的值&#xA;若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。 在实际实现上，数据库会创建一个视图，访问得到的就是视图的逻辑结果。在“可重复读”这个隔离级别下，视图是在事务启动时创建的，整个事务存在期间都是用这个视图；在“读提交”，视图是在每个SQL语句开始执行之后创建的；在“读未提交”这个隔离级别下，没有视图的概念，直接返回记录的最新值；在“串行化”隔离级别下，则是直接使用加锁的方式来避免并行访问</description>
    </item>
    <item>
      <title>MySQL学习（二）| 日志系统</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 30 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>前言 在了解了查询语句之后，再来了解一下更新语句的执行流程。&#xA;对于如下这个表，有一个主键ID和整型字段c：&#xA;create table T(ID int primary key, c int); 如果要将ID=2的行的字段 c 加一，那么SQL语句就会这么写&#xA;update T set c = c + 1 where ID = 2; 在之前讲述过MySQL的整体架构，准确来说，查询语句经历的流程更新语句也会走一遍。首先执行前需要先连接数据库，又因为这是对表进行更新的语句，因此会将查询缓存清空，接下来分析器进行词法分析和语法分析确定这是一条更新语句。优化器决定使用ID这个索引，最后交由执行器执行。&#xA;与查询流程不一样的是，更新流程涉及两个重要的日志模块，redo log（重做日志）和binlog（归档日志）。&#xA;redo log 对于不断到来的修改记录，数据库自然需要对应的存储方式。如果记录不多，可以将记录存储在缓存中，当数据量大的后，日志系统不可避免的要存储到磁盘中。此时有两种存储方式&#xA;一种是直接对对应的记录进行增减。 另一种直接记录当前的操作记录，待之后空闲再进行所有记录的核算。 在高并发的情况下，第二种方式无疑是较为合理的，避免了先在所有数据中找到对应的记录之后才能添加修改日志。&#xA;MySQL就是是这样，如果每次更新都需要写入磁盘，磁盘也需要找到对应的那条记录再进行更新，整个过程的IO成本和查找成本都很高。&#xA;具体说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，也就是WAL技术，全称是Write-Ahead-Logging，关键就是先写日志再写磁盘。&#xA;为什么说redo log减少了磁盘随机写的IO性能消耗？&#xA;如果没有redo log，那么每次写入都需要写入磁盘，而数据在磁盘中是随机存储的，会有寻道时间，如果是写入redo log，因为是顺序写入，不需要考虑寻道，所以性能就提升上来了。&#xA;InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么内存就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。如下图所示&#xA;write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。&#xA;write pos 和 checkpoint 之间的是还可以使用的内存大小，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示内存满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。&#xA;有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe 。</description>
    </item>
    <item>
      <title>MySQL学习（一）| 基础架构</title>
      <link>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Fri, 27 Jun 2025 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</guid>
      <description>已经许久没有更新过博客了，曾经的热情似乎早已不再。在经历过一些人和事之后，觉得还是有必要重启这个博客，回归打算就从MySQL开始吧，经好友推荐了解到了《MySQL45讲》，之前的数据库基础实在是有点薄弱，打算趁此机会正式学习一下这个数据库。&#xA;MySQL基础架构 MySQL逻辑架构 如图所示，是MySQL的基础架构，大体可以分为server层和存储引擎层两部分。Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现。存储引擎层负责数据的存储和提取。其架构模式是插件式的，最常用的存储引擎是InnoDB，也是MySQL的默认存储引擎。当然，我们也可以在建表时使用 engine=MyISAM 来更改存储引擎。&#xA;值得一提是，MySQL8.0取消了查询缓存这个模块，原因自然是查询缓存存在弊端和局限性。同时由于现代缓存redis发展的成熟，将缓存置于客户端也有更多的好处。这些内容有机会再另开一篇博客稍作解释吧。&#xA;连接器 第一步，在连接到数据库之后，首先通过的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：&#xA;mysql -h$ip -P$port -u$user -p$password 在经过 TCP握手 之后，连接器就会开始认证你的身份。&#xA;如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。 一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。&#xA;如果连接断开之后（如果客户端长期处于空闲，MySQL也会将连接中断，由参数 wait_timeout 控制），客户端再次发送请求，就会发生错误，此时需要进行重连。这里区分了 长连接 和 短连接 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。&#xA;建立连接的过程较为复杂，实际使用中要减少建立连接的动作，因此尽量使用长连接。&#xA;但是全部使用长连接后，MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。&#xA;如何解决这种问题？&#xA;定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。 查询缓存 因为新版的MySQL已经舍弃了这一部分，所以不作过多介绍。只需要知道MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以键值对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。&#xA;但是查询缓存的失效十分频繁，只要有针对表的更新，那么关于这个表的查询缓存就会被清空。&#xA;分析器 分析器首先会进行“词法分析”，识别出里面的字符串分别是什么，代表什么。之后进行“语法分析”，根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。&#xA;如果查询的字段在表中不存在，那么在分析器阶段就会报错&#xA;优化器 经过分析器，MySQL就知道要做什么了，在执行之前还需要经过优化器处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：&#xA;mysql&amp;gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20; 此时优化器要决定先取出t1表的数据还是t2表的数据再进行关联。虽然是一样的逻辑，但可能有不一样的执行效率。&#xA;执行器 到了执行器之后就开始正式执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。对于如下的这个语句，若ID字段没有索引，那么执行流程如下&#xA;select * from T where ID = 10; 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中； 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 参考 MySQL45讲——01 基础架构：一条SQL查询语句是如何执行的？ </description>
    </item>
    <item>
      <title>Redis二三事（一）</title>
      <link>https://MUNLELEE.github.io/post/redis%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B8%80/</link>
      <pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/redis%E4%BA%8C%E4%B8%89%E4%BA%8B%E4%B8%80/</guid>
      <description>想来既然决定了走Java这条路，那么一定是绕不开redis了，redis的使用以及其原理也算是一门艺术了，希望通过博文把一些常见的redis问题和操作记录下来。&#xA;前言 在当前的数据库体系中有两大类型的数据库，一类是关系型数据库，另一类为非关系型数据库。关系型数据库典型的数据结构是表，是由二维表及其之间的联系所组成的数据组。非关系型数据库严格上来说不是一种数据库，而是一种 数据结构化存储方法的集合，可以是文档或者键值对等。 两者的优缺点如下&#xA;关系型数据库 优点 缺点 使用方便，SQL语言较为通用，可以用于复杂查询 高并发读写性能较差，在海量数据的读写场景中性能较差，硬盘的IO是一个无法避免的瓶颈 易于维护，都是使用表结构，格式一致 灵活度较低，表结构固定，DDL修改对业务影响较大 复杂操作，可用于一个表以及多个表之间的复杂查询 支持事务控制 非关系型数据库 优点 缺点 读写速度快，可以存储在内存中，不依赖于硬盘 不支持join等复杂连接操作 数据格式灵活，可以是键值对，文档、图片等，扩展性强 事务处理能力弱 缺乏数据完整性约束 不提供SQL支持 redis简介 Redis（Remote Dictionary Server），即远程字典服务，是一个用C语言编写可基于内存亦可以持久化的日志型，Key-Value数据库。是非关系型数据库的一种解决方案，也是目前业界主流的缓存解决方案组件。&#xA;why redis redis性能优秀，能够支持每秒大量的读写操作，还支持集群，分布式、主从同步等配置。同时支持一定的事务能力，保证了高并发场景下的数据的安全和一致性。还有一点，redis的社区十分活跃。其优点如下：&#xA;redis优点 通常情况下，redis作为MySQL等数据库的缓存层使用。为什么要有缓存？如果在这样一个场景，当大量的数据请求访问MySQL，过多的请求可能会导致MySQL服务器压力过大，甚至会因为过量的请求将数据库击穿，数据服务也会因此中断。此时如果有缓存，那么数据访问请求将会先通过缓存再到达数据库，一旦请求在缓存中得到响应，将不会再查询数据库，这会很大的减少数据库的压力。简单描述如下图：&#xA;什么数据可以放在redis 这个问题其实一直萦绕在脑海里很久，在网上翻阅了一段时间也没有找到描述得较为详细的，更多的是应用的具体场景，但在我看来都不够抽象。看来这个问题也只有不断的在实践中去寻找答案了。这里就稍微简单描述一下&#xA;不需要实时更新但是又极其消耗数据库的数据。例如网上的商品销售排行榜，这种数据只需要每隔一段时间统计即可，其实时性关注度并不高。 更新频率不高，但是访问比较频繁的数据。这类数据如果放置于缓存能够一定程度上减少数据库的访问压力。如用户个人资料，设置完成后并不会频繁更新，但是为了个性化服务可能会频繁访问。 需要实时更新，但是更新频率不高的数据。比如一个用户的订单列表，用户的订单显然是需要实时呈现的，但是频繁下单的情况又比较少。 在某个时刻访问量极大而且更新也很频繁的数据。种数据有一个很典型的例子就是秒杀，在秒杀那一刻，可能有N倍于平时的流量进来，系统压力会很大。但是这种数据使用的缓存不能和普通缓存一样，这种缓存必须保证不丢失，否则会出现一致性等问题。 redis缓存问题 缓存雪崩 定义 大量或全部缓存数据突然失效或消失，导致所有请求都直接打到数据库上，数据库在巨大的压力下响应缓慢或宕机，应用性能急剧下降，就像雪崩一样。&#xA;触发原因 同步过期。如果你将大量缓存设置为在同一时间过期。突然间，所有数据都需要重新加载到缓存中，这时候所有的请求都会转到数据库上，导致瞬间流量激增。 系统重启。有时系统维护或意外的服务重启会导致所有缓存失效。当服务再次上线，所有的请求都会涌向空无一物的缓存，然后转向数据库。 Redis服务宕机。硬件故障、网络问题或配置错误都可能导致Redis服务不可用。此时所有的请求都会打向数据库。 热点key消失。在某些情况下，特定的热点key（被大量频繁访问的key）如果失效或被删除，也会导致相应的大量请求直接落到数据库上，造成局部的雪崩效应。 解决方案 过期策略改进 随机过期时间。给缓存项设置随机的过期时间可以防止它们同时失效。例如，希望缓存大约在1小时后过期，可以设置过期时间为60±10分钟。 细粒度过期。对于一些热点数据，可以使用更细粒度的过期时间。如使用不同的过期时间策略针对不同类型或频率访问。 预防措施 合理设置缓存失效时间。根据应用的具体情况合理设置缓存的失效时间，避免大量缓存同时过期。对于不同的数据和业务场景，失效时间应该有所不同。 持久化策略。利用Redis的RDB或AOF持久化机制，确保在系统重启后缓存可以被恢复，减少对数据库的压力。 备份机制。确保有备份和灾难恢复计划，当缓存服务器出现问题时，可以快速恢复或切换到备份系统。 热点数据处理 识别热点数据。监控和识别访问频率特别高的数据。这些数据是潜在的热点，需要特别关注。 分布式锁。对于热点key的更新操作，可以使用分布式锁来确保同一时间只有一个请求去构建新的缓存，避免大量请求同时击中数据库。 使用队列。对于高频更新的热点数据，可以使用消息队列来缓冲和序列化处理请求。 降级和限流 服务降级。在缓存雪崩或其他系统异常时，可以暂时关闭一些非核心功能，保证核心功能的正常运作。 请求限流。通过算法（如令牌桶、漏桶等）限制访问频率，确保系统在承受范围内。 缓存穿透 定义 当请求查询的数据在缓存中不存在时（也不存在于数据库中），请求便会“穿透”缓存层直接查询数据库。在正常情况下，缓存系统会减轻对数据库的访问压力，但在缓存穿透的情况下，大量的无效请求会直接落在数据库上，导致数据库负载激增，甚至可能导致服务瘫痪。&#xA;触发原因 恶意攻击&#xA;攻击者可能会故意请求缓存中不存在的数据。这种攻击通常旨在使应用程序变慢或崩溃，从而达到拒绝服务的效果。&#xA;系统缺陷&#xA;设计缺陷。如果系统没有妥善处理不存在的数据请求，例如未设置合理的默认行为或缓存策略，那么即使是正常的用户行为也可能导致缓存穿透。 数据不一致。在有些情况下，缓存和数据库之间的数据不同步也可能导致缓存穿透。 错误的用户输入</description>
    </item>
    <item>
      <title>优雅的使用AOP实现参数校验</title>
      <link>https://MUNLELEE.github.io/post/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8aop%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</link>
      <pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8aop%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</guid>
      <description>如题所述，本篇博文就是使用AOP方法实现参数校验，同时利用了自定义注解。第一次见到这个做法的时候觉得甚是巧妙，故此记录。&#xA;AOP 首先解释一下什么是AOP，AOP（Aspect Orient Programming）是spring框架中的一个重要部分。直译过来就是面向切面编程，这是一种编程思想，作为面向对象的一种补充。其本质就是在不改变源代码的情况下给程序或一组程序动态统一的添加额外功能。&#xA;用一个具体的例子来讲，假如我们有如下这么个类，用来实现简单的四则运算。&#xA;@NoArgsConstructor @AllArgsConstructor public class Operation { private int num1; private int num2; public int add() { return num1 + num2; } public int sub() { return num1 - num2; } public int mul() { return num1 * num2; } public int div() { return num1 / num2; } } 如果我们希望在每个方法运行前打印出一行日志信息，很容易想到的就是在操作类中的每个方法返回之前加上 logger.info()，虽然很简单，但是当源代码无法修改或者十分繁杂的时候，工程量将会呈几何倍数增加。此时会更希望将这个日志方法抽象为一个类，当每个方法执行时，能够自动的在方法返回之前打印出日志。如下图，AOP其实就是由切面对象和目标对象组成的代理对象。&#xA;AOP示意图 自定义注解实现参数校验 假定有以下这个用户类（ User），它有两个字段 name和 password，希望实现对用户名的非空判断和对密码的长度判断。&#xA;@Data @NoArgsConstructor public class User { private String name; private String password; } 直观的做法就是在控制器方法上，对获得的用户对象或者是相应的请求参数进行if的条件判断。诚然，这十分有效，但如果换个角度，需要进行参数校验的类不止有User，且控制器方法也不止一个。那么还要一个一个的去添加if条件吗？甚至当控制器方法无法修改时呢？于是，使用一个类或者是一个注解抽象出这个功能就显得一劳永逸了。这也就是AOP强大的解耦能力。</description>
    </item>
    <item>
      <title>机器学习算法 | K近邻</title>
      <link>https://MUNLELEE.github.io/post/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</guid>
      <description>K近邻算法 K近邻是一种有监督学习算法。因为没有对数据进行训练，而是通过新数据与旧数据的比较得到相应的结果。因此是一种隐式的学习过程和训练过程。K近邻算法可以用来解决分类问题，也可以用来解决回归问题。&#xA;步骤 对未知类别的属性的数据集中的每个点依次执行以下操作：&#xA;计算已知类别数据集中点与当前点之间的距离 按照距离递增次序排序 选取与当前点距离最小的k个点 确定前k个点所在的类别出现的频率 返回前k个点出现频率最高的类别作为当前点的预测分类 在确定样本和当前点的距离时，通常采用的是欧式距离公式$$d=\sqrt{(x_1-x_0)+(y_1-y_0)}$$ 当公式中的指数变化时，随之也会得到相应的不同的距离公式。&#xA;如下图所示的例子中&#xA;1、当采用实线的圆作为k近邻的范围，也就是$k=3$时，此时与绿点距离更近的三个点中，三角形出现的频率更大，因此将绿点归为三角形一类&#xA;2、当采用虚线的圆作为k近邻的范围，也就是$k=5$，时，此时与绿点距离更近的五个点中，正方形的频率更大，因此将绿点归为正方形一类。&#xA;以下采用鸢尾花作为例子进行KNN测试&#xA;代码 import numpy as np import pandas as pd from sklearn.datasets import load_iris import matplotlib.pyplot as plt iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) # print(df) df[&amp;#39;label&amp;#39;] = iris.target # print(len(df)) 150 # 绘散点图 # print(df.info()) # 显示数据类型 # 前两个特征 Colors = [] for i in range(df.shape[0]): item = df.iloc[i, -1] # 定位到标签 if item == 0: Colors.</description>
    </item>
    <item>
      <title>岛屿问题 | DFS框架</title>
      <link>https://MUNLELEE.github.io/post/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 02 Apr 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</guid>
      <description>在DFS这一块一直是比较弱的，因此就去看了DFS相关的一些题目，并找到了岛屿的一系列问题。&#xA;岛屿数量 岛屿的最大面积 最大人工岛 封闭岛屿的数目 岛屿的周长 图类DFS方法 图通常是由方格组成，通过方格中的元素来对图的DFS进行限制。岛屿问题便是其中经典的一类。在岛屿问题中，通常由$1$表示陆地，由$2$表示海洋，当每个方格都相邻时，组成的一个全$1$方格域即为一个岛屿。（这里不包含对角相邻）&#xA;DFS框架 DFS也是一种意义上的递归，因此在一个DFS程序中首先要做的便是设定递归出口。类似于树结构可以利用指针为空等条件，在岛屿问题中，我们需要判断边界，也需要判断当前方格是否是陆地。因此在递归出口设置中就需要两个条件进行限制。&#xA;之后DFS就要考虑下一步搜索与前一轮搜索之间的区别。岛屿问题中最主要的区别便是遍历方格的四个邻格，其余的区别便需要依题目而定。因此我们可以得到以下的岛屿类问题的DFS框架&#xA;class Solution { private: bool inRange(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int x, int y) { if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; grid.size() &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; grid[0].size()) { return true; } return false; } void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int pos_x, int pos_y) { if (!inRange(grid, pos_x, pos_y)) return; if (grid[pos_x][pos_y] != 1) return; dfs(grid, pos_x - 1, pos_y); dfs(grid, pos_x + 1, pos_y); dfs(grid, pos_x, pos_y + 1); dfs(grid, pos_x, pos_y - 1); } } 避免重复遍历 在DFS中一个重要的问题就是要避免重复遍历，不然可能会造成程序原地打转的现象。在岛屿一类的问题中，可以将已经遍历过的方块修改其元素为$0$或者为非题中给出元素。因此我们可以修改上述的DFS模板如下</description>
    </item>
    <item>
      <title>应用层协议——HTTP</title>
      <link>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE-http/</guid>
      <description>HTTP协议概述 概况 Web的应用层协议是超文本传输协议（HTTP）。HTTP协议由两个程序实现：一个客户程序和一个服务器程序，通过交换HTTP报文进行会话。&#xA;HTTP定义了Web页面的方式，以及服务器向客户传送Web页面的方式。并 使用TCP作为它的支撑运输协议 。HTTP客户首先发起一个与服务器的TCP链接。连接建立，彼此之间就可以通过 套接字接口 访问TCP。从而利用套接字接口接受和发送HTTP报文。通信过程如下图所示&#xA;由于TCP为HTTP提供可靠数据传输服务，因此每个报文都能完整地到达服务器或客户，HTTP协议不关心TCP从网络种如何处理报文的各种问题，也不用担心数据丢失。但又由于服务器只为客户服务，并不存储任何关于客户的状态信息，因此HTTP协议是一个 无状态协议 ，如果需要保存客户的登录信息，则 需要引入相关技术来记录状态，如Cookie 。&#xA;持续和非持续连接 在实际情况中，客户可能会发出一系列请求并且服务器会对每个请求进行响应。而这种客户-服务器的交互是经过TCP进行的，因此这些请求是经过单独的TCP连接还是经过相同的TCP连接就是这种交互方式的关键问题。也因此诞生了持续和非持续的HTTP连接。&#xA;非持续连接： 使用非持续连接，每个TCP连接在服务器 发送一个对象后就关闭 （对象即HTML文件以及网页图像等），每个TCP连接只传输一个请求报文和一个响应报文。&#xA;非持续连接有以下缺点：&#xA;必须为每个请求的对象建立和维护一个全新的连接。对于这样的连接要分配TCP缓冲区和保持TCP变量。造成服务器负担。 每个对象经受两倍的RTT交付时间，即一个RTT用于创建，一个RTT用于请求和接受. 持续连接： 服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送，而如果一条连接经过一定时间间隔（配置好的超时间隔）仍未被使用，HTTP服务器就应该关闭这个连接。&#xA;HTTP连接流程 （1）、 客户端连接到Web服务器。 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80端口），建立一个TCP套接字连接。&#xA;（2）、 发送HTTP请求。 通过TCP套接字，客户端向HTTP服务器发送一个文本的请求报文。&#xA;（3）、 服务器接受请求并返回HTTP响应。 Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，由客户端读取。&#xA;（4）、 释放TCP连接。 若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭TCP连接并释放。反之若为keepalive，则TCP连接会保持一段时间，在这段时间内可以继续接受请求和响应。&#xA;（5）、 客户端浏览器解析HTML内容。 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取相应的HTML，根据HTML语法对其进行格式化，并在浏览器窗口显示。&#xA;HTTP报文 HTTP请求报文 请求报文格式如下图。其中第一行称为 请求行 ，其后继的行称为 首部行 。&#xA;请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以区包括GET、POST、HEAD、PUT和DELETE。这些请求方法将会在下文讲述。&#xA;首部行则会包含Host字段，Connection字段以及User-agent字段等。分别指明了对象所在的主机、是否使用持续连接以及用户代理（发送请求的浏览器类型）。其中Host首部行则是Web代理高速缓存所要求的。&#xA;HTTP响应报文 响应报文的格式如下图。分为 状态行 ， 首部行 以及 实体体 三个部分。实体体为报文的主要部分，为所请求的对象本身。同样在首部行会包含一些字段。例如：Date：指示发送该报文的日期和时间；Server：指示发送的服务器；Last-Modified：最后修改的日期和时间等。&#xA;HTTP状态码 由上述HTTP响应报文可以得出，在状态行中包含状态码字段，这个字段将指示请求的结果。可以将状态码分为以下几类：&#xA;1xx： 指示信息 ，表示请求已接收，继续处理 2xx： 成功 ，表示请求已被成功接收、理解、接受 3xx： 重定向 ，要完成请求必须进行进一步的操作 4xx： 客户端错误 ，请求有语法错误或请求无法实现 5xx： 服务器端错误 ，服务器未能实现合法请求 常见的状态码如下：</description>
    </item>
    <item>
      <title>LeetCode 二叉搜索树与双向链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。&#xA;为了让您更好地理解问题，以下面的二叉搜索树为例：&#xA;我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。&#xA;下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点&#xA;特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。&#xA;解题想法 题目给出的是一棵二叉搜索树，而要我们整理成一个升序的双向链表，可以很自然的想到二叉搜索树的中序遍历即为升序序列。面对双向链表，我们还需要建立相邻结点之间的关系，因此需要设置前驱结点pre和当前结点cur两个指针来组织结点之间的关系。（具体即为pre-&amp;gt;right = cur和cur-&amp;gt;left = pre），最后则是连接头结点和尾结点。&#xA;中序遍历流程 令recur为中序遍历函数&#xA;1、终止条件：当cur结点为空时，直接返回，说明此时已经越过了叶节点&#xA;2、递归左子树，recur（cur-&amp;gt;left）&#xA;3、构建相邻结点之间的关系&#xA;（a）、如果pre指针为空，说明当前访问的结点为中序遍历的第一个结点，也就是双向链表的头结点，此时将当前结点cur赋值给head指针。&#xA;（b）、如果pre指针非空，需要建立两个结点之间的关系，即pre-&amp;gt;right = cur和cur-&amp;gt;left = pre&#xA;（c）、更新前驱结点pre，即pre = cur&#xA;4、递归右子树，recur（cur-&amp;gt;right）&#xA;最后在执行函数中，需要利用head和pre指针建立双向链表的头尾关系，即head-&amp;gt;left = pre，pre-&amp;gt;right = head，因为当递归完二叉搜索树时，pre会指向中序的最后一个元素。&#xA;代码 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { private: Node *head, *pre; void recur(Node *root) { if (root == NULL) return; recur(root-&amp;gt;left); // 如果pre为空，说明当前访问的是头结点 if (pre) pre-&amp;gt;right = root; else head = root; root-&amp;gt;left = pre; // 修改当前的结点为前驱结点 pre = root; recur(root-&amp;gt;right); } public: Node* treeToDoublyList(Node* root) { if (root == NULL) return NULL; recur(root); head-&amp;gt;left = pre; pre-&amp;gt;right = head; return head; } }; </description>
    </item>
    <item>
      <title>LeetCode 矩阵中的路径</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。&#xA;单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。&#xA;例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。&#xA;示例：&#xA;输入：board = [[&amp;#34;A&amp;#34;,&amp;#34;B&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;E&amp;#34;],[&amp;#34;S&amp;#34;,&amp;#34;F&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;S&amp;#34;],[&amp;#34;A&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;E&amp;#34;,&amp;#34;E&amp;#34;]], word = &amp;#34;ABCCED&amp;#34;&#xD;输出：true 输入：board = [[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;],[&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;]], word = &amp;#34;abcd&amp;#34;&#xD;输出：false 解题想法 这道题一开始想到的是使用BFS，但是细想发现BFS好像很难处理回溯的问题，应该采用DFS。然后，就是递归的痛了，也借这道题学习一下DFS的写法吧。&#xA;**DFS：**即是暴力遍历矩阵的所有元素，来搜索一条可行的路径，通过递归，可以在一条路径中搜索到底，最后回溯到之前已经匹配的节点。&#xA;**剪枝：**在DFS过程中如果当前的矩阵字符与字符串字符不等，可以直接回溯。或者路径已经访问过，可以直接跳过。&#xA;DFS解析 1、递归终止条件：&#xA;（a）、返回true，当匹配到字符串的最后一个字符时，可以直接返回true（至于为什么可以这样返回，参看代码注释）&#xA;（b）、返回false，如果矩阵的索引越界，当前矩阵的字符和字符串的字符不匹配，当前元素已经访问过了直接返回false&#xA;2、递归过程&#xA;（a）、选定当前元素，将当前元素标记为空字符，表明当前元素已经访问过，防止走回头路。&#xA;（b）、搜索下一个元素，向四个方向分别匹配字符，如果有一个方向可以匹配就继续递归这个方向的DFS算法，并返回true，否则返回false&#xA;（c）、还原当前元素，需要在DFS算法退出之前，将空字符还原为原来的字符，用于回溯时重新寻找路径，否则回溯将找不到正确路径。&#xA;代码 class Solution { public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { rows = board.size(); cols = board[0].size(); for (int i = 0; i &amp;lt; rows; ++i) { for (int j = 0; j &amp;lt; cols; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; } private: int rows, cols; // k为单词索引 bool dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt; &amp;amp;board, string word, int i, int j, int k) { // 如果越界或者字符不相等，就停止递归 if (i &amp;gt;= rows || i &amp;lt; 0 || j &amp;gt;= cols || j &amp;lt; 0 || board[i][j] !</description>
    </item>
    <item>
      <title>LeetCode 最长不含重复字符的子字符串</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&#xA;示例&#xA;输入: &amp;#34;abcabcbb&amp;#34;&#xD;输出: 3 解释: 因为无重复字符的最长子串是 &amp;#34;abc&amp;#34;，所以其长度为 3。 输入: &amp;#34;bbbbb&amp;#34;&#xD;输出: 1&#xD;解释: 因为无重复字符的最长子串是 &amp;#34;b&amp;#34;，所以其长度为 1。 输入: &amp;#34;pwwkew&amp;#34;&#xD;输出: 3&#xD;解释: 因为无重复字符的最长子串是 &amp;#34;wke&amp;#34;，所以其长度为 3。&#xD;请注意，你的答案必须是 子串 的长度，&amp;#34;pwke&amp;#34; 是一个子序列，不是子串。 解题想法 这道题想通了发现也是一道比较常规的动态规划题，但是开始时没有考虑好的细节确实是折磨了我一阵。以及没有想到用哈希表处理属实比较蠢。&#xA;动态规划 1、状态的定义，本题依旧需要一个一维的动态规划数组，dp[i]则表示以第i个字符为结尾的子字符串可以得到的最长的含不重复字符的子字符串长度。&#xA;2、状态转移方程，首先我们需要固定右边界i，也就是遍历时的索引，设与s[i]相同且距离最近的字符为s[pos]（pos初始化为-1。此时不重复字符子串长度应该是i - pos，但是题目所求为最长，因此根据动态规划的思想就有以下的情况&#xA;（a）、当$pos&amp;lt;0$时，说明在s[i]的左侧没有与s[i]相同的字符，那么dp[i] = dp[i - 1] + 1（即最长长度等于遍历到前一字符的长度 + 1）&#xA;（b）、当$dp[i - 1]&amp;lt;i - pos$时，说明重复的字符应该在当前最长非重复字符子串的区间外，即在这个子串的左边，此时dp[i] = dp[i - 1] + 1，也就是之前的子串再加上当前的字符。&#xA;（c）、当$dp[i - 1]&amp;gt;=i-pos$​时，说明此时重复的字符应该在当前最长的非重复字符子串的区间内，因此dp[i] = i - pos，也就是在之前的子串中截取出非重复的部分。&#xA;3、需要一个哈希表用来记录曾经出现过的字符的相对应的索引，每当遍历到一个重复字符时，便要将哈希表中的相应表项更新为当前的索引。&#xA;由以上的分析可以看出，dp[i]只由dp[i - 1]决定，所以可以省略动态规划的数组，采用一个变量进行迭代即可，并求取此变量在这个过程中的最大值。&#xA;双指针法（滑动窗口） 由于滑动窗口的代码写得比较少，当看到题解有滑动窗口时，便又学习了一下。</description>
    </item>
    <item>
      <title>LeetCode 股票的最大利润</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？&#xA;示例：&#xA;输入: [7,1,5,3,6,4]&#xD;输出: 5&#xD;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&#xD;注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 输入: [7,6,4,3,1]&#xD;输出: 0&#xD;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题想法 这道题首先可以采用暴力的求解方法，只要计算在某一天中，其后的每一天卖出的价钱所得的利润最大，依次遍历每一天，最终就可以求得最大利润，这样可以得到的时间复杂度为$$(n-1)+(n-2)+&amp;hellip;+2+1=n(n-1)/2$$也就是$O(n^2)$，不出所料，在这种解法中，你需要将一些冗余的操作去除，才能通过力扣的判题机。于是就有了下面的解法，也就是动态规划。&#xA;动态规划思路 1、状态的定义，首先需要声明一个动态规划数组dp，其中dp[i]表示以第i天为最后一天的子数组所能获得的最大利润。&#xA;2、状态转移方程，由于股票只能买卖一次，因此dp[i]（也就是前i天的最大利润），应该是前i-1天的最大利润与第i天卖出股票的利润的最大值，于是就有了$前i天最大利润=max（前i-1天最大利润，第i天价格-前i天最低价格）$即为dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i]))，最终返回dp[n-1]为所求。&#xA;优化 我们还可以进行空间和时间上的优化，时间上，可以借助一个变量cost来维护最小值，这样每次进行状态转移时只需要dp[i] = max(dp[i - 1], prices[i] - min(cost, prices[i]))，空间上，由于本道题的状态转移只需要前一次的状态，因此可以采用一个变量maxprofit来代替整个动态规划列表，这样状态转移就简化为了maxprofit = max(maxprofit, prices[i] - min(cost, prices[i]))&#xA;代码 /*未优化*/ class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { if (prices.</description>
    </item>
    <item>
      <title>LeetCode 树的子结构</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&#xA;B是A的子结构， 即 A中有出现和B相同的结构和节点值。&#xA;例如: 给定的树 A:&#xA;3&#xD;/ \&#xD;4 5&#xD;/ \&#xD;1 2 给定的树 B：&#xA;4&#xD;/&#xD;1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。&#xA;解题想法 树的题目是真的让人头疼。在经过几次暴力解的尝试之后我还是放弃了，最后几组数据总是通过不了。还是去翻了题解，发现又是我最烦的递归（永远的痛）&#xA;1、首先子结构要么是其本身要么在树的左子树或者右子树里，因此在isSubStructure函数中需要判断是本身匹配还是左子树或者是右子树匹配，这是最外层递归。最外层递归中，如果B树（也就是子结构树）为空，那么直接返回false，同理如果A树（要从这棵树中寻找子结构）为空也可以直接返回false&#xA;2、对于子结构是否匹配的判断也需要通过递归实现（也就是isContain函数），但具有以下几种情况，其中包含退出递归的条件&#xA;（a）、如果当前的B树为空，且At树（也就是从A树种截取出的子树）非空或者空，此时表明B树是A树的一个子结构，因为可以将B树匹配完。&#xA;（b）、如果当前的B树非空，但At树为空，说明此时已经遍历过了A树的叶节点，那么B树一定与At树不匹配，可以直接返回false&#xA;（c）、如果此时At树和B树都不为空，且当前匹配中的结点的值不相等，那么B树一定与At树不匹配，可以直接返回false&#xA;（d）、如果At树和B树都不为空，且当前匹配中的结点的值相等，那么就继续匹配两棵树当前结点的左结点和右结点（也就是内层的递归）&#xA;代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isContain(TreeNode *A, TreeNode *B) { // 递归判断是否包含 // 如果此时B为空树，说明已经递归完了B树，因此是包含的 if (B == NULL) return true; // 如果大树为空，匹配树不是空，那么说明不包含 if (A == NULL) return false; // 如果当前匹配的结点值不相等，那么也是不包含 if (A-&amp;gt;val !</description>
    </item>
    <item>
      <title>LeetCode 从上到下打印链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。&#xA;例如: 给定二叉树: [3,9,20,null,null,15,7],&#xA;3&#xD;/ \&#xD;9 20&#xD;/ \&#xD;15 7 返回其层次遍历结果：&#xA;[&#xD;[3],&#xD;[9,20],&#xD;[15,7]&#xD;] 解题想法 这道题本身并不是什么难题，也很明显可以看出是一个层序遍历的变种，解决问题的关键就在于如何区分当前层和下一层，最开始是打算使用pair将每个结点与其相应的层序号对应起来。但在实际写代码时发现有点困难，最后还是去翻了题解，发现了利用空指针作为层与层之间分隔的方法。具体做法就是在第一次入队时再入队一个空指针，之后利用队头元素不为空指针作为内循环的判断，如果队头为空，则表明了已经循环完了一层。而由于二叉树的特点，在使用层序遍历时，遍历完一层也即代表着下一层的非空结点已经完全入队，这时便可以再入队一个空指针作为下一个分隔结点。利用这样的循环就能做到以层为序来打印层序遍历。&#xA;代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; res; if (root == NULL) { return res; } queue&amp;lt;TreeNode*&amp;gt; que; // 用于层序遍历 que.</description>
    </item>
    <item>
      <title>LeetCode 复杂链表的复制</title>
      <link>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。&#xA;示例 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]&#xD;输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 解题 题目的意思很简单，就是返回一个一模一样的链表头结点。由于随机指针的存在，链表的复制不能够像正常链表那样直接遍历，也因此没想明白要怎么做，最后翻了题解，才发现又是我最烦的递归。&#xA;这道题采用的递归解法其实本质就是遇到问题再解决问题，在还没有开始复制之前，所有的复制结点都是虚无的，要让这些结点和已知的结点一一对应起来就需要一个map数据结构。用来对应新旧两个链表的结点。这样从第一个结点入手，当这个结点不在map中时，就立刻创建这个结点并于原链表中的相应结点建立对应关系。之后的每一个结点都可以根据这样的逻辑进行创建，而因为有map这个数据结构的存在，这样每个结点都不是虚空存在的，而是可以在map中找到与之对应的结点。可以解决随机结点创建的问题。具体代码如下：&#xA;class Solution { public: unordered_map&amp;lt;Node*, Node*&amp;gt; um; // 用来存储两个链表，结点之间一一对应 Node* copyRandomList(Node* head) { if (head == NULL) { // 如果链表本就为空，那么直接返回空 return NULL; } // 遵循边遍历边创建的原则 if (!um.count(head)) { // 如果此时哈希表中没有这个结点，就直接创建 Node* headNew = new Node(head-&amp;gt;val); // 初始化一个相同的结点 um.insert(make_pair(head, headNew)); // 将这两个位置一样的结点对应起来 headNew-&amp;gt;next = copyRandomList(head-&amp;gt;next); // 同理下一个结点也应该这样拷贝，依旧遵循上面的原则 headNew-&amp;gt;random = copyRandomList(head-&amp;gt;random); } // 如果这个结点已经在哈希表中存在，那么就直接返回 return um[head]; } }; </description>
    </item>
    <item>
      <title>LeetCode 141 环形链表</title>
      <link>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>题目描述 给定一个链表，判断链表中是否有环。&#xA;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&#xA;如果链表中存在环，则返回 true 。 否则，返回 false 。&#xA;示例 在这里插入图片描述 输入：head = [3,2,0,-4], pos = 1&#xD;输出：true&#xD;解释：链表中有一个环，其尾部连接到第二个节点。 在这里插入图片描述 输入：head = [1,2], pos = 0&#xD;输出：true&#xD;解释：链表中有一个环，其尾部连接到第一个节点。 在这里插入图片描述 输入：head = [1], pos = -1&#xD;输出：false&#xD;解释：链表中没有环。 提示 链表中节点的数目范围是 [0, 104]&#xD;-105 &amp;lt;= Node.val &amp;lt;= 105&#xD;pos 为 -1 或者链表中的一个 有效索引 。 解题想法 这道题在leetcode上属于简单题，但由于第一次遇见这种解法（也由于第一次想错了，根本不是正解）所以就想记录一下。 很明显题目要判断链表中是否有环，于是可以想到如果在链表中有两个指针分别向前跑，当两个指针指向的结点相同的时候便证明链表中有环存在。这个时候就需要一个循环来判断两个指针是否相等。此时条件应该是first != second因此如果我们初始化两个指针在同一个位置，那么将无法进入循环，因此需要将两个指针分别初始化在头结点以及头结点的下一个结点，还要注意的是，first指针的速度应该要快于second指针的速度，这样，当链表中有环时，first指针会先进入环中，并一直在环中循环，而当second指针进入环时，由于first指针速度快，将会在某个循环时刻追上second指针，这样当两个指针重合后就能够判断出链表存在环，下面附上C++代码&#xA;/** * Definition for singly-linked list.</description>
    </item>
    <item>
      <title>LeetCode 862 和至少为K的最短子数组</title>
      <link>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://MUNLELEE.github.io/post/leetcode-862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>题目描述 返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。&#xA;如果没有和至少为 K 的非空子数组，返回 -1&#xA;示例 输入：A = [1], K = 1&#xD;输出：1&#xD;输入：A = [1,2], K = 4&#xD;输出：-1&#xD;输入：A = [2,-1,2], K = 3&#xD;输出：3 提示 1. 1 &amp;lt;= A.length &amp;lt;= 50000&#xD;2. -10 ^ 5 &amp;lt;= A[i] &amp;lt;= 10 ^ 5&#xD;3. 1 &amp;lt;= K &amp;lt;= 10 ^ 9 首先对于我这样一个不怎么有基础的人来说，这道题着实是令我作呕。。解题也是通过了其它题解的启发。下面就开始吧。&#xA;解题想法 由于题目中已经明确表示了数组的长度为50000，因此如果要使用暴力接法，势必造成O(n^2)的时间复杂度。因此就要想办法让i， j两个循环变量只跑一遍。而对于这道题因为绕不开要求取数组中的区间和。所以可以采用的一个方法是前缀和思想。大致的意思就是sum[i] = array[0] + array[1] + &amp;hellip; + array[i - 1]利用这个前缀和数组就可以较为方便的得到一个数组的区间和，例如要知道区间[1, 3]的和，我们可以利用前缀和数组得到sum[4] - sum[1]（这里需要注意的是，为了便于计算前缀和数组的第零个元素默认为零）</description>
    </item>
  </channel>
</rss>
